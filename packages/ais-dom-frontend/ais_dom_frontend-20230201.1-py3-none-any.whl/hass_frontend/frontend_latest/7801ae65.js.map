{"version":3,"file":"7801ae65.js","mappings":";;AA+CA;;AAEA;AACA;AACA;;;AAKA;;AAEA;AACA;AACA;;AAKA;AACA;AAGA;AACA;AACA;AAGA;AAKA;AAJA;;;;;;;;;;;;;;;;AAmGA;;;;;;;;;;;;;AClIA;;;;;;;;;;;;;;;;;;;;ACCA;AC3CA;AAuDA;;AAIA;AACA;AACA;AACA;;;AAKA;AAeA;AAKA;;AAGA;;AAGA;;AAGA;AACA;;;;AAQA;;AAMA;AACA;;;AAhHA;;AAuHA;;AAKA;;;AA5HA;;;AAoIA;;AAKA;;;AAzIA;;;AAkJA;;;;;AAgCA;AACA;;;AAGA;;;AAIA;AACA;;;;;AAMA;AACA;;;;;;;AAQA;;;;;;;;;;;;;;;;;AAqDA","sources":["webpack://home-assistant-frontend/./src/components/entity/ha-entity-toggle.ts","webpack://home-assistant-frontend/./src/components/ha-formfield.ts","webpack://home-assistant-frontend/./src/components/ha-switch.ts","webpack://home-assistant-frontend/./src/panels/aistts/ha-panel-aisttsauto.ts"],"sourcesContent":["import { mdiFlash, mdiFlashOff } from \"@mdi/js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { property, state } from \"lit/decorators\";\nimport { STATES_OFF } from \"../../common/const\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { isUnavailableState, UNAVAILABLE, UNKNOWN } from \"../../data/entity\";\nimport { forwardHaptic } from \"../../data/haptics\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-formfield\";\nimport \"../ha-icon-button\";\nimport \"../ha-switch\";\n\nconst isOn = (stateObj?: HassEntity) =>\n  stateObj !== undefined &&\n  !STATES_OFF.includes(stateObj.state) &&\n  !isUnavailableState(stateObj.state);\n\nexport class HaEntityToggle extends LitElement {\n  // hass is not a property so that we only re-render on stateObj changes\n  public hass?: HomeAssistant;\n\n  @property() public stateObj?: HassEntity;\n\n  @property() public label?: string;\n\n  @state() private _isOn = false;\n\n  protected render(): TemplateResult {\n    if (!this.stateObj) {\n      return html` <ha-switch disabled></ha-switch> `;\n    }\n\n    if (\n      this.stateObj.attributes.assumed_state ||\n      this.stateObj.state === UNKNOWN\n    ) {\n      return html`\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} off`}\n          .path=${mdiFlashOff}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOff}\n          class=${!this._isOn && this.stateObj.state !== UNKNOWN\n            ? \"state-active\"\n            : \"\"}\n        ></ha-icon-button>\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} on`}\n          .path=${mdiFlash}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOn}\n          class=${this._isOn ? \"state-active\" : \"\"}\n        ></ha-icon-button>\n      `;\n    }\n\n    const switchTemplate = html`<ha-switch\n      aria-label=${`Toggle ${computeStateName(this.stateObj)} ${\n        this._isOn ? \"off\" : \"on\"\n      }`}\n      .checked=${this._isOn}\n      .disabled=${this.stateObj.state === UNAVAILABLE}\n      @change=${this._toggleChanged}\n    ></ha-switch>`;\n\n    if (!this.label) {\n      return switchTemplate;\n    }\n\n    return html`\n      <ha-formfield .label=${this.label}>${switchTemplate}</ha-formfield>\n    `;\n  }\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n    this.addEventListener(\"click\", (ev) => ev.stopPropagation());\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"stateObj\")) {\n      this._isOn = isOn(this.stateObj);\n    }\n  }\n\n  private _toggleChanged(ev) {\n    const newVal = ev.target.checked;\n\n    if (newVal !== this._isOn) {\n      this._callService(newVal);\n    }\n  }\n\n  private _turnOn() {\n    this._callService(true);\n  }\n\n  private _turnOff() {\n    this._callService(false);\n  }\n\n  // We will force a re-render after a successful call to re-sync the toggle\n  // with the state. It will be out of sync if our service call did not\n  // result in the entity to be turned on. Since the state is not changing,\n  // the resync is not called automatic.\n  private async _callService(turnOn): Promise<void> {\n    if (!this.hass || !this.stateObj) {\n      return;\n    }\n    forwardHaptic(\"light\");\n    const stateDomain = computeStateDomain(this.stateObj);\n    let serviceDomain;\n    let service;\n\n    if (stateDomain === \"lock\") {\n      serviceDomain = \"lock\";\n      service = turnOn ? \"unlock\" : \"lock\";\n    } else if (stateDomain === \"cover\") {\n      serviceDomain = \"cover\";\n      service = turnOn ? \"open_cover\" : \"close_cover\";\n    } else if (stateDomain === \"group\") {\n      serviceDomain = \"homeassistant\";\n      service = turnOn ? \"turn_on\" : \"turn_off\";\n    } else {\n      serviceDomain = stateDomain;\n      service = turnOn ? \"turn_on\" : \"turn_off\";\n    }\n\n    const currentState = this.stateObj;\n\n    // Optimistic update.\n    this._isOn = turnOn;\n\n    await this.hass.callService(serviceDomain, service, {\n      entity_id: this.stateObj.entity_id,\n    });\n\n    setTimeout(async () => {\n      // If after 2 seconds we have not received a state update\n      // reset the switch to it's original state.\n      if (this.stateObj === currentState) {\n        this._isOn = isOn(this.stateObj);\n      }\n    }, 2000);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        white-space: nowrap;\n        min-width: 38px;\n      }\n      ha-icon-button {\n        --mdc-icon-button-size: 40px;\n        color: var(--ha-icon-button-inactive-color, var(--primary-text-color));\n        transition: color 0.5s;\n      }\n      ha-icon-button.state-active {\n        color: var(--ha-icon-button-active-color, var(--primary-color));\n      }\n      ha-switch {\n        padding: 13px 5px;\n      }\n    `;\n  }\n}\n\ncustomElements.define(\"ha-entity-toggle\", HaEntityToggle);\n","import { FormfieldBase } from \"@material/mwc-formfield/mwc-formfield-base\";\nimport { styles } from \"@material/mwc-formfield/mwc-formfield.css\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\n\n@customElement(\"ha-formfield\")\nexport class HaFormfield extends FormfieldBase {\n  protected _labelClick() {\n    const input = this.input;\n    if (input) {\n      input.focus();\n      switch (input.tagName) {\n        case \"HA-CHECKBOX\":\n        case \"HA-RADIO\":\n          if ((input as any).disabled) {\n            break;\n          }\n          (input as any).checked = !(input as any).checked;\n          fireEvent(input, \"change\");\n          break;\n        default:\n          input.click();\n          break;\n      }\n    }\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host(:not([alignEnd])) ::slotted(ha-switch) {\n        margin-right: 10px;\n        margin-inline-end: 10px;\n        margin-inline-start: inline;\n      }\n      .mdc-form-field > label {\n        direction: var(--direction);\n        margin-inline-start: 0;\n        margin-inline-end: auto;\n        padding-inline-start: 4px;\n        padding-inline-end: 0;\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-formfield\": HaFormfield;\n  }\n}\n","import { SwitchBase } from \"@material/mwc-switch/deprecated/mwc-switch-base\";\nimport { styles } from \"@material/mwc-switch/deprecated/mwc-switch.css\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { forwardHaptic } from \"../data/haptics\";\n\n@customElement(\"ha-switch\")\nexport class HaSwitch extends SwitchBase {\n  // Generate a haptic vibration.\n  // Only set to true if the new value of the switch is applied right away when toggling.\n  // Do not add haptic when a user is required to press save.\n  @property({ type: Boolean }) public haptic = false;\n\n  protected firstUpdated() {\n    super.firstUpdated();\n    this.addEventListener(\"change\", () => {\n      if (this.haptic) {\n        forwardHaptic(\"light\");\n      }\n    });\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--switch-checked-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__thumb {\n        background-color: var(--switch-checked-button-color);\n        border-color: var(--switch-checked-button-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__track {\n        background-color: var(--switch-checked-track-color);\n        border-color: var(--switch-checked-track-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__thumb {\n        background-color: var(--switch-unchecked-button-color);\n        border-color: var(--switch-unchecked-button-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__track {\n        background-color: var(--switch-unchecked-track-color);\n        border-color: var(--switch-unchecked-track-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-switch\": HaSwitch;\n  }\n}\n","import \"../../components/ha-card\";\nimport \"../../components/ha-menu-button\";\nimport \"@material/mwc-icon-button\";\nimport {\n  mdiHistory,\n  mdiInformationOutline,\n  mdiPencil,\n  mdiElectricSwitch,\n} from \"@mdi/js\";\nimport \"@polymer/paper-tooltip/paper-tooltip\";\nimport { css, html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { property, customElement } from \"lit/decorators\";\nimport \"@polymer/polymer/lib/elements/dom-repeat\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { navigate } from \"../../common/navigate\";\nimport \"../../components/entity/ha-entity-toggle\";\nimport \"../../components/ha-fab\";\nimport \"../../components/ha-svg-icon\";\nimport \"../../components/ha-button-related-filter-menu\";\nimport { triggerAutomationActions } from \"../../data/automation\";\nimport { haStyle } from \"../../resources/styles\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { HomeAssistant } from \"../../types\";\nimport { formatDateTime } from \"../../common/datetime/format_date_time\";\nimport memoizeOne from \"memoize-one\";\nimport { HassEntityBase } from \"home-assistant-js-websocket\";\nimport { HaCheckbox } from \"../../components/ha-checkbox\";\n// eslint-disable-next-line import/no-duplicates\nimport \"../../components/data-table/ha-data-table\";\nimport {\n  DataTableColumnContainer,\n  DataTableRowData,\n  // eslint-disable-next-line import/no-duplicates\n} from \"../../components/data-table/ha-data-table\";\n\nexport interface AutomationRowData extends DataTableRowData {\n  id: string;\n  name: string | undefined;\n  last_triggered: string;\n  entity: HassEntityBase;\n}\n\n@customElement(\"ha-panel-aisttsauto\")\nclass HaPanelAisTtsAuto extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean }) public isWide!: boolean;\n\n  @property({ type: Boolean }) public narrow!: boolean;\n\n  private _columns = memoizeOne(\n    (narrow: boolean, _locale): DataTableColumnContainer => {\n      const columns: DataTableColumnContainer = {\n        toggle: {\n          title: html`&nbsp;&nbsp;&nbsp;&nbsp;<ha-svg-icon\n              path=${mdiElectricSwitch}\n            ></ha-svg-icon>`,\n          type: \"icon\",\n          template: (_toggle, automation: any) =>\n            html`\n              <ha-checkbox\n                .key=${automation.id}\n                .hass=${this.hass}\n                @change=${this._handleRowCheckboxClick}\n                .checked=${automation.entity.state === \"on\"}\n              >\n              </ha-checkbox>\n            `,\n        },\n        name: {\n          title: \"Nazwa\",\n          sortable: true,\n          filterable: true,\n          direction: \"asc\",\n          grows: true,\n        },\n      };\n\n      if (!narrow) {\n        columns.last_triggered = {\n          sortable: true,\n          width: \"20%\",\n          title: this.hass.localize(\"ui.card.automation.last_triggered\"),\n          template: (last_triggered) => html`\n            ${last_triggered\n              ? formatDateTime(new Date(last_triggered), this.hass.locale)\n              : this.hass.localize(\"ui.components.relative_time.never\")}\n          `,\n        };\n        columns.trigger = {\n          title: html`\n            <mwc-button style=\"visibility: hidden\">\n              ${this.hass.localize(\"ui.card.automation.trigger\")}\n            </mwc-button>\n          `,\n          width: \"20%\",\n          template: (_info, automation: any) => html`\n            <mwc-button\n              .automation=${automation.entity}\n              @click=${(ev) => this._runActions(ev)}\n            >\n              URUCHOM\n            </mwc-button>\n          `,\n        };\n      }\n\n      if (this.hass.user!.is_admin) {\n        columns.info = {\n          title: \"\",\n          type: \"icon-button\",\n          template: (_info, automation: any) => html`\n            <mwc-icon-button\n              .automation=${automation.entity}\n              @click=${this._showInfo}\n              label=\"Info\"\n            >\n              <ha-svg-icon .path=${mdiInformationOutline}></ha-svg-icon>\n            </mwc-icon-button>\n          `,\n        };\n        columns.trace = {\n          title: \"\",\n          type: \"icon-button\",\n          template: (_info, automation: any) => html`\n            <a\n              href=\"/config/automation/trace/${automation.entity.attributes.id}\"\n            >\n              <mwc-icon-button label=\"Ślad\">\n                <ha-svg-icon .path=${mdiHistory}></ha-svg-icon>\n              </mwc-icon-button>\n            </a>\n          `,\n        };\n        columns.edit = {\n          title: \"\",\n          type: \"icon-button\",\n          template: (_info, automation: any) => html`\n            <a\n              href=\"/config/automation/edit/${automation.entity.attributes.id}\"\n            >\n              <mwc-icon-button label=\"Edit\">\n                <ha-svg-icon path=${mdiPencil}></ha-svg-icon>\n              </mwc-icon-button>\n            </a>\n          `,\n        };\n      }\n      return columns;\n    }\n  );\n\n  protected firstUpdated(changedProps: PropertyValues): void {\n    super.firstUpdated(changedProps);\n  }\n\n  private _get_automations(_states) {\n    const l_automation: AutomationRowData[] = [];\n    Object.values(this.hass.states).forEach((entity) => {\n      if (\n        computeStateDomain(entity) === \"automation\" &&\n        !entity.entity_id.startsWith(\"automation.ais_\")\n      ) {\n        l_automation.push({\n          id: entity.entity_id,\n          name: entity.attributes.friendly_name,\n          last_triggered: entity.attributes.last_triggered,\n          entity: entity,\n        });\n      }\n    });\n    return l_automation;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-app-layout>\n        <app-header slot=\"header\" fixed>\n          <app-toolbar>\n            <ha-menu-button\n              .hass=${this.hass}\n              .narrow=${this.narrow}\n            ></ha-menu-button>\n            <div main-title>TTS Automatyczny</div>\n            ${this.hass.user!.is_admin\n              ? html`<ha-icon-button\n                  label=\"Dodaj\"\n                  icon=\"hass:plus\"\n                  @click=${this._createNew}\n                ></ha-icon-button>`\n              : html``}\n          </app-toolbar>\n        </app-header>\n        <ha-card class=\"content\">\n          <ha-data-table\n            .columns=${this._columns(this.narrow, this.hass.locale)}\n            .data=${this._get_automations(this.hass.states)}\n            auto-height\n            searchLabel=\"Szukaj\"\n            noDataText=\"Brak danych\"\n          ></ha-data-table>\n        </ha-card>\n      </ha-app-layout>\n    `;\n  }\n\n  private _showInfo(ev) {\n    ev.stopPropagation();\n    const entityId = (ev.currentTarget as any).automation.entity_id;\n    fireEvent(this, \"hass-more-info\", { entityId });\n  }\n\n  private _runActions(ev) {\n    const entityId = (ev.currentTarget as any).automation.entity_id;\n    triggerAutomationActions(this.hass, entityId);\n  }\n\n  private _createNew() {\n    navigate(\"/config/automation/edit/new\");\n  }\n\n  private _handleRowCheckboxClick(ev: Event) {\n    const key = (ev.currentTarget as any).key;\n    const hass = (ev.currentTarget as any).hass;\n    const checkbox = ev.currentTarget as HaCheckbox;\n    let mode = \"off\";\n    if (checkbox.checked) {\n      mode = \"on\";\n    }\n    hass.callService(\"ais_tts\", \"change_auto_mode\", {\n      entity_id: key,\n      change_to: mode,\n    });\n  }\n\n  static get styles() {\n    return [\n      haStyle,\n      css`\n        ha-card.content {\n          padding: 16px;\n        }\n\n        .has-header {\n          padding-top: 0;\n        }\n\n        .checked span {\n          color: var(--primary-color);\n        }\n        .content {\n          padding-bottom: 32px;\n          max-width: 94%;\n          margin: 0 auto;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-panel-aisttsauto\": HaPanelAisTtsAuto;\n  }\n}\n"],"names":[],"sourceRoot":""}