# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_command_language_python
else:
    import _tesseract_command_language_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_command_language_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_command_language_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_command_language_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_command_language_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_command_language_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_command_language_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_command_language_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_command_language_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_command_language_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_command_language_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_command_language_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_command_language_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_command_language_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_command_language_python:
_tesseract_command_language_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_command_language_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_command_language_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_command_language_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_command_language_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_command_language_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_command_language_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_command_language_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_command_language_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_command_language_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_command_language_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_command_language_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_command_language_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_command_language_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_command_language_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_command_language_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_command_language_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_command_language_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_command_language_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_command_language_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_command_language_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_command_language_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_command_language_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_command_language_python.vector_eigen_index_swiginit(self, _tesseract_command_language_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_command_language_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_command_language_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_command_language_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_command_language_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_command_language_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_command_language_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_command_language_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_command_language_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_command_language_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_command_language_python:
_tesseract_command_language_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_common.tesseract_common_python
class flattenFilterFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a: "Instruction", b: "CompositeInstruction", c: "bool") -> "bool":
        return _tesseract_command_language_python.flattenFilterFnBase_call(self, a, b, c)
    __swig_destroy__ = _tesseract_command_language_python.delete_flattenFilterFnBase

    def __init__(self):
        if self.__class__ == flattenFilterFnBase:
            _self = None
        else:
            _self = self
        _tesseract_command_language_python.flattenFilterFnBase_swiginit(self, _tesseract_command_language_python.new_flattenFilterFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_command_language_python.disown_flattenFilterFnBase(self)
        return weakref.proxy(self)

# Register flattenFilterFnBase in _tesseract_command_language_python:
_tesseract_command_language_python.flattenFilterFnBase_swigregister(flattenFilterFnBase)



class flattenFilterFn(flattenFilterFnBase):
  def __init__(self,fn):
    super(flattenFilterFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

class locateFilterFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a: "Instruction", b: "CompositeInstruction", c: "bool") -> "bool":
        return _tesseract_command_language_python.locateFilterFnBase_call(self, a, b, c)
    __swig_destroy__ = _tesseract_command_language_python.delete_locateFilterFnBase

    def __init__(self):
        if self.__class__ == locateFilterFnBase:
            _self = None
        else:
            _self = self
        _tesseract_command_language_python.locateFilterFnBase_swiginit(self, _tesseract_command_language_python.new_locateFilterFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_command_language_python.disown_locateFilterFnBase(self)
        return weakref.proxy(self)

# Register locateFilterFnBase in _tesseract_command_language_python:
_tesseract_command_language_python.locateFilterFnBase_swigregister(locateFilterFnBase)



class locateFilterFn(locateFilterFnBase):
  def __init__(self,fn):
    super(locateFilterFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

class TypeErasureInterface(object, metaclass=_SwigNonDynamicMeta):
    r""" This is the interface that all type erasures interfaces must inherit from"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_command_language_python.delete_TypeErasureInterface

    def equals(self, other: "TypeErasureInterface") -> "bool":
        return _tesseract_command_language_python.TypeErasureInterface_equals(self, other)

    def getType(self) -> "std::type_index":
        return _tesseract_command_language_python.TypeErasureInterface_getType(self)

    def recover(self, *args) -> "void const *":
        return _tesseract_command_language_python.TypeErasureInterface_recover(self, *args)

# Register TypeErasureInterface in _tesseract_command_language_python:
_tesseract_command_language_python.TypeErasureInterface_swigregister(TypeErasureInterface)

class ProfileDictionary(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This class is used to store profiles for motion planning and process planning
    This is a thread safe class
       A ProfileEntry<T> is a std::unordered_map<std::string, std::shared_ptr<const T>>
         - The key is the profile name
         - Where std::shared_ptr<const T> is the profile
       The ProfleEntry<T> is also stored in std::unordered_map where the key here is the std::type_index(typeid(T))
    Notes: When adding a profile entry the T should be the base class type.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        _tesseract_command_language_python.ProfileDictionary_swiginit(self, _tesseract_command_language_python.new_ProfileDictionary())
    __swig_destroy__ = _tesseract_command_language_python.delete_ProfileDictionary

# Register ProfileDictionary in _tesseract_command_language_python:
_tesseract_command_language_python.ProfileDictionary_swigregister(ProfileDictionary)

class WaypointInterface(TypeErasureInterface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _print(self, prefix: "std::string const &") -> "void":
        return _tesseract_command_language_python.WaypointInterface__print(self, prefix)
    __swig_destroy__ = _tesseract_command_language_python.delete_WaypointInterface

# Register WaypointInterface in _tesseract_command_language_python:
_tesseract_command_language_python.WaypointInterface_swigregister(WaypointInterface)

class Waypoint(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.Waypoint__print(self, *args)

    def as_NullWaypoint(self) -> "tesseract_planning::NullWaypoint":
        return _tesseract_command_language_python.Waypoint_as_NullWaypoint(self)

    def as_const_NullWaypoint(self) -> "tesseract_planning::NullWaypoint const":
        return _tesseract_command_language_python.Waypoint_as_const_NullWaypoint(self)

    def as_CartesianWaypoint(self) -> "tesseract_planning::CartesianWaypoint":
        return _tesseract_command_language_python.Waypoint_as_CartesianWaypoint(self)

    def as_const_CartesianWaypoint(self) -> "tesseract_planning::CartesianWaypoint const":
        return _tesseract_command_language_python.Waypoint_as_const_CartesianWaypoint(self)

    def as_JointWaypoint(self) -> "tesseract_planning::JointWaypoint":
        return _tesseract_command_language_python.Waypoint_as_JointWaypoint(self)

    def as_const_JointWaypoint(self) -> "tesseract_planning::JointWaypoint const":
        return _tesseract_command_language_python.Waypoint_as_const_JointWaypoint(self)

    def as_StateWaypoint(self) -> "tesseract_planning::StateWaypoint":
        return _tesseract_command_language_python.Waypoint_as_StateWaypoint(self)

    def as_const_StateWaypoint(self) -> "tesseract_planning::StateWaypoint const":
        return _tesseract_command_language_python.Waypoint_as_const_StateWaypoint(self)

    def __init__(self, *args):
        _tesseract_command_language_python.Waypoint_swiginit(self, _tesseract_command_language_python.new_Waypoint(*args))
    __swig_destroy__ = _tesseract_command_language_python.delete_Waypoint

# Register Waypoint in _tesseract_command_language_python:
_tesseract_command_language_python.Waypoint_swigregister(Waypoint)

class InstructionUPtr(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_command_language_python.InstructionUPtr_swiginit(self, _tesseract_command_language_python.new_InstructionUPtr(*args))

    def __deref__(self) -> "std::unique_ptr< tesseract_planning::Instruction >::pointer":
        return _tesseract_command_language_python.InstructionUPtr___deref__(self)

    def release(self) -> "std::unique_ptr< tesseract_planning::Instruction >::pointer":
        return _tesseract_command_language_python.InstructionUPtr_release(self)

    def reset(self, *args) -> "void":
        return _tesseract_command_language_python.InstructionUPtr_reset(self, *args)

    def swap(self, __u: "InstructionUPtr") -> "void":
        return _tesseract_command_language_python.InstructionUPtr_swap(self, __u)

    def get(self) -> "std::unique_ptr< tesseract_planning::Instruction >::pointer":
        return _tesseract_command_language_python.InstructionUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_command_language_python.InstructionUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_command_language_python.delete_InstructionUPtr

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.InstructionUPtr_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.InstructionUPtr_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.InstructionUPtr__print(self, *args)

    def as_NullInstruction(self) -> "tesseract_planning::NullInstruction":
        return _tesseract_command_language_python.InstructionUPtr_as_NullInstruction(self)

    def as_const_NullInstruction(self) -> "tesseract_planning::NullInstruction const":
        return _tesseract_command_language_python.InstructionUPtr_as_const_NullInstruction(self)

    def as_CompositeInstruction(self) -> "tesseract_planning::CompositeInstruction":
        return _tesseract_command_language_python.InstructionUPtr_as_CompositeInstruction(self)

    def as_const_CompositeInstruction(self) -> "tesseract_planning::CompositeInstruction const":
        return _tesseract_command_language_python.InstructionUPtr_as_const_CompositeInstruction(self)

    def as_MoveInstruction(self) -> "tesseract_planning::MoveInstruction":
        return _tesseract_command_language_python.InstructionUPtr_as_MoveInstruction(self)

    def as_const_MoveInstruction(self) -> "tesseract_planning::MoveInstruction const":
        return _tesseract_command_language_python.InstructionUPtr_as_const_MoveInstruction(self)

    def as_TimerInstruction(self) -> "tesseract_planning::TimerInstruction":
        return _tesseract_command_language_python.InstructionUPtr_as_TimerInstruction(self)

    def as_const_TimerInstruction(self) -> "tesseract_planning::TimerInstruction const":
        return _tesseract_command_language_python.InstructionUPtr_as_const_TimerInstruction(self)

    def as_WaitInstruction(self) -> "tesseract_planning::WaitInstruction":
        return _tesseract_command_language_python.InstructionUPtr_as_WaitInstruction(self)

    def as_const_WaitInstruction(self) -> "tesseract_planning::WaitInstruction const":
        return _tesseract_command_language_python.InstructionUPtr_as_const_WaitInstruction(self)

    def as_SetToolInstruction(self) -> "tesseract_planning::SetToolInstruction":
        return _tesseract_command_language_python.InstructionUPtr_as_SetToolInstruction(self)

    def as_const_SetToolInstruction(self) -> "tesseract_planning::SetToolInstruction const":
        return _tesseract_command_language_python.InstructionUPtr_as_const_SetToolInstruction(self)

    def as_SetAnalogInstruction(self) -> "tesseract_planning::SetAnalogInstruction":
        return _tesseract_command_language_python.InstructionUPtr_as_SetAnalogInstruction(self)

    def as_const_SetAnalogInstruction(self) -> "tesseract_planning::SetAnalogInstruction const":
        return _tesseract_command_language_python.InstructionUPtr_as_const_SetAnalogInstruction(self)

# Register InstructionUPtr in _tesseract_command_language_python:
_tesseract_command_language_python.InstructionUPtr_swigregister(InstructionUPtr)

class InstructionInterface(TypeErasureInterface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.InstructionInterface_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.InstructionInterface_setDescription(self, description)

    def _print(self, prefix: "std::string const &") -> "void":
        return _tesseract_command_language_python.InstructionInterface__print(self, prefix)
    __swig_destroy__ = _tesseract_command_language_python.delete_InstructionInterface

# Register InstructionInterface in _tesseract_command_language_python:
_tesseract_command_language_python.InstructionInterface_swigregister(InstructionInterface)

class Instruction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.Instruction_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.Instruction_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.Instruction__print(self, *args)

    def as_NullInstruction(self) -> "tesseract_planning::NullInstruction":
        return _tesseract_command_language_python.Instruction_as_NullInstruction(self)

    def as_const_NullInstruction(self) -> "tesseract_planning::NullInstruction const":
        return _tesseract_command_language_python.Instruction_as_const_NullInstruction(self)

    def as_CompositeInstruction(self) -> "tesseract_planning::CompositeInstruction":
        return _tesseract_command_language_python.Instruction_as_CompositeInstruction(self)

    def as_const_CompositeInstruction(self) -> "tesseract_planning::CompositeInstruction const":
        return _tesseract_command_language_python.Instruction_as_const_CompositeInstruction(self)

    def as_MoveInstruction(self) -> "tesseract_planning::MoveInstruction":
        return _tesseract_command_language_python.Instruction_as_MoveInstruction(self)

    def as_const_MoveInstruction(self) -> "tesseract_planning::MoveInstruction const":
        return _tesseract_command_language_python.Instruction_as_const_MoveInstruction(self)

    def as_TimerInstruction(self) -> "tesseract_planning::TimerInstruction":
        return _tesseract_command_language_python.Instruction_as_TimerInstruction(self)

    def as_const_TimerInstruction(self) -> "tesseract_planning::TimerInstruction const":
        return _tesseract_command_language_python.Instruction_as_const_TimerInstruction(self)

    def as_WaitInstruction(self) -> "tesseract_planning::WaitInstruction":
        return _tesseract_command_language_python.Instruction_as_WaitInstruction(self)

    def as_const_WaitInstruction(self) -> "tesseract_planning::WaitInstruction const":
        return _tesseract_command_language_python.Instruction_as_const_WaitInstruction(self)

    def as_SetToolInstruction(self) -> "tesseract_planning::SetToolInstruction":
        return _tesseract_command_language_python.Instruction_as_SetToolInstruction(self)

    def as_const_SetToolInstruction(self) -> "tesseract_planning::SetToolInstruction const":
        return _tesseract_command_language_python.Instruction_as_const_SetToolInstruction(self)

    def as_SetAnalogInstruction(self) -> "tesseract_planning::SetAnalogInstruction":
        return _tesseract_command_language_python.Instruction_as_SetAnalogInstruction(self)

    def as_const_SetAnalogInstruction(self) -> "tesseract_planning::SetAnalogInstruction const":
        return _tesseract_command_language_python.Instruction_as_const_SetAnalogInstruction(self)

    def __init__(self, *args):
        _tesseract_command_language_python.Instruction_swiginit(self, _tesseract_command_language_python.new_Instruction(*args))
    __swig_destroy__ = _tesseract_command_language_python.delete_Instruction

# Register Instruction in _tesseract_command_language_python:
_tesseract_command_language_python.Instruction_swigregister(Instruction)

class Instructions(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.Instructions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_command_language_python.Instructions___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_command_language_python.Instructions___bool__(self)

    def __len__(self) -> "std::vector< tesseract_planning::Instruction >::size_type":
        return _tesseract_command_language_python.Instructions___len__(self)

    def __getslice__(self, i: "std::vector< tesseract_planning::Instruction >::difference_type", j: "std::vector< tesseract_planning::Instruction >::difference_type") -> "std::vector< tesseract_planning::Instruction,std::allocator< tesseract_planning::Instruction > > *":
        return _tesseract_command_language_python.Instructions___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_command_language_python.Instructions___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< tesseract_planning::Instruction >::difference_type", j: "std::vector< tesseract_planning::Instruction >::difference_type") -> "void":
        return _tesseract_command_language_python.Instructions___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_command_language_python.Instructions___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< tesseract_planning::Instruction >::value_type const &":
        return _tesseract_command_language_python.Instructions___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_command_language_python.Instructions___setitem__(self, *args)

    def pop(self) -> "std::vector< tesseract_planning::Instruction >::value_type":
        return _tesseract_command_language_python.Instructions_pop(self)

    def append(self, x: "Instruction") -> "void":
        return _tesseract_command_language_python.Instructions_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_command_language_python.Instructions_empty(self)

    def size(self) -> "std::vector< tesseract_planning::Instruction >::size_type":
        return _tesseract_command_language_python.Instructions_size(self)

    def swap(self, v: "Instructions") -> "void":
        return _tesseract_command_language_python.Instructions_swap(self, v)

    def begin(self) -> "std::vector< tesseract_planning::Instruction >::iterator":
        return _tesseract_command_language_python.Instructions_begin(self)

    def end(self) -> "std::vector< tesseract_planning::Instruction >::iterator":
        return _tesseract_command_language_python.Instructions_end(self)

    def rbegin(self) -> "std::vector< tesseract_planning::Instruction >::reverse_iterator":
        return _tesseract_command_language_python.Instructions_rbegin(self)

    def rend(self) -> "std::vector< tesseract_planning::Instruction >::reverse_iterator":
        return _tesseract_command_language_python.Instructions_rend(self)

    def clear(self) -> "void":
        return _tesseract_command_language_python.Instructions_clear(self)

    def get_allocator(self) -> "std::vector< tesseract_planning::Instruction >::allocator_type":
        return _tesseract_command_language_python.Instructions_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_command_language_python.Instructions_pop_back(self)

    def erase(self, *args) -> "std::vector< tesseract_planning::Instruction >::iterator":
        return _tesseract_command_language_python.Instructions_erase(self, *args)

    def __init__(self, *args):
        _tesseract_command_language_python.Instructions_swiginit(self, _tesseract_command_language_python.new_Instructions(*args))

    def push_back(self, x: "Instruction") -> "void":
        return _tesseract_command_language_python.Instructions_push_back(self, x)

    def front(self) -> "std::vector< tesseract_planning::Instruction >::value_type const &":
        return _tesseract_command_language_python.Instructions_front(self)

    def back(self) -> "std::vector< tesseract_planning::Instruction >::value_type const &":
        return _tesseract_command_language_python.Instructions_back(self)

    def assign(self, n: "std::vector< tesseract_planning::Instruction >::size_type", x: "Instruction") -> "void":
        return _tesseract_command_language_python.Instructions_assign(self, n, x)

    def resize(self, new_size: "std::vector< tesseract_planning::Instruction >::size_type", x: "Instruction") -> "void":
        return _tesseract_command_language_python.Instructions_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _tesseract_command_language_python.Instructions_insert(self, *args)

    def reserve(self, n: "std::vector< tesseract_planning::Instruction >::size_type") -> "void":
        return _tesseract_command_language_python.Instructions_reserve(self, n)

    def capacity(self) -> "std::vector< tesseract_planning::Instruction >::size_type":
        return _tesseract_command_language_python.Instructions_capacity(self)
    __swig_destroy__ = _tesseract_command_language_python.delete_Instructions

# Register Instructions in _tesseract_command_language_python:
_tesseract_command_language_python.Instructions_swigregister(Instructions)


def isCommentInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isCommentInstruction(instruction)

def isVariableInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isVariableInstruction(instruction)

def isSetAnalogInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isSetAnalogInstruction(instruction)

def isSetToolInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isSetToolInstruction(instruction)

def isTimerInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isTimerInstruction(instruction)

def isWaitInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isWaitInstruction(instruction)

def isCompositeInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isCompositeInstruction(instruction)

def isMoveInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isMoveInstruction(instruction)

def isNullInstruction(instruction: "Instruction") -> "bool":
    return _tesseract_command_language_python.isNullInstruction(instruction)
class NullInstruction(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.NullInstruction_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.NullInstruction_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.NullInstruction__print(self, *args)

    def __eq__(self, rhs: "NullInstruction") -> "bool":
        return _tesseract_command_language_python.NullInstruction___eq__(self, rhs)

    def __ne__(self, rhs: "NullInstruction") -> "bool":
        return _tesseract_command_language_python.NullInstruction___ne__(self, rhs)

    def __init__(self):
        _tesseract_command_language_python.NullInstruction_swiginit(self, _tesseract_command_language_python.new_NullInstruction())
    __swig_destroy__ = _tesseract_command_language_python.delete_NullInstruction

# Register NullInstruction in _tesseract_command_language_python:
_tesseract_command_language_python.NullInstruction_swigregister(NullInstruction)

class NullWaypoint(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.NullWaypoint__print(self, *args)

    def __eq__(self, rhs: "NullWaypoint") -> "bool":
        return _tesseract_command_language_python.NullWaypoint___eq__(self, rhs)

    def __ne__(self, rhs: "NullWaypoint") -> "bool":
        return _tesseract_command_language_python.NullWaypoint___ne__(self, rhs)

    def __init__(self):
        _tesseract_command_language_python.NullWaypoint_swiginit(self, _tesseract_command_language_python.new_NullWaypoint())
    __swig_destroy__ = _tesseract_command_language_python.delete_NullWaypoint

# Register NullWaypoint in _tesseract_command_language_python:
_tesseract_command_language_python.NullWaypoint_swigregister(NullWaypoint)

class CartesianWaypoint(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.CartesianWaypoint__print(self, *args)

    def __init__(self, *args):
        _tesseract_command_language_python.CartesianWaypoint_swiginit(self, _tesseract_command_language_python.new_CartesianWaypoint(*args))

    def linear(self, *args) -> "Eigen::Matrix3d":
        return _tesseract_command_language_python.CartesianWaypoint_linear(self, *args)

    def translation(self, *args) -> "Eigen::Vector3d":
        return _tesseract_command_language_python.CartesianWaypoint_translation(self, *args)

    def isApprox(self, other: "Isometry3d", prec: "double"=1e-12) -> "bool":
        r"""
        :rtype: boolean
        :return: true if two are approximate
        """
        return _tesseract_command_language_python.CartesianWaypoint_isApprox(self, other, prec)

    def __imul__(self, other: "Isometry3d") -> "tesseract_planning::CartesianWaypoint &":
        return _tesseract_command_language_python.CartesianWaypoint___imul__(self, other)

    def __mul__(self, other: "Isometry3d") -> "tesseract_planning::CartesianWaypoint":
        return _tesseract_command_language_python.CartesianWaypoint___mul__(self, other)
    waypoint = property(_tesseract_command_language_python.CartesianWaypoint_waypoint_get, _tesseract_command_language_python.CartesianWaypoint_waypoint_set, doc=r""" The Cartesian Waypoint""")
    lower_tolerance = property(_tesseract_command_language_python.CartesianWaypoint_lower_tolerance_get, _tesseract_command_language_python.CartesianWaypoint_lower_tolerance_set, doc=r"""
     Distance below waypoint that is allowed. Should be size = 6. First 3 elements are dx, dy, dz. The last 3
    elements are angle axis error allowed (Eigen::AngleAxisd.axis() * Eigen::AngleAxisd.angle())
    """)
    upper_tolerance = property(_tesseract_command_language_python.CartesianWaypoint_upper_tolerance_get, _tesseract_command_language_python.CartesianWaypoint_upper_tolerance_set, doc=r"""
     Distance above waypoint that is allowed. Should be size = 6. First 3 elements are dx, dy, dz. The last 3
    elements are angle axis error allowed (Eigen::AngleAxisd.axis() * Eigen::AngleAxisd.angle())
    """)
    seed = property(_tesseract_command_language_python.CartesianWaypoint_seed_get, _tesseract_command_language_python.CartesianWaypoint_seed_set, doc=r"""
    Waypoint seed associated with this Cartesian waypoint
    The waypoint seed can be used for purposes like:
      - providing a joint state seed to an IK solver
      - providing a seed to the IK solver with modified limits using the tolerances
      - providing a joint state to be used by a motion planner for interpolation to avoid performing IK
    """)

    def isToleranced(self) -> "bool":
        r"""
        Returns true if waypoint has tolerances
        :rtype: boolean
        :return: True if waypoint has tolerances
        """
        return _tesseract_command_language_python.CartesianWaypoint_isToleranced(self)

    def __eq__(self, rhs: "CartesianWaypoint") -> "bool":
        return _tesseract_command_language_python.CartesianWaypoint___eq__(self, rhs)

    def __ne__(self, rhs: "CartesianWaypoint") -> "bool":
        return _tesseract_command_language_python.CartesianWaypoint___ne__(self, rhs)
    __swig_destroy__ = _tesseract_command_language_python.delete_CartesianWaypoint

# Register CartesianWaypoint in _tesseract_command_language_python:
_tesseract_command_language_python.CartesianWaypoint_swigregister(CartesianWaypoint)

CompositeInstructionOrder_ORDERED = _tesseract_command_language_python.CompositeInstructionOrder_ORDERED
CompositeInstructionOrder_UNORDERED = _tesseract_command_language_python.CompositeInstructionOrder_UNORDERED
CompositeInstructionOrder_ORDERED_AND_REVERABLE = _tesseract_command_language_python.CompositeInstructionOrder_ORDERED_AND_REVERABLE
class CompositeInstruction(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_command_language_python.CompositeInstruction_swiginit(self, _tesseract_command_language_python.new_CompositeInstruction(*args))

    def getOrder(self) -> "tesseract_planning::CompositeInstructionOrder":
        return _tesseract_command_language_python.CompositeInstruction_getOrder(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_setDescription(self, description)

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.CompositeInstruction_getDescription(self)

    def setProfile(self, profile: "std::string const &") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_setProfile(self, profile)

    def getProfile(self) -> "std::string const &":
        return _tesseract_command_language_python.CompositeInstruction_getProfile(self)
    profile_overrides = property(_tesseract_command_language_python.CompositeInstruction_profile_overrides_get, _tesseract_command_language_python.CompositeInstruction_profile_overrides_set, doc=r""" Dictionary of profiles that will override named profiles for a specific task""")

    def setManipulatorInfo(self, info: "ManipulatorInfo") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_setManipulatorInfo(self, info)

    def getManipulatorInfo(self, *args) -> "tesseract_planning::ManipulatorInfo &":
        return _tesseract_command_language_python.CompositeInstruction_getManipulatorInfo(self, *args)

    def setStartInstruction(self, instruction: "Instruction") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_setStartInstruction(self, instruction)

    def resetStartInstruction(self) -> "void":
        return _tesseract_command_language_python.CompositeInstruction_resetStartInstruction(self)

    def getStartInstruction(self, *args) -> "tesseract_planning::Instruction &":
        return _tesseract_command_language_python.CompositeInstruction_getStartInstruction(self, *args)

    def hasStartInstruction(self) -> "bool":
        return _tesseract_command_language_python.CompositeInstruction_hasStartInstruction(self)

    def setInstructions(self, instructions: "Instructions") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_setInstructions(self, instructions)

    def getInstructions(self, *args) -> "std::vector< tesseract_planning::Instruction,std::allocator< tesseract_planning::Instruction > > const &":
        return _tesseract_command_language_python.CompositeInstruction_getInstructions(self, *args)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.CompositeInstruction__print(self, *args)

    def __eq__(self, rhs: "CompositeInstruction") -> "bool":
        return _tesseract_command_language_python.CompositeInstruction___eq__(self, rhs)

    def __ne__(self, rhs: "CompositeInstruction") -> "bool":
        return _tesseract_command_language_python.CompositeInstruction___ne__(self, rhs)

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_command_language_python.CompositeInstruction_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_command_language_python.CompositeInstruction___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_command_language_python.CompositeInstruction___bool__(self)

    def __len__(self) -> "tesseract_planning::CompositeInstruction::size_type":
        return _tesseract_command_language_python.CompositeInstruction___len__(self)

    def __getslice__(self, i: "tesseract_planning::CompositeInstruction::difference_type", j: "tesseract_planning::CompositeInstruction::difference_type") -> "tesseract_planning::CompositeInstruction *":
        return _tesseract_command_language_python.CompositeInstruction___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_command_language_python.CompositeInstruction___setslice__(self, *args)

    def __delslice__(self, i: "tesseract_planning::CompositeInstruction::difference_type", j: "tesseract_planning::CompositeInstruction::difference_type") -> "void":
        return _tesseract_command_language_python.CompositeInstruction___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_command_language_python.CompositeInstruction___delitem__(self, *args)

    def __getitem__(self, *args) -> "tesseract_planning::CompositeInstruction::value_type const &":
        return _tesseract_command_language_python.CompositeInstruction___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_command_language_python.CompositeInstruction___setitem__(self, *args)

    def pop(self) -> "tesseract_planning::CompositeInstruction::value_type":
        return _tesseract_command_language_python.CompositeInstruction_pop(self)

    def append(self, x: "Instruction") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_command_language_python.CompositeInstruction_empty(self)

    def size(self) -> "tesseract_planning::CompositeInstruction::size_type":
        return _tesseract_command_language_python.CompositeInstruction_size(self)

    def begin(self) -> "tesseract_planning::CompositeInstruction::iterator":
        return _tesseract_command_language_python.CompositeInstruction_begin(self)

    def end(self) -> "tesseract_planning::CompositeInstruction::iterator":
        return _tesseract_command_language_python.CompositeInstruction_end(self)

    def rbegin(self) -> "tesseract_planning::CompositeInstruction::reverse_iterator":
        return _tesseract_command_language_python.CompositeInstruction_rbegin(self)

    def rend(self) -> "tesseract_planning::CompositeInstruction::reverse_iterator":
        return _tesseract_command_language_python.CompositeInstruction_rend(self)

    def clear(self) -> "void":
        return _tesseract_command_language_python.CompositeInstruction_clear(self)

    def pop_back(self) -> "void":
        return _tesseract_command_language_python.CompositeInstruction_pop_back(self)

    def erase(self, *args) -> "tesseract_planning::CompositeInstruction::iterator":
        return _tesseract_command_language_python.CompositeInstruction_erase(self, *args)

    def push_back(self, x: "Instruction") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_push_back(self, x)

    def front(self) -> "tesseract_planning::CompositeInstruction::value_type const &":
        return _tesseract_command_language_python.CompositeInstruction_front(self)

    def back(self) -> "tesseract_planning::CompositeInstruction::value_type const &":
        return _tesseract_command_language_python.CompositeInstruction_back(self)

    def reserve(self, n: "tesseract_planning::CompositeInstruction::size_type") -> "void":
        return _tesseract_command_language_python.CompositeInstruction_reserve(self, n)

    def capacity(self) -> "tesseract_planning::CompositeInstruction::size_type":
        return _tesseract_command_language_python.CompositeInstruction_capacity(self)
    __swig_destroy__ = _tesseract_command_language_python.delete_CompositeInstruction

# Register CompositeInstruction in _tesseract_command_language_python:
_tesseract_command_language_python.CompositeInstruction_swigregister(CompositeInstruction)

class JointWaypoint(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.JointWaypoint__print(self, *args)
    waypoint = property(_tesseract_command_language_python.JointWaypoint_waypoint_get, _tesseract_command_language_python.JointWaypoint_waypoint_set)
    joint_names = property(_tesseract_command_language_python.JointWaypoint_joint_names_get, _tesseract_command_language_python.JointWaypoint_joint_names_set)
    lower_tolerance = property(_tesseract_command_language_python.JointWaypoint_lower_tolerance_get, _tesseract_command_language_python.JointWaypoint_lower_tolerance_set, doc=r""" Joint distance below waypoint that is allowed. Each element should be <= 0""")
    upper_tolerance = property(_tesseract_command_language_python.JointWaypoint_upper_tolerance_get, _tesseract_command_language_python.JointWaypoint_upper_tolerance_set, doc=r""" Joint distance above waypoint that is allowed. Each element should be >= 0""")

    def isToleranced(self) -> "bool":
        r"""
        Returns true if waypoint is toleranced
        :rtype: boolean
        :return: True if waypoint is toleranced
        """
        return _tesseract_command_language_python.JointWaypoint_isToleranced(self)

    def __eq__(self, rhs: "JointWaypoint") -> "bool":
        return _tesseract_command_language_python.JointWaypoint___eq__(self, rhs)

    def __ne__(self, rhs: "JointWaypoint") -> "bool":
        return _tesseract_command_language_python.JointWaypoint___ne__(self, rhs)

    def __init__(self, *args):
        _tesseract_command_language_python.JointWaypoint_swiginit(self, _tesseract_command_language_python.new_JointWaypoint(*args))
    __swig_destroy__ = _tesseract_command_language_python.delete_JointWaypoint

# Register JointWaypoint in _tesseract_command_language_python:
_tesseract_command_language_python.JointWaypoint_swigregister(JointWaypoint)

MoveInstructionType_LINEAR = _tesseract_command_language_python.MoveInstructionType_LINEAR
MoveInstructionType_FREESPACE = _tesseract_command_language_python.MoveInstructionType_FREESPACE
MoveInstructionType_CIRCULAR = _tesseract_command_language_python.MoveInstructionType_CIRCULAR
MoveInstructionType_START = _tesseract_command_language_python.MoveInstructionType_START
r""" This indicates it is a start instruction."""
class MoveInstruction(object, metaclass=_SwigNonDynamicMeta):
    r"""
    The move instruction is used when defining the results of a motion planning request

    This instruction contains two profiles 'profile' and 'path_profile' which are similar to industrial robots
    termination type and Motion Options.
      - profile (Termination Type): is used to define a set of costs/constraints associated only with the waypoint
    assigned to this instruction
      - path_profile (Motion Options): is used to define a set of costs/constraints associated only with the path taken
    to the waypoint assigned to this instruction
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Move Instruction Constructor
        This constructor automatically assigns the path profile which is only associated to the path taken to the
        waypoint. If the motion is LINEAR/CIRCULAR it assigns the profile to the defined profile. If the motion is
        FREESPACE/START it is left empty.
        :type waypoint: :py:class:`Waypoint`
        :param waypoint: The waypoint associated with the instruction
        :type type: int
        :param type: The type of instruction (LINEAR, FREESPACE, CIRCULAR, START)
        :type profile: string, optional
        :param profile: The waypoint profile, which is only associated to the waypoint and not the path taken.
        :type manipulator_info: :py:class:`ManipulatorInfo`, optional
        :param manipulator_info: Then manipulator information

        |

        *Overload 2:*

        Move Instruction Constructor
        This constructor automatically assigns the path profile which is only associated to the path taken to the
        waypoint. If the motion is LINEAR/CIRCULAR it assigns the profile to the defined profile. If the motion is
        FREESPACE/START it is left empty.
        :type waypoint: :py:class:`Waypoint`
        :param waypoint: The waypoint associated with the instruction
        :type type: int
        :param type: The type of instruction (LINEAR, FREESPACE, CIRCULAR, START)
        :type profile: string, optional
        :param profile: The waypoint profile, which is only associated to the waypoint and not the path taken.
        :param manipulator_info: Then manipulator information

        |

        *Overload 3:*

        Move Instruction Constructor
        This constructor automatically assigns the path profile which is only associated to the path taken to the
        waypoint. If the motion is LINEAR/CIRCULAR it assigns the profile to the defined profile. If the motion is
        FREESPACE/START it is left empty.
        :type waypoint: :py:class:`Waypoint`
        :param waypoint: The waypoint associated with the instruction
        :type type: int
        :param type: The type of instruction (LINEAR, FREESPACE, CIRCULAR, START)
        :param profile: The waypoint profile, which is only associated to the waypoint and not the path taken.
        :param manipulator_info: Then manipulator information

        |

        *Overload 4:*

        Move Instruction Constructor
        :type waypoint: :py:class:`Waypoint`
        :param waypoint: The waypoint associated with the instruction
        :type type: int
        :param type: The type of instruction (LINEAR, FREESPACE, CIRCULAR, START)
        :type profile: string
        :param profile: The waypoint profile, which is only associated to the waypoint and not the path taken.
        :type path_profile: string
        :param path_profile: The waypoint path profile which is only associated to the path taken to the waypoint.
        :type manipulator_info: :py:class:`ManipulatorInfo`, optional
        :param manipulator_info: Then manipulator information

        |

        *Overload 5:*

        Move Instruction Constructor
        :type waypoint: :py:class:`Waypoint`
        :param waypoint: The waypoint associated with the instruction
        :type type: int
        :param type: The type of instruction (LINEAR, FREESPACE, CIRCULAR, START)
        :type profile: string
        :param profile: The waypoint profile, which is only associated to the waypoint and not the path taken.
        :type path_profile: string
        :param path_profile: The waypoint path profile which is only associated to the path taken to the waypoint.
        :param manipulator_info: Then manipulator information
        """
        _tesseract_command_language_python.MoveInstruction_swiginit(self, _tesseract_command_language_python.new_MoveInstruction(*args))

    def setWaypoint(self, waypoint: "Waypoint") -> "void":
        return _tesseract_command_language_python.MoveInstruction_setWaypoint(self, waypoint)

    def getWaypoint(self, *args) -> "tesseract_planning::Waypoint const &":
        return _tesseract_command_language_python.MoveInstruction_getWaypoint(self, *args)

    def setManipulatorInfo(self, info: "ManipulatorInfo") -> "void":
        return _tesseract_command_language_python.MoveInstruction_setManipulatorInfo(self, info)

    def getManipulatorInfo(self, *args) -> "tesseract_planning::ManipulatorInfo &":
        return _tesseract_command_language_python.MoveInstruction_getManipulatorInfo(self, *args)

    def setProfile(self, profile: "std::string const &") -> "void":
        return _tesseract_command_language_python.MoveInstruction_setProfile(self, profile)

    def getProfile(self) -> "std::string const &":
        return _tesseract_command_language_python.MoveInstruction_getProfile(self)

    def setPathProfile(self, profile: "std::string const &") -> "void":
        return _tesseract_command_language_python.MoveInstruction_setPathProfile(self, profile)

    def getPathProfile(self) -> "std::string const &":
        return _tesseract_command_language_python.MoveInstruction_getPathProfile(self)
    profile_overrides = property(_tesseract_command_language_python.MoveInstruction_profile_overrides_get, _tesseract_command_language_python.MoveInstruction_profile_overrides_set, doc=r""" Dictionary of profiles that will override named profiles for a specific task""")

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.MoveInstruction_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.MoveInstruction_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.MoveInstruction__print(self, *args)

    def setMoveType(self, move_type: "tesseract_planning::MoveInstructionType") -> "void":
        return _tesseract_command_language_python.MoveInstruction_setMoveType(self, move_type)

    def getMoveType(self) -> "tesseract_planning::MoveInstructionType":
        return _tesseract_command_language_python.MoveInstruction_getMoveType(self)

    def isLinear(self) -> "bool":
        return _tesseract_command_language_python.MoveInstruction_isLinear(self)

    def isFreespace(self) -> "bool":
        return _tesseract_command_language_python.MoveInstruction_isFreespace(self)

    def isCircular(self) -> "bool":
        return _tesseract_command_language_python.MoveInstruction_isCircular(self)

    def isStart(self) -> "bool":
        return _tesseract_command_language_python.MoveInstruction_isStart(self)

    def __eq__(self, rhs: "MoveInstruction") -> "bool":
        return _tesseract_command_language_python.MoveInstruction___eq__(self, rhs)

    def __ne__(self, rhs: "MoveInstruction") -> "bool":
        return _tesseract_command_language_python.MoveInstruction___ne__(self, rhs)
    __swig_destroy__ = _tesseract_command_language_python.delete_MoveInstruction

# Register MoveInstruction in _tesseract_command_language_python:
_tesseract_command_language_python.MoveInstruction_swigregister(MoveInstruction)

class StateWaypoint(tesseract_robotics.tesseract_common.tesseract_common_python.JointState):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_command_language_python.StateWaypoint_swiginit(self, _tesseract_command_language_python.new_StateWaypoint(*args))

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.StateWaypoint__print(self, *args)

    def __eq__(self, rhs: "StateWaypoint") -> "bool":
        return _tesseract_command_language_python.StateWaypoint___eq__(self, rhs)

    def __ne__(self, rhs: "StateWaypoint") -> "bool":
        return _tesseract_command_language_python.StateWaypoint___ne__(self, rhs)
    __swig_destroy__ = _tesseract_command_language_python.delete_StateWaypoint

# Register StateWaypoint in _tesseract_command_language_python:
_tesseract_command_language_python.StateWaypoint_swigregister(StateWaypoint)


def isCartesianWaypoint(waypoint: "Waypoint") -> "bool":
    return _tesseract_command_language_python.isCartesianWaypoint(waypoint)

def isJointWaypoint(waypoint: "Waypoint") -> "bool":
    return _tesseract_command_language_python.isJointWaypoint(waypoint)

def isStateWaypoint(waypoint: "Waypoint") -> "bool":
    return _tesseract_command_language_python.isStateWaypoint(waypoint)

def isNullWaypoint(waypoint: "Waypoint") -> "bool":
    return _tesseract_command_language_python.isNullWaypoint(waypoint)
TimerInstructionType_DIGITAL_OUTPUT_HIGH = _tesseract_command_language_python.TimerInstructionType_DIGITAL_OUTPUT_HIGH
TimerInstructionType_DIGITAL_OUTPUT_LOW = _tesseract_command_language_python.TimerInstructionType_DIGITAL_OUTPUT_LOW
class TimerInstruction(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This instruction indicates that a timer should be started and when the time expires it either sets a digital
    output high(1) or low(0).

      - DIGITAL_OUTPUT_HIGH : The digital output will be set to high(1) when the timer expires
      - DIGITAL_OUTPUT_LOW  : The digital output will be set to low(0) when the timer expires
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_command_language_python.TimerInstruction_swiginit(self, _tesseract_command_language_python.new_TimerInstruction(*args))

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.TimerInstruction_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.TimerInstruction_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.TimerInstruction__print(self, *args)

    def getTimerType(self) -> "tesseract_planning::TimerInstructionType":
        r"""
        Get the timer type
        :rtype: int
        :return: The timer type
        """
        return _tesseract_command_language_python.TimerInstruction_getTimerType(self)

    def setTimerType(self, type: "tesseract_planning::TimerInstructionType") -> "void":
        r"""
        Set the timer type
        :type type: int
        :param type: The timer type
        """
        return _tesseract_command_language_python.TimerInstruction_setTimerType(self, type)

    def getTimerTime(self) -> "double":
        r"""
        Get timer time in second
        :rtype: float
        :return: The timer time in second
        """
        return _tesseract_command_language_python.TimerInstruction_getTimerTime(self)

    def setTimerTime(self, time: "double") -> "void":
        r"""
        Set timer time in second
        :type time: float
        :param time: The timer time in second
        """
        return _tesseract_command_language_python.TimerInstruction_setTimerTime(self, time)

    def getTimerIO(self) -> "int":
        r"""
        Get the timer IO
        :rtype: int
        :return: The timer IO
        """
        return _tesseract_command_language_python.TimerInstruction_getTimerIO(self)

    def setTimerIO(self, io: "int") -> "void":
        r"""
        Set the timer IO
        :type io: int
        :param io: The timer IO
        """
        return _tesseract_command_language_python.TimerInstruction_setTimerIO(self, io)

    def __eq__(self, rhs: "TimerInstruction") -> "bool":
        r"""
        Equal operator. Does not compare descriptions
        :type rhs: :py:class:`TimerInstruction`
        :param rhs: TimerInstruction
        :rtype: boolean
        :return: True if equal, otherwise false
        """
        return _tesseract_command_language_python.TimerInstruction___eq__(self, rhs)

    def __ne__(self, rhs: "TimerInstruction") -> "bool":
        r"""
        Not equal operator. Does not compare descriptions
        :type rhs: :py:class:`TimerInstruction`
        :param rhs: TimerInstruction
        :rtype: boolean
        :return: True if not equal, otherwise false
        """
        return _tesseract_command_language_python.TimerInstruction___ne__(self, rhs)
    __swig_destroy__ = _tesseract_command_language_python.delete_TimerInstruction

# Register TimerInstruction in _tesseract_command_language_python:
_tesseract_command_language_python.TimerInstruction_swigregister(TimerInstruction)

WaitInstructionType_TIME = _tesseract_command_language_python.WaitInstructionType_TIME
WaitInstructionType_DIGITAL_INPUT_HIGH = _tesseract_command_language_python.WaitInstructionType_DIGITAL_INPUT_HIGH
WaitInstructionType_DIGITAL_INPUT_LOW = _tesseract_command_language_python.WaitInstructionType_DIGITAL_INPUT_LOW
WaitInstructionType_DIGITAL_OUTPUT_HIGH = _tesseract_command_language_python.WaitInstructionType_DIGITAL_OUTPUT_HIGH
WaitInstructionType_DIGITAL_OUTPUT_LOW = _tesseract_command_language_python.WaitInstructionType_DIGITAL_OUTPUT_LOW
class WaitInstruction(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This is a wait instruction similar to wait instruction on industrial controllers.
    The instruction has several modes of operation.

      - TIME                : This will wait for a specified number of seconds and then continue
      - DIGITAL_INPUT_HIGH  : This will wait for a digital input to go high(1) then continue
      - DIGITAL_INPUT_LOW   : This will wait for a digital input to go low(0) then continue
      - DIGITAL_OUTPUT_HIGH : This will wait for a digital output to go high(1) then continue
      - DIGITAL_OUTPUT_LOW  : This will wait for a digital output to go low(0) then continue
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_command_language_python.WaitInstruction_swiginit(self, _tesseract_command_language_python.new_WaitInstruction(*args))

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.WaitInstruction_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.WaitInstruction_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.WaitInstruction__print(self, *args)

    def getWaitType(self) -> "tesseract_planning::WaitInstructionType":
        r"""
        Get the wait type
        :rtype: int
        :return: The wait type
        """
        return _tesseract_command_language_python.WaitInstruction_getWaitType(self)

    def setWaitType(self, type: "tesseract_planning::WaitInstructionType") -> "void":
        r"""
        Set the wait type
        :type type: int
        :param type: The wait type
        """
        return _tesseract_command_language_python.WaitInstruction_setWaitType(self, type)

    def getWaitTime(self) -> "double":
        r"""
        Get wait time in second
        :rtype: float
        :return: The wait time in second
        """
        return _tesseract_command_language_python.WaitInstruction_getWaitTime(self)

    def setWaitTime(self, time: "double") -> "void":
        r"""
        Set wait time in second
        :type time: float
        :param time: The wait time in second
        """
        return _tesseract_command_language_python.WaitInstruction_setWaitTime(self, time)

    def getWaitIO(self) -> "int":
        r"""
        Get the wait IO
        :rtype: int
        :return: The wait IO
        """
        return _tesseract_command_language_python.WaitInstruction_getWaitIO(self)

    def setWaitIO(self, io: "int") -> "void":
        r"""
        Set the wait IO
        :type io: int
        :param io: The wait IO
        """
        return _tesseract_command_language_python.WaitInstruction_setWaitIO(self, io)

    def __eq__(self, rhs: "WaitInstruction") -> "bool":
        r"""
        Equal operator. Does not compare descriptions
        :type rhs: :py:class:`WaitInstruction`
        :param rhs: TimerInstruction
        :rtype: boolean
        :return: True if equal, otherwise false
        """
        return _tesseract_command_language_python.WaitInstruction___eq__(self, rhs)

    def __ne__(self, rhs: "WaitInstruction") -> "bool":
        r"""
        Not equal operator. Does not compare descriptions
        :type rhs: :py:class:`WaitInstruction`
        :param rhs: TimerInstruction
        :rtype: boolean
        :return: True if not equal, otherwise false
        """
        return _tesseract_command_language_python.WaitInstruction___ne__(self, rhs)
    __swig_destroy__ = _tesseract_command_language_python.delete_WaitInstruction

# Register WaitInstruction in _tesseract_command_language_python:
_tesseract_command_language_python.WaitInstruction_swigregister(WaitInstruction)

class SetToolInstruction(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_command_language_python.SetToolInstruction_swiginit(self, _tesseract_command_language_python.new_SetToolInstruction(*args))

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.SetToolInstruction_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.SetToolInstruction_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.SetToolInstruction__print(self, *args)

    def getTool(self) -> "int":
        r"""
        Get the tool ID
        :rtype: int
        :return: The tool ID
        """
        return _tesseract_command_language_python.SetToolInstruction_getTool(self)

    def __eq__(self, rhs: "SetToolInstruction") -> "bool":
        r"""
        Equal operator. Does not compare descriptions
        :type rhs: :py:class:`SetToolInstruction`
        :param rhs: SetToolInstruction
        :rtype: boolean
        :return: True if equal, otherwise false
        """
        return _tesseract_command_language_python.SetToolInstruction___eq__(self, rhs)

    def __ne__(self, rhs: "SetToolInstruction") -> "bool":
        r"""
        Not equal operator. Does not compare descriptions
        :type rhs: :py:class:`SetToolInstruction`
        :param rhs: SetToolInstruction
        :rtype: boolean
        :return: True if not equal, otherwise false
        """
        return _tesseract_command_language_python.SetToolInstruction___ne__(self, rhs)
    __swig_destroy__ = _tesseract_command_language_python.delete_SetToolInstruction

# Register SetToolInstruction in _tesseract_command_language_python:
_tesseract_command_language_python.SetToolInstruction_swigregister(SetToolInstruction)

class SetAnalogInstruction(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_command_language_python.SetAnalogInstruction_swiginit(self, _tesseract_command_language_python.new_SetAnalogInstruction(*args))

    def getDescription(self) -> "std::string const &":
        return _tesseract_command_language_python.SetAnalogInstruction_getDescription(self)

    def setDescription(self, description: "std::string const &") -> "void":
        return _tesseract_command_language_python.SetAnalogInstruction_setDescription(self, description)

    def _print(self, *args) -> "void":
        return _tesseract_command_language_python.SetAnalogInstruction__print(self, *args)

    def getKey(self) -> "std::string":
        r""" Get the analog key"""
        return _tesseract_command_language_python.SetAnalogInstruction_getKey(self)

    def getIndex(self) -> "int":
        r""" Get the analog index"""
        return _tesseract_command_language_python.SetAnalogInstruction_getIndex(self)

    def getValue(self) -> "double":
        r""" Get the analgo value"""
        return _tesseract_command_language_python.SetAnalogInstruction_getValue(self)

    def __eq__(self, rhs: "SetAnalogInstruction") -> "bool":
        r"""
        Equal operator. Does not compare descriptions
        :type rhs: :py:class:`SetAnalogInstruction`
        :param rhs: SetAnalogInstruction
        :rtype: boolean
        :return: True if equal, otherwise false
        """
        return _tesseract_command_language_python.SetAnalogInstruction___eq__(self, rhs)

    def __ne__(self, rhs: "SetAnalogInstruction") -> "bool":
        r"""
        Not equal operator. Does not compare descriptions
        :type rhs: :py:class:`SetAnalogInstruction`
        :param rhs: SetAnalogInstruction
        :rtype: boolean
        :return: True if not equal, otherwise false
        """
        return _tesseract_command_language_python.SetAnalogInstruction___ne__(self, rhs)
    __swig_destroy__ = _tesseract_command_language_python.delete_SetAnalogInstruction

# Register SetAnalogInstruction in _tesseract_command_language_python:
_tesseract_command_language_python.SetAnalogInstruction_swigregister(SetAnalogInstruction)


def moveFilter(instruction: "Instruction", composite: "CompositeInstruction", parent_is_first_composite: "bool") -> "bool":
    return _tesseract_command_language_python.moveFilter(instruction, composite, parent_is_first_composite)

def toJointTrajectory(composite_instructions: "CompositeInstruction") -> "tesseract_common::JointTrajectory":
    r"""
    Convert composite instruction to a joint trajectory
    This searches for both move and plan instruction to support converting both input and results to planning
    requests. If it contains a Cartesian waypoint it is skipped.
    :type composite_instructions: :py:class:`CompositeInstruction`
    :param composite_instructions: The composite instruction to convert
    :rtype: :py:class:`JointTrajectory`
    :return: A joint trajectory
    """
    return _tesseract_command_language_python.toJointTrajectory(composite_instructions)

def getJointNames(waypoint: "Waypoint") -> "std::vector< std::string,std::allocator< std::string > > const &":
    r"""
    Gets joint names from waypoints that contain that information.

    Throws if waypoint does not directly contain that information

    :type waypoint: :py:class:`Waypoint`
    :param waypoint: The waypoint to try and extract the joint position from
    :rtype: std::vector< std::string,std::allocator< std::string > >
    :return: The joint names
    """
    return _tesseract_command_language_python.getJointNames(waypoint)

def getJointPosition(*args) -> "Eigen::VectorXd":
    r"""
    *Overload 1:*

    Gets joint position from waypoints that contain that information.

    Throws if waypoint does not directly contain that information
    :type waypoint: :py:class:`Waypoint`
    :param waypoint: The waypoint to try and extract the joint position from
    :rtype: Eigen::VectorXd
    :return: The joint values

    |

    *Overload 2:*

    Get the joint positions ordered by the provided joint names

    Throws if waypoint does not directly contain that information

    Also this is an expensive call so the motion planners do not leverage this and they expect the order through out
    the program all match.

    :type joint_names: std::vector< std::string,std::allocator< std::string > >
    :param joint_names: The joint names defining the order desired
    :type waypoint: :py:class:`Waypoint`
    :param waypoint: The waypoint to
    :rtype: Eigen::VectorXd
    :return: The joint values ordered by the provided joint_names
    """
    return _tesseract_command_language_python.getJointPosition(*args)

def formatJointPosition(joint_names: "vector_string", waypoint: "Waypoint") -> "bool":
    r"""
    Format the waypoints joint ordered by the provided joint names

    Throws if waypoint does not directly contain that information

    Also this is an expensive call so the motion planners do not leverage this and they expect the order through out
    the program all match.

    :type joint_names: std::vector< std::string,std::allocator< std::string > >
    :param joint_names: The joint names defining the order desired
    :type waypoint: :py:class:`Waypoint`
    :param waypoint: The waypoint to format
    :rtype: boolean
    :return: True if formatting was required, otherwise false.
    """
    return _tesseract_command_language_python.formatJointPosition(joint_names, waypoint)

def checkJointPositionFormat(joint_names: "vector_string", waypoint: "Waypoint") -> "bool":
    r"""
    Check the waypoints joint order against the provided joint names

    Throws if waypoint does not directly contain that information

    Also this is an expensive call so the motion planners do not leverage this and they expect the order through out
    the program all match.

    :type joint_names: std::vector< std::string,std::allocator< std::string > >
    :param joint_names: The joint names defining the order desired
    :type waypoint: :py:class:`Waypoint`
    :param waypoint: The waypoint to check format
    :rtype: boolean
    :return: True if waypoint format is correct, otherwise false.
    """
    return _tesseract_command_language_python.checkJointPositionFormat(joint_names, waypoint)

def setJointPosition(waypoint: "Waypoint", position: "Eigen::Ref< Eigen::VectorXd const > const &") -> "bool":
    r"""
    Set the joint position for waypoints that contain that information
    :type waypoint: :py:class:`Waypoint`
    :param waypoint: Waypoint to set
    :type position: Eigen::Ref< Eigen::VectorXd const >
    :param position: Joint position
    :rtype: boolean
    :return: true if successful (if the waypoint is a supported type)
    """
    return _tesseract_command_language_python.setJointPosition(waypoint, position)

def isWithinJointLimits(wp: "Waypoint", limits: "Eigen::Ref< Eigen::MatrixX2d const > const &") -> "bool":
    r"""
    Checks if a waypoint is
    :type wp: :py:class:`Waypoint`
    :param wp: Waypoint to be checked. Only checks if a JointPosition or State waypoint (otherwise returns true)
    :type limits: Eigen::Ref< Eigen::MatrixX2d const >
    :param limits: Matrix2d of limits with first column being lower limits and second column being upper limits
    :rtype: boolean
    :return: True if the waypoit falls within the joint limits
    """
    return _tesseract_command_language_python.isWithinJointLimits(wp, limits)

def generateSkeletonSeed(composite_instructions: "CompositeInstruction") -> "tesseract_planning::CompositeInstruction":
    r"""
    This creates a seed by looping over and replacing every plan instruction with a composite instruction
    :param instructions:
    :rtype: :py:class:`CompositeInstruction`
    :return: 
    """
    return _tesseract_command_language_python.generateSkeletonSeed(composite_instructions)

def toDelimitedFile(*args) -> "bool":
    r"""
    Convert a CompositeInstruction to delimited formate file by extracting all MoveInstructions
    :type composite_instructions: :py:class:`CompositeInstruction`
    :param composite_instructions: The CompositeInstruction to extract data from
    :type file_path: string
    :param file_path: The location to save the file
    :type separator: char, optional
    :param separator: The separator to use
    :rtype: boolean
    :return: true if successful
    """
    return _tesseract_command_language_python.toDelimitedFile(*args)

def getFirstInstruction(*args) -> "tesseract_planning::Instruction *":
    r"""
    *Overload 1:*

    Get the first Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :type locate_filter: tesseract_planning::locateFilterFn, optional
    :param locate_filter: The filter to indicate if an instruction should be considered
    :type process_child_composites: boolean, optional
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The first Instruction (Const)

    |

    *Overload 2:*

    Get the first Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :type locate_filter: tesseract_planning::locateFilterFn, optional
    :param locate_filter: The filter to indicate if an instruction should be considered
    :type process_child_composites: boolean, optional
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The first Instruction (Non-Const)

    |

    *Overload 3:*

    Get the first Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :type locate_filter: tesseract_planning::locateFilterFn, optional
    :param locate_filter: The filter to indicate if an instruction should be considered
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The first Instruction (Non-Const)

    |

    *Overload 4:*

    Get the first Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :param locate_filter: The filter to indicate if an instruction should be considered
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The first Instruction (Non-Const)
    """
    return _tesseract_command_language_python.getFirstInstruction(*args)

def getLastInstruction(*args) -> "tesseract_planning::Instruction *":
    r"""
    *Overload 1:*

    Get the last Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :type locate_filter: tesseract_planning::locateFilterFn, optional
    :param locate_filter: The filter to indicate if an instruction should be considered
    :type process_child_composites: boolean, optional
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The Last Instruction (Const)

    |

    *Overload 2:*

    Get the last Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :type locate_filter: tesseract_planning::locateFilterFn, optional
    :param locate_filter: The filter to indicate if an instruction should be considered
    :type process_child_composites: boolean, optional
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The Last Instruction (Non-Const)

    |

    *Overload 3:*

    Get the last Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :type locate_filter: tesseract_planning::locateFilterFn, optional
    :param locate_filter: The filter to indicate if an instruction should be considered
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The Last Instruction (Non-Const)

    |

    *Overload 4:*

    Get the last Instruction in a Composite Instruction that is identified by the filter
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :param locate_filter: The filter to indicate if an instruction should be considered
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: :py:class:`Instruction`
    :return: The Last Instruction (Non-Const)
    """
    return _tesseract_command_language_python.getLastInstruction(*args)

def getFirstMoveInstruction(*args) -> "tesseract_planning::MoveInstruction const *":
    r"""
    *Overload 1:*

    Get the first Move Instruction in a Composite Instruction
    This does not consider the start instruction in child composite instruction
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :rtype: :py:class:`MoveInstruction`
    :return: The first Move Instruction (Non-Const)

    |

    *Overload 2:*

    Get the first Move Instruction in a Composite Instruction
    This does not consider the start instruction in child composite instruction
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :rtype: :py:class:`MoveInstruction`
    :return: The first Move Instruction (Const)
    """
    return _tesseract_command_language_python.getFirstMoveInstruction(*args)

def getLastMoveInstruction(*args) -> "tesseract_planning::MoveInstruction const *":
    r"""
    *Overload 1:*

    Get the last Move Instruction in a Composite Instruction
    This does not consider the start instruction in child composite instruction
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :rtype: :py:class:`MoveInstruction`
    :return: The last Move Instruction (Non-Const)

    |

    *Overload 2:*

    Get the last Move Instruction in a Composite Instruction
    This does not consider the start instruction in child composite instruction
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Composite Instruction to search
    :rtype: :py:class:`MoveInstruction`
    :return: The last Move Instruction (Const)
    """
    return _tesseract_command_language_python.getLastMoveInstruction(*args)

def getInstructionCount(composite_instruction: "CompositeInstruction", locate_filter: "tesseract_planning::locateFilterFn const &"=0, process_child_composites: "bool"=True) -> "long":
    r"""
    Get number of Instruction in a Composite Instruction
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: The Composite Instruction to process
    :type locate_filter: tesseract_planning::locateFilterFn, optional
    :param locate_filter: The filter to indicate if an instruction should be considered
    :type process_child_composites: boolean, optional
    :param process_child_composites: Indicate if child Composite Instructions should be searched
    :rtype: int
    :return: The number of Instructions
    """
    return _tesseract_command_language_python.getInstructionCount(composite_instruction, locate_filter, process_child_composites)

def getMoveInstructionCount(composite_instruction: "CompositeInstruction") -> "long":
    r"""
    Get number of Move Instruction in a Composite Instruction
    This does not consider the start instruction in the child composite instruction
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: The Composite Instruction to process
    :rtype: int
    :return: The number of Move Instructions
    """
    return _tesseract_command_language_python.getMoveInstructionCount(composite_instruction)

def flatten(*args) -> "std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >":
    r"""
    *Overload 1:*

    Flattens a CompositeInstruction into a vector of Instruction
    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Input composite instruction to be flattened
    :type filter: tesseract_planning::flattenFilterFn, optional
    :param filter: Used to filter only what should be considered. Should return true to include otherwise false
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction > > >
    :return: A new flattened vector referencing the original instruction elements

    |

    *Overload 2:*

    Flattens a CompositeInstruction into a vector of Instruction
    :param instruction: Input composite instruction to be flattened
    :type filter: tesseract_planning::flattenFilterFn, optional
    :param filter: Used to filter only what should be considered. Should return true to include otherwise false
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >
    :return: A new flattened vector referencing the original instruction elements

    |

    *Overload 3:*

    Flattens a CompositeInstruction into a vector of Instruction
    :param instruction: Input composite instruction to be flattened
    :param filter: Used to filter only what should be considered. Should return true to include otherwise false
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >
    :return: A new flattened vector referencing the original instruction elements
    """
    return _tesseract_command_language_python.flatten(*args)

def flattenToPattern(*args) -> "std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >":
    r"""
    *Overload 1:*

    Flattens a composite instruction to the same pattern as the pattern composite instruction. ie, an element of
    instruction will only be flattened if the corresponding element in pattern is flattenable.
    The motivation for this utility is a case where you flatten only the elements in a seed that correspond to composites
    in the parent instruction
    :param instruction: CompositeInstruction that will be flattened
    :type pattern: :py:class:`CompositeInstruction`
    :param pattern: CompositeInstruction used to determine if instruction will be flattened
    :type filter: tesseract_planning::flattenFilterFn, optional
    :param filter: Used to filter only what should be considered. Should return true to include otherwise false
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction > > >
    :return: A new flattened vector referencing the original instruction elements

    |

    *Overload 2:*

    Flattens a composite instruction to the same pattern as the pattern composite instruction. ie, an element of
    instruction will only be flattened if the corresponding element in pattern is flattenable.
    :param instruction: CompositeInstruction that will be flattened
    :type pattern: :py:class:`CompositeInstruction`
    :param pattern: CompositeInstruction used to determine if instruction will be flattened
    :type filter: tesseract_planning::flattenFilterFn, optional
    :param filter: Used to filter only what should be considered. Should return true to include otherwise false
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >
    :return: A new flattened vector referencing the original instruction elements

    |

    *Overload 3:*

    Flattens a composite instruction to the same pattern as the pattern composite instruction. ie, an element of
    instruction will only be flattened if the corresponding element in pattern is flattenable.
    :param instruction: CompositeInstruction that will be flattened
    :type pattern: :py:class:`CompositeInstruction`
    :param pattern: CompositeInstruction used to determine if instruction will be flattened
    :param filter: Used to filter only what should be considered. Should return true to include otherwise false
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >
    :return: A new flattened vector referencing the original instruction elements
    """
    return _tesseract_command_language_python.flattenToPattern(*args)

def clampToJointLimits(*args) -> "bool":
    return _tesseract_command_language_python.clampToJointLimits(*args)


