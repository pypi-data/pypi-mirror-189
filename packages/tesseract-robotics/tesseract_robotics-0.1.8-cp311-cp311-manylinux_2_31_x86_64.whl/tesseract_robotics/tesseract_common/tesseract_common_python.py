# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_common_python
else:
    import _tesseract_common_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_common_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_common_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_common_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_common_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_common_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_common_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_common_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_common_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_common_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_common_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_common_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_common_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_common_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_common_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_common_python:
_tesseract_common_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_common_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_common_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_common_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_common_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_common_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_common_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_common_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_common_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_common_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_common_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_common_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_common_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_common_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_common_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.vector_eigen_index_swiginit(self, _tesseract_common_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_common_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_common_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_common_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_common_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_common_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_common_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_common_python:
_tesseract_common_python.vector_eigen_index_swigregister(vector_eigen_index)

TINYXML2_MAJOR_VERSION = _tesseract_common_python.TINYXML2_MAJOR_VERSION
TINYXML2_MINOR_VERSION = _tesseract_common_python.TINYXML2_MINOR_VERSION
TINYXML2_PATCH_VERSION = _tesseract_common_python.TINYXML2_PATCH_VERSION
class XMLVisitor(object, metaclass=_SwigNonDynamicMeta):
    r"""
    Implements the interface to the "Visitor pattern" (see the Accept() method.)
    If you call the Accept() method, it requires being passed a XMLVisitor
    class to handle callbacks. For nodes that contain other nodes (Document, Element)
    you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
    are simply called with Visit().

    If you return 'true' from a Visit method, recursive parsing will continue. If you return
    false, **no children of this node or its siblings** will be visited.

    All flavors of Visit methods have a default implementation that returns 'true' (continue
    visiting). You need to only override methods that are interesting to you.

    Generally Accept() is called on the XMLDocument, although all nodes support visiting.

    You should never change the document from a callback.

    See also: XMLNode::Accept()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_XMLVisitor

    def VisitEnter(self, *args) -> "bool":
        r"""
        *Overload 1:*
        Visit a document.

        |

        *Overload 2:*
        Visit an element.
        """
        return _tesseract_common_python.XMLVisitor_VisitEnter(self, *args)

    def VisitExit(self, *args) -> "bool":
        r"""
        *Overload 1:*
        Visit a document.

        |

        *Overload 2:*
        Visit an element.
        """
        return _tesseract_common_python.XMLVisitor_VisitExit(self, *args)

    def Visit(self, *args) -> "bool":
        r"""
        *Overload 1:*
        Visit a declaration.

        |

        *Overload 2:*
        Visit a text node.

        |

        *Overload 3:*
        Visit a comment node.

        |

        *Overload 4:*
        Visit an unknown node.
        """
        return _tesseract_common_python.XMLVisitor_Visit(self, *args)

    def __init__(self):
        _tesseract_common_python.XMLVisitor_swiginit(self, _tesseract_common_python.new_XMLVisitor())

# Register XMLVisitor in _tesseract_common_python:
_tesseract_common_python.XMLVisitor_swigregister(XMLVisitor)
cvar = _tesseract_common_python.cvar
TIXML2_MAJOR_VERSION = cvar.TIXML2_MAJOR_VERSION
TIXML2_MINOR_VERSION = cvar.TIXML2_MINOR_VERSION
TIXML2_PATCH_VERSION = cvar.TIXML2_PATCH_VERSION
TINYXML2_MAX_ELEMENT_DEPTH = cvar.TINYXML2_MAX_ELEMENT_DEPTH

XML_SUCCESS = _tesseract_common_python.XML_SUCCESS
XML_NO_ATTRIBUTE = _tesseract_common_python.XML_NO_ATTRIBUTE
XML_WRONG_ATTRIBUTE_TYPE = _tesseract_common_python.XML_WRONG_ATTRIBUTE_TYPE
XML_ERROR_FILE_NOT_FOUND = _tesseract_common_python.XML_ERROR_FILE_NOT_FOUND
XML_ERROR_FILE_COULD_NOT_BE_OPENED = _tesseract_common_python.XML_ERROR_FILE_COULD_NOT_BE_OPENED
XML_ERROR_FILE_READ_ERROR = _tesseract_common_python.XML_ERROR_FILE_READ_ERROR
UNUSED_XML_ERROR_ELEMENT_MISMATCH = _tesseract_common_python.UNUSED_XML_ERROR_ELEMENT_MISMATCH
XML_ERROR_PARSING_ELEMENT = _tesseract_common_python.XML_ERROR_PARSING_ELEMENT
XML_ERROR_PARSING_ATTRIBUTE = _tesseract_common_python.XML_ERROR_PARSING_ATTRIBUTE
UNUSED_XML_ERROR_IDENTIFYING_TAG = _tesseract_common_python.UNUSED_XML_ERROR_IDENTIFYING_TAG
XML_ERROR_PARSING_TEXT = _tesseract_common_python.XML_ERROR_PARSING_TEXT
XML_ERROR_PARSING_CDATA = _tesseract_common_python.XML_ERROR_PARSING_CDATA
XML_ERROR_PARSING_COMMENT = _tesseract_common_python.XML_ERROR_PARSING_COMMENT
XML_ERROR_PARSING_DECLARATION = _tesseract_common_python.XML_ERROR_PARSING_DECLARATION
XML_ERROR_PARSING_UNKNOWN = _tesseract_common_python.XML_ERROR_PARSING_UNKNOWN
XML_ERROR_EMPTY_DOCUMENT = _tesseract_common_python.XML_ERROR_EMPTY_DOCUMENT
XML_ERROR_MISMATCHED_ELEMENT = _tesseract_common_python.XML_ERROR_MISMATCHED_ELEMENT
XML_ERROR_PARSING = _tesseract_common_python.XML_ERROR_PARSING
XML_CAN_NOT_CONVERT_TEXT = _tesseract_common_python.XML_CAN_NOT_CONVERT_TEXT
XML_NO_TEXT_NODE = _tesseract_common_python.XML_NO_TEXT_NODE
XML_ELEMENT_DEPTH_EXCEEDED = _tesseract_common_python.XML_ELEMENT_DEPTH_EXCEEDED
XML_ERROR_COUNT = _tesseract_common_python.XML_ERROR_COUNT
class XMLUtil(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    @staticmethod
    def SkipWhiteSpace(*args) -> "char *":
        return _tesseract_common_python.XMLUtil_SkipWhiteSpace(*args)

    @staticmethod
    def IsWhiteSpace(p: "char") -> "bool":
        return _tesseract_common_python.XMLUtil_IsWhiteSpace(p)

    @staticmethod
    def IsNameStartChar(ch: "unsigned char") -> "bool":
        return _tesseract_common_python.XMLUtil_IsNameStartChar(ch)

    @staticmethod
    def IsNameChar(ch: "unsigned char") -> "bool":
        return _tesseract_common_python.XMLUtil_IsNameChar(ch)

    @staticmethod
    def StringEqual(*args) -> "bool":
        return _tesseract_common_python.XMLUtil_StringEqual(*args)

    @staticmethod
    def IsUTF8Continuation(p: "char") -> "bool":
        return _tesseract_common_python.XMLUtil_IsUTF8Continuation(p)

    @staticmethod
    def ReadBOM(p: "char const *", hasBOM: "bool *") -> "char const *":
        return _tesseract_common_python.XMLUtil_ReadBOM(p, hasBOM)

    @staticmethod
    def GetCharacterRef(p: "char const *", value: "char *", length: "int *") -> "char const *":
        return _tesseract_common_python.XMLUtil_GetCharacterRef(p, value, length)

    @staticmethod
    def ConvertUTF32ToUTF8(input: "unsigned long", output: "char *", length: "int *") -> "void":
        return _tesseract_common_python.XMLUtil_ConvertUTF32ToUTF8(input, output, length)

    @staticmethod
    def ToStr(*args) -> "void":
        return _tesseract_common_python.XMLUtil_ToStr(*args)

    @staticmethod
    def ToInt(str: "char const *", value: "int *") -> "bool":
        return _tesseract_common_python.XMLUtil_ToInt(str, value)

    @staticmethod
    def ToUnsigned(str: "char const *", value: "unsigned int *") -> "bool":
        return _tesseract_common_python.XMLUtil_ToUnsigned(str, value)

    @staticmethod
    def ToBool(str: "char const *", value: "bool *") -> "bool":
        return _tesseract_common_python.XMLUtil_ToBool(str, value)

    @staticmethod
    def ToFloat(str: "char const *", value: "float *") -> "bool":
        return _tesseract_common_python.XMLUtil_ToFloat(str, value)

    @staticmethod
    def ToDouble(str: "char const *", value: "double *") -> "bool":
        return _tesseract_common_python.XMLUtil_ToDouble(str, value)

    @staticmethod
    def ToInt64(str: "char const *", value: "int64_t *") -> "bool":
        return _tesseract_common_python.XMLUtil_ToInt64(str, value)

    @staticmethod
    def SetBoolSerialization(writeTrue: "char const *", writeFalse: "char const *") -> "void":
        return _tesseract_common_python.XMLUtil_SetBoolSerialization(writeTrue, writeFalse)

    def __init__(self):
        _tesseract_common_python.XMLUtil_swiginit(self, _tesseract_common_python.new_XMLUtil())
    __swig_destroy__ = _tesseract_common_python.delete_XMLUtil

# Register XMLUtil in _tesseract_common_python:
_tesseract_common_python.XMLUtil_swigregister(XMLUtil)

def XMLUtil_SkipWhiteSpace(*args) -> "char *":
    return _tesseract_common_python.XMLUtil_SkipWhiteSpace(*args)

def XMLUtil_IsWhiteSpace(p: "char") -> "bool":
    return _tesseract_common_python.XMLUtil_IsWhiteSpace(p)

def XMLUtil_IsNameStartChar(ch: "unsigned char") -> "bool":
    return _tesseract_common_python.XMLUtil_IsNameStartChar(ch)

def XMLUtil_IsNameChar(ch: "unsigned char") -> "bool":
    return _tesseract_common_python.XMLUtil_IsNameChar(ch)

def XMLUtil_StringEqual(*args) -> "bool":
    return _tesseract_common_python.XMLUtil_StringEqual(*args)

def XMLUtil_IsUTF8Continuation(p: "char") -> "bool":
    return _tesseract_common_python.XMLUtil_IsUTF8Continuation(p)

def XMLUtil_ReadBOM(p: "char const *", hasBOM: "bool *") -> "char const *":
    return _tesseract_common_python.XMLUtil_ReadBOM(p, hasBOM)

def XMLUtil_GetCharacterRef(p: "char const *", value: "char *", length: "int *") -> "char const *":
    return _tesseract_common_python.XMLUtil_GetCharacterRef(p, value, length)

def XMLUtil_ConvertUTF32ToUTF8(input: "unsigned long", output: "char *", length: "int *") -> "void":
    return _tesseract_common_python.XMLUtil_ConvertUTF32ToUTF8(input, output, length)

def XMLUtil_ToStr(*args) -> "void":
    return _tesseract_common_python.XMLUtil_ToStr(*args)

def XMLUtil_ToInt(str: "char const *", value: "int *") -> "bool":
    return _tesseract_common_python.XMLUtil_ToInt(str, value)

def XMLUtil_ToUnsigned(str: "char const *", value: "unsigned int *") -> "bool":
    return _tesseract_common_python.XMLUtil_ToUnsigned(str, value)

def XMLUtil_ToBool(str: "char const *", value: "bool *") -> "bool":
    return _tesseract_common_python.XMLUtil_ToBool(str, value)

def XMLUtil_ToFloat(str: "char const *", value: "float *") -> "bool":
    return _tesseract_common_python.XMLUtil_ToFloat(str, value)

def XMLUtil_ToDouble(str: "char const *", value: "double *") -> "bool":
    return _tesseract_common_python.XMLUtil_ToDouble(str, value)

def XMLUtil_ToInt64(str: "char const *", value: "int64_t *") -> "bool":
    return _tesseract_common_python.XMLUtil_ToInt64(str, value)

def XMLUtil_SetBoolSerialization(writeTrue: "char const *", writeFalse: "char const *") -> "void":
    return _tesseract_common_python.XMLUtil_SetBoolSerialization(writeTrue, writeFalse)

class XMLNode(object, metaclass=_SwigNonDynamicMeta):
    r"""
    XMLNode is a base class for every object that is in the
    XML Document Object Model (DOM), except XMLAttributes.
    Nodes have siblings, a parent, and children which can
    be navigated. A node is always in a XMLDocument.
    The type of a XMLNode can be queried, and it can
    be cast to its more defined type.

    A XMLDocument allocates memory for all its Nodes.
    When the XMLDocument gets deleted, all its Nodes
    will also be deleted.

    	A Document can contain:	Element	(container or leaf)
    						Comment (leaf)
    						Unknown (leaf)
    						Declaration( leaf )

    An Element can contain:	Element (container or leaf)
    						Text	(leaf)
    						Attributes (not on tree)
    						Comment (leaf)
    						Unknown (leaf)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetDocument(self, *args) -> "tinyxml2::XMLDocument *":
        r"""
        *Overload 1:*
        Get the XMLDocument that owns this XMLNode.

        |

        *Overload 2:*
        Get the XMLDocument that owns this XMLNode.
        """
        return _tesseract_common_python.XMLNode_GetDocument(self, *args)

    def ToElement(self, *args) -> "tinyxml2::XMLElement const *":
        return _tesseract_common_python.XMLNode_ToElement(self, *args)

    def ToText(self, *args) -> "tinyxml2::XMLText const *":
        return _tesseract_common_python.XMLNode_ToText(self, *args)

    def ToComment(self, *args) -> "tinyxml2::XMLComment const *":
        return _tesseract_common_python.XMLNode_ToComment(self, *args)

    def ToDocument(self, *args) -> "tinyxml2::XMLDocument const *":
        return _tesseract_common_python.XMLNode_ToDocument(self, *args)

    def ToDeclaration(self, *args) -> "tinyxml2::XMLDeclaration const *":
        return _tesseract_common_python.XMLNode_ToDeclaration(self, *args)

    def ToUnknown(self, *args) -> "tinyxml2::XMLUnknown const *":
        return _tesseract_common_python.XMLNode_ToUnknown(self, *args)

    def Value(self) -> "char const *":
        r"""
        The meaning of 'value' changes for the specific type.
           	    	Document:	empty (NULL is returned, not an empty string)
           	Element:	name of the element
           	Comment:	the comment text
           	Unknown:	the tag contents
           	Text:		the text string

        """
        return _tesseract_common_python.XMLNode_Value(self)

    def SetValue(self, val: "char const *", staticMem: "bool"=False) -> "void":
        r"""
        Set the Value of an XML node.
           	See also: Value()
        """
        return _tesseract_common_python.XMLNode_SetValue(self, val, staticMem)

    def GetLineNum(self) -> "int":
        r""" Gets the line number the node is in, if the document was parsed from a file."""
        return _tesseract_common_python.XMLNode_GetLineNum(self)

    def Parent(self, *args) -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLNode_Parent(self, *args)

    def NoChildren(self) -> "bool":
        r""" Returns true if this node has no children."""
        return _tesseract_common_python.XMLNode_NoChildren(self)

    def FirstChild(self, *args) -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLNode_FirstChild(self, *args)

    def FirstChildElement(self, *args) -> "tinyxml2::XMLElement *":
        return _tesseract_common_python.XMLNode_FirstChildElement(self, *args)

    def LastChild(self, *args) -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLNode_LastChild(self, *args)

    def LastChildElement(self, *args) -> "tinyxml2::XMLElement *":
        return _tesseract_common_python.XMLNode_LastChildElement(self, *args)

    def PreviousSibling(self, *args) -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLNode_PreviousSibling(self, *args)

    def PreviousSiblingElement(self, *args) -> "tinyxml2::XMLElement *":
        return _tesseract_common_python.XMLNode_PreviousSiblingElement(self, *args)

    def NextSibling(self, *args) -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLNode_NextSibling(self, *args)

    def NextSiblingElement(self, *args) -> "tinyxml2::XMLElement *":
        return _tesseract_common_python.XMLNode_NextSiblingElement(self, *args)

    def InsertEndChild(self, addThis: "XMLNode") -> "tinyxml2::XMLNode *":
        r"""
          	Add a child node as the last (right) child.
        If the child node is already part of the document,
        it is moved from its old location to the new location.
        Returns the addThis argument or 0 if the node does not
        belong to the same document.
        """
        return _tesseract_common_python.XMLNode_InsertEndChild(self, addThis)

    def LinkEndChild(self, addThis: "XMLNode") -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLNode_LinkEndChild(self, addThis)

    def InsertFirstChild(self, addThis: "XMLNode") -> "tinyxml2::XMLNode *":
        r"""
          	Add a child node as the first (left) child.
        If the child node is already part of the document,
        it is moved from its old location to the new location.
        Returns the addThis argument or 0 if the node does not
        belong to the same document.
        """
        return _tesseract_common_python.XMLNode_InsertFirstChild(self, addThis)

    def InsertAfterChild(self, afterThis: "XMLNode", addThis: "XMLNode") -> "tinyxml2::XMLNode *":
        r"""
          	Add a node after the specified child node.
        If the child node is already part of the document,
        it is moved from its old location to the new location.
        Returns the addThis argument or 0 if the afterThis node
        is not a child of this node, or if the node does not
        belong to the same document.
        """
        return _tesseract_common_python.XMLNode_InsertAfterChild(self, afterThis, addThis)

    def DeleteChildren(self) -> "void":
        r"""    	Delete all the children of this node."""
        return _tesseract_common_python.XMLNode_DeleteChildren(self)

    def DeleteChild(self, node: "XMLNode") -> "void":
        r"""    	Delete a child of this node."""
        return _tesseract_common_python.XMLNode_DeleteChild(self, node)

    def ShallowClone(self, document: "XMLDocument") -> "tinyxml2::XMLNode *":
        r"""
        Make a copy of this node, but not its children.
        You may pass in a Document pointer that will be
        the owner of the new Node. If the 'document' is
        null, then the node returned will be allocated
        from the current Document. (this->GetDocument())

        Note: if called on a XMLDocument, this will return null.
        """
        return _tesseract_common_python.XMLNode_ShallowClone(self, document)

    def DeepClone(self, target: "XMLDocument") -> "tinyxml2::XMLNode *":
        r"""
        Make a copy of this node and all its children.

        If the 'target' is null, then the nodes will
        be allocated in the current document. If 'target'
              is specified, the memory will be allocated is the
              specified XMLDocument.

        NOTE: This is probably not the correct tool to
        copy a document, since XMLDocuments can have multiple
        top level XMLNodes. You probably want to use
              XMLDocument::DeepCopy()
        """
        return _tesseract_common_python.XMLNode_DeepClone(self, target)

    def ShallowEqual(self, compare: "XMLNode") -> "bool":
        r"""
        Test if 2 nodes are the same, but don't test children.
        The 2 nodes do not need to be in the same Document.

        Note: if called on a XMLDocument, this will return false.
        """
        return _tesseract_common_python.XMLNode_ShallowEqual(self, compare)

    def Accept(self, visitor: "XMLVisitor") -> "bool":
        r"""
        Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the
           	XML tree will be conditionally visited and the host will be called back
           	via the XMLVisitor interface.

           	This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse
           	the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this
           	interface versus any other.)

           	The interface has been based on ideas from:

           	- http://www.saxproject.org/
           	- http://c2.com/cgi/wiki?HierarchicalVisitorPattern

           	Which are both good references for "visiting".

           	An example of using Accept():
           	    	XMLPrinter printer;
           	tinyxmlDoc.Accept( &printer );
           	const char* xmlcstr = printer.CStr();

        """
        return _tesseract_common_python.XMLNode_Accept(self, visitor)

    def SetUserData(self, userData: "void *") -> "void":
        r"""
        Set user data into the XMLNode. TinyXML-2 in
        no way processes or interprets user data.
        It is initially 0.
        """
        return _tesseract_common_python.XMLNode_SetUserData(self, userData)

    def GetUserData(self) -> "void *":
        r"""
        Get user data set into the XMLNode. TinyXML-2 in
        no way processes or interprets user data.
        It is initially 0.
        """
        return _tesseract_common_python.XMLNode_GetUserData(self)

# Register XMLNode in _tesseract_common_python:
_tesseract_common_python.XMLNode_swigregister(XMLNode)

class XMLText(XMLNode):
    r"""
    XML text.

    Note that a text node can have child element nodes, for example:
    	<root>This is <b>bold</b></root>


    A text node can have 2 ways to output the next. "normal" output
    and CDATA. It will default to the mode it was parsed from the XML file and
    you generally want to leave it alone, but you can change the output mode with
    SetCData() and query it with CData().
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Accept(self, visitor: "XMLVisitor") -> "bool":
        return _tesseract_common_python.XMLText_Accept(self, visitor)

    def ToText(self, *args) -> "tinyxml2::XMLText const *":
        return _tesseract_common_python.XMLText_ToText(self, *args)

    def SetCData(self, isCData: "bool") -> "void":
        r""" Declare whether this should be CDATA or standard text."""
        return _tesseract_common_python.XMLText_SetCData(self, isCData)

    def CData(self) -> "bool":
        r""" Returns true if this is a CDATA text element."""
        return _tesseract_common_python.XMLText_CData(self)

    def ShallowClone(self, document: "XMLDocument") -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLText_ShallowClone(self, document)

    def ShallowEqual(self, compare: "XMLNode") -> "bool":
        return _tesseract_common_python.XMLText_ShallowEqual(self, compare)

# Register XMLText in _tesseract_common_python:
_tesseract_common_python.XMLText_swigregister(XMLText)

class XMLComment(XMLNode):
    r""" An XML Comment."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ToComment(self, *args) -> "tinyxml2::XMLComment const *":
        return _tesseract_common_python.XMLComment_ToComment(self, *args)

    def Accept(self, visitor: "XMLVisitor") -> "bool":
        return _tesseract_common_python.XMLComment_Accept(self, visitor)

    def ShallowClone(self, document: "XMLDocument") -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLComment_ShallowClone(self, document)

    def ShallowEqual(self, compare: "XMLNode") -> "bool":
        return _tesseract_common_python.XMLComment_ShallowEqual(self, compare)

# Register XMLComment in _tesseract_common_python:
_tesseract_common_python.XMLComment_swigregister(XMLComment)

class XMLDeclaration(XMLNode):
    r"""
    In correct XML the declaration is the first entry in the file.
    		<?xml version="1.0" standalone="yes"?>


    TinyXML-2 will happily read or write files without a declaration,
    however.

    The text of the declaration isn't interpreted. It is parsed
    and written as a string.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ToDeclaration(self, *args) -> "tinyxml2::XMLDeclaration const *":
        return _tesseract_common_python.XMLDeclaration_ToDeclaration(self, *args)

    def Accept(self, visitor: "XMLVisitor") -> "bool":
        return _tesseract_common_python.XMLDeclaration_Accept(self, visitor)

    def ShallowClone(self, document: "XMLDocument") -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLDeclaration_ShallowClone(self, document)

    def ShallowEqual(self, compare: "XMLNode") -> "bool":
        return _tesseract_common_python.XMLDeclaration_ShallowEqual(self, compare)

# Register XMLDeclaration in _tesseract_common_python:
_tesseract_common_python.XMLDeclaration_swigregister(XMLDeclaration)

class XMLUnknown(XMLNode):
    r"""
    Any tag that TinyXML-2 doesn't recognize is saved as an
    unknown. It is a tag of text, but should not be modified.
    It will be written back to the XML, unchanged, when the file
    is saved.

    DTD tags get thrown into XMLUnknowns.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ToUnknown(self, *args) -> "tinyxml2::XMLUnknown const *":
        return _tesseract_common_python.XMLUnknown_ToUnknown(self, *args)

    def Accept(self, visitor: "XMLVisitor") -> "bool":
        return _tesseract_common_python.XMLUnknown_Accept(self, visitor)

    def ShallowClone(self, document: "XMLDocument") -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLUnknown_ShallowClone(self, document)

    def ShallowEqual(self, compare: "XMLNode") -> "bool":
        return _tesseract_common_python.XMLUnknown_ShallowEqual(self, compare)

# Register XMLUnknown in _tesseract_common_python:
_tesseract_common_python.XMLUnknown_swigregister(XMLUnknown)

class XMLAttribute(object, metaclass=_SwigNonDynamicMeta):
    r"""
    An attribute is a name-value pair. Elements have an arbitrary
    number of attributes, each with a unique name.

    Notes: The attributes are not XMLNodes. You may only query the
    Next() attribute in a list.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Name(self) -> "char const *":
        r""" The name of the attribute."""
        return _tesseract_common_python.XMLAttribute_Name(self)

    def Value(self) -> "char const *":
        r""" The value of the attribute."""
        return _tesseract_common_python.XMLAttribute_Value(self)

    def GetLineNum(self) -> "int":
        r""" Gets the line number the attribute is in, if the document was parsed from a file."""
        return _tesseract_common_python.XMLAttribute_GetLineNum(self)

    def Next(self) -> "tinyxml2::XMLAttribute const *":
        r""" The next attribute in the list."""
        return _tesseract_common_python.XMLAttribute_Next(self)

    def IntValue(self) -> "int":
        r"""
        IntValue interprets the attribute as an integer, and returns the value.
               If the value isn't an integer, 0 will be returned. There is no error checking;
           	use QueryIntValue() if you need error checking.
        """
        return _tesseract_common_python.XMLAttribute_IntValue(self)

    def Int64Value(self) -> "int64_t":
        return _tesseract_common_python.XMLAttribute_Int64Value(self)

    def UnsignedValue(self) -> "unsigned int":
        r""" Query as an unsigned integer. See IntValue()"""
        return _tesseract_common_python.XMLAttribute_UnsignedValue(self)

    def BoolValue(self) -> "bool":
        r""" Query as a boolean. See IntValue()"""
        return _tesseract_common_python.XMLAttribute_BoolValue(self)

    def DoubleValue(self) -> "double":
        r""" Query as a double. See IntValue()"""
        return _tesseract_common_python.XMLAttribute_DoubleValue(self)

    def FloatValue(self) -> "float":
        r""" Query as a float. See IntValue()"""
        return _tesseract_common_python.XMLAttribute_FloatValue(self)

    def QueryIntValue(self, value: "int *") -> "tinyxml2::XMLError":
        r"""
        QueryIntValue interprets the attribute as an integer, and returns the value
           	in the provided parameter. The function will return XML_SUCCESS on success,
           	and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.
        """
        return _tesseract_common_python.XMLAttribute_QueryIntValue(self, value)

    def QueryUnsignedValue(self, value: "unsigned int *") -> "tinyxml2::XMLError":
        r""" See QueryIntValue"""
        return _tesseract_common_python.XMLAttribute_QueryUnsignedValue(self, value)

    def QueryInt64Value(self, value: "int64_t *") -> "tinyxml2::XMLError":
        r""" See QueryIntValue"""
        return _tesseract_common_python.XMLAttribute_QueryInt64Value(self, value)

    def QueryBoolValue(self, value: "bool *") -> "tinyxml2::XMLError":
        r""" See QueryIntValue"""
        return _tesseract_common_python.XMLAttribute_QueryBoolValue(self, value)

    def QueryDoubleValue(self, value: "double *") -> "tinyxml2::XMLError":
        r""" See QueryIntValue"""
        return _tesseract_common_python.XMLAttribute_QueryDoubleValue(self, value)

    def QueryFloatValue(self, value: "float *") -> "tinyxml2::XMLError":
        r""" See QueryIntValue"""
        return _tesseract_common_python.XMLAttribute_QueryFloatValue(self, value)

    def SetAttribute(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set the attribute to a string value.

        |

        *Overload 2:*
        Set the attribute to value.

        |

        *Overload 3:*
        Set the attribute to value.

        |

        *Overload 4:*
        Set the attribute to value.

        |

        *Overload 5:*
        Set the attribute to value.

        |

        *Overload 6:*
        Set the attribute to value.

        |

        *Overload 7:*
        Set the attribute to value.
        """
        return _tesseract_common_python.XMLAttribute_SetAttribute(self, *args)

# Register XMLAttribute in _tesseract_common_python:
_tesseract_common_python.XMLAttribute_swigregister(XMLAttribute)

class XMLElement(XMLNode):
    r"""
    The element is a container class. It has a value, the element name,
    and can contain other elements, text, comments, and unknowns.
    Elements also contain an arbitrary number of attributes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Name(self) -> "char const *":
        r""" Get the name of an element (which is the Value() of the node.)"""
        return _tesseract_common_python.XMLElement_Name(self)

    def SetName(self, str: "char const *", staticMem: "bool"=False) -> "void":
        r""" Set the name of the element."""
        return _tesseract_common_python.XMLElement_SetName(self, str, staticMem)

    def ToElement(self, *args) -> "tinyxml2::XMLElement const *":
        return _tesseract_common_python.XMLElement_ToElement(self, *args)

    def Accept(self, visitor: "XMLVisitor") -> "bool":
        return _tesseract_common_python.XMLElement_Accept(self, visitor)

    def Attribute(self, name: "char const *", value: "char const *"=None) -> "char const *":
        r"""
        Given an attribute name, Attribute() returns the value
           	for the attribute of that name, or null if none
           	exists. For example:

           	    	const char* value = ele->Attribute( "foo" );


           	The 'value' parameter is normally null. However, if specified,
           	the attribute will only be returned if the 'name' and 'value'
           	match. This allow you to write code:

           	    	if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();


           	rather than:
           	    	if ( ele->Attribute( "foo" ) ) {
           		if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
           	}

        """
        return _tesseract_common_python.XMLElement_Attribute(self, name, value)

    def IntAttribute(self, name: "char const *", defaultValue: "int"=0) -> "int":
        r"""
        Given an attribute name, IntAttribute() returns the value
           	of the attribute interpreted as an integer. The default
               value will be returned if the attribute isn't present,
               or if there is an error. (For a method with error
           	checking, see QueryIntAttribute()).
        """
        return _tesseract_common_python.XMLElement_IntAttribute(self, name, defaultValue)

    def UnsignedAttribute(self, name: "char const *", defaultValue: "unsigned int"=0) -> "unsigned int":
        r""" See IntAttribute()"""
        return _tesseract_common_python.XMLElement_UnsignedAttribute(self, name, defaultValue)

    def Int64Attribute(self, name: "char const *", defaultValue: "int64_t"=0) -> "int64_t":
        r""" See IntAttribute()"""
        return _tesseract_common_python.XMLElement_Int64Attribute(self, name, defaultValue)

    def BoolAttribute(self, name: "char const *", defaultValue: "bool"=False) -> "bool":
        r""" See IntAttribute()"""
        return _tesseract_common_python.XMLElement_BoolAttribute(self, name, defaultValue)

    def DoubleAttribute(self, name: "char const *", defaultValue: "double"=0) -> "double":
        r""" See IntAttribute()"""
        return _tesseract_common_python.XMLElement_DoubleAttribute(self, name, defaultValue)

    def FloatAttribute(self, name: "char const *", defaultValue: "float"=0) -> "float":
        r""" See IntAttribute()"""
        return _tesseract_common_python.XMLElement_FloatAttribute(self, name, defaultValue)

    def QueryIntAttribute(self, name: "char const *", value: "int *") -> "tinyxml2::XMLError":
        r"""
        Given an attribute name, QueryIntAttribute() returns
           	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
           	can't be performed, or XML_NO_ATTRIBUTE if the attribute
           	doesn't exist. If successful, the result of the conversion
           	will be written to 'value'. If not successful, nothing will
           	be written to 'value'. This allows you to provide default
           	value:

           	    	int value = 10;
           	QueryIntAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10

        """
        return _tesseract_common_python.XMLElement_QueryIntAttribute(self, name, value)

    def QueryUnsignedAttribute(self, name: "char const *", value: "unsigned int *") -> "tinyxml2::XMLError":
        r""" See QueryIntAttribute()"""
        return _tesseract_common_python.XMLElement_QueryUnsignedAttribute(self, name, value)

    def QueryInt64Attribute(self, name: "char const *", value: "int64_t *") -> "tinyxml2::XMLError":
        r""" See QueryIntAttribute()"""
        return _tesseract_common_python.XMLElement_QueryInt64Attribute(self, name, value)

    def QueryBoolAttribute(self, name: "char const *", value: "bool *") -> "tinyxml2::XMLError":
        r""" See QueryIntAttribute()"""
        return _tesseract_common_python.XMLElement_QueryBoolAttribute(self, name, value)

    def QueryDoubleAttribute(self, name: "char const *", value: "double *") -> "tinyxml2::XMLError":
        r""" See QueryIntAttribute()"""
        return _tesseract_common_python.XMLElement_QueryDoubleAttribute(self, name, value)

    def QueryFloatAttribute(self, name: "char const *", value: "float *") -> "tinyxml2::XMLError":
        r""" See QueryIntAttribute()"""
        return _tesseract_common_python.XMLElement_QueryFloatAttribute(self, name, value)

    def QueryStringAttribute(self, name: "char const *", value: "char const **") -> "tinyxml2::XMLError":
        r""" See QueryIntAttribute()"""
        return _tesseract_common_python.XMLElement_QueryStringAttribute(self, name, value)

    def QueryAttribute(self, *args) -> "int":
        return _tesseract_common_python.XMLElement_QueryAttribute(self, *args)

    def SetAttribute(self, *args) -> "void":
        r"""
        *Overload 1:*
        Sets the named attribute to value.

        |

        *Overload 2:*
        Sets the named attribute to value.

        |

        *Overload 3:*
        Sets the named attribute to value.

        |

        *Overload 4:*
        Sets the named attribute to value.

        |

        *Overload 5:*
        Sets the named attribute to value.

        |

        *Overload 6:*
        Sets the named attribute to value.

        |

        *Overload 7:*
        Sets the named attribute to value.
        """
        return _tesseract_common_python.XMLElement_SetAttribute(self, *args)

    def DeleteAttribute(self, name: "char const *") -> "void":
        r"""    	Delete an attribute."""
        return _tesseract_common_python.XMLElement_DeleteAttribute(self, name)

    def FirstAttribute(self) -> "tinyxml2::XMLAttribute const *":
        r""" Return the first attribute in the list."""
        return _tesseract_common_python.XMLElement_FirstAttribute(self)

    def FindAttribute(self, name: "char const *") -> "tinyxml2::XMLAttribute const *":
        r""" Query a specific attribute in the list."""
        return _tesseract_common_python.XMLElement_FindAttribute(self, name)

    def GetText(self) -> "char const *":
        r"""
        Convenience function for easy access to the text inside an element. Although easy
           	and concise, GetText() is limited compared to getting the XMLText child
           	and accessing it directly.

           	If the first child of 'this' is a XMLText, the GetText()
           	returns the character string of the Text node, else null is returned.

           	This is a convenient method for getting the text of simple contained text:
           	    	<foo>This is text</foo>
           		const char* str = fooElement->GetText();


           	'str' will be a pointer to "This is text".

           	Note that this function can be misleading. If the element foo was created from
           	this XML:
           	    		<foo><b>This is text</b></foo>


           	then the value of str would be null. The first child node isn't a text node, it is
           	another element. From this XML:
           	    		<foo>This is <b>text</b></foo>

           	GetText() will return "This is ".
        """
        return _tesseract_common_python.XMLElement_GetText(self)

    def SetText(self, *args) -> "void":
        r"""
        *Overload 1:*
         Convenience function for easy access to the text inside an element. Although easy
            	and concise, SetText() is limited compared to creating an XMLText child
            	and mutating it directly.

            	If the first child of 'this' is a XMLText, SetText() sets its value to
        		the given string, otherwise it will create a first child that is an XMLText.

            	This is a convenient method for setting the text of simple contained text:
            	    	<foo>This is text</foo>
            		fooElement->SetText( "Hullaballoo!" );
             	<foo>Hullaballoo!</foo>


            	Note that this function can be misleading. If the element foo was created from
            	this XML:
            	    		<foo><b>This is text</b></foo>


            	then it will not change "This is text", but rather prefix it with a text element:
            	    		<foo>Hullaballoo!<b>This is text</b></foo>


        		For this XML:
            	    		<foo />

            	SetText() will generate
            	    		<foo>Hullaballoo!</foo>


        |

        *Overload 2:*
         Convenience method for setting text inside an element. See SetText() for important limitations.

        |

        *Overload 3:*
         Convenience method for setting text inside an element. See SetText() for important limitations.

        |

        *Overload 4:*
         Convenience method for setting text inside an element. See SetText() for important limitations.

        |

        *Overload 5:*
         Convenience method for setting text inside an element. See SetText() for important limitations.

        |

        *Overload 6:*
         Convenience method for setting text inside an element. See SetText() for important limitations.

        |

        *Overload 7:*
         Convenience method for setting text inside an element. See SetText() for important limitations.
        """
        return _tesseract_common_python.XMLElement_SetText(self, *args)

    def QueryIntText(self, ival: "int *") -> "tinyxml2::XMLError":
        r"""
            	Convenience method to query the value of a child text node. This is probably best
            	shown by example. Given you have a document is this form:
            	    		<point>
            			<x>1</x>
            			<y>1.4</y>
            		</point>


            	The QueryIntText() and similar functions provide a safe and easier way to get to the
            	"value" of x and y.

            	    		int x = 0;
            		float y = 0;	// types of x and y are contrived for example
            		const XMLElement* xElement = pointElement->FirstChildElement( "x" );
            		const XMLElement* yElement = pointElement->FirstChildElement( "y" );
            		xElement->QueryIntText( &x );
            		yElement->QueryFloatText( &y );


            	:rtype: int
        :return: XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted
                			 to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.
        """
        return _tesseract_common_python.XMLElement_QueryIntText(self, ival)

    def QueryUnsignedText(self, uval: "unsigned int *") -> "tinyxml2::XMLError":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_QueryUnsignedText(self, uval)

    def QueryInt64Text(self, uval: "int64_t *") -> "tinyxml2::XMLError":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_QueryInt64Text(self, uval)

    def QueryBoolText(self, bval: "bool *") -> "tinyxml2::XMLError":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_QueryBoolText(self, bval)

    def QueryDoubleText(self, dval: "double *") -> "tinyxml2::XMLError":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_QueryDoubleText(self, dval)

    def QueryFloatText(self, fval: "float *") -> "tinyxml2::XMLError":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_QueryFloatText(self, fval)

    def IntText(self, defaultValue: "int"=0) -> "int":
        return _tesseract_common_python.XMLElement_IntText(self, defaultValue)

    def UnsignedText(self, defaultValue: "unsigned int"=0) -> "unsigned int":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_UnsignedText(self, defaultValue)

    def Int64Text(self, defaultValue: "int64_t"=0) -> "int64_t":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_Int64Text(self, defaultValue)

    def BoolText(self, defaultValue: "bool"=False) -> "bool":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_BoolText(self, defaultValue)

    def DoubleText(self, defaultValue: "double"=0) -> "double":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_DoubleText(self, defaultValue)

    def FloatText(self, defaultValue: "float"=0) -> "float":
        r""" See QueryIntText()"""
        return _tesseract_common_python.XMLElement_FloatText(self, defaultValue)
    OPEN = _tesseract_common_python.XMLElement_OPEN
    CLOSED = _tesseract_common_python.XMLElement_CLOSED
    CLOSING = _tesseract_common_python.XMLElement_CLOSING

    def ClosingType(self) -> "tinyxml2::XMLElement::ElementClosingType":
        return _tesseract_common_python.XMLElement_ClosingType(self)

    def ShallowClone(self, document: "XMLDocument") -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLElement_ShallowClone(self, document)

    def ShallowEqual(self, compare: "XMLNode") -> "bool":
        return _tesseract_common_python.XMLElement_ShallowEqual(self, compare)

# Register XMLElement in _tesseract_common_python:
_tesseract_common_python.XMLElement_swigregister(XMLElement)

PRESERVE_WHITESPACE = _tesseract_common_python.PRESERVE_WHITESPACE
COLLAPSE_WHITESPACE = _tesseract_common_python.COLLAPSE_WHITESPACE
class XMLDocument(XMLNode):
    r"""
    A Document binds together all the functionality.
    It can be saved, loaded, and printed to the screen.
    All Nodes are connected and allocated to a Document.
    If the Document is deleted, all its Nodes are also deleted.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" constructor"""
        _tesseract_common_python.XMLDocument_swiginit(self, _tesseract_common_python.new_XMLDocument(*args))
    __swig_destroy__ = _tesseract_common_python.delete_XMLDocument

    def ToDocument(self, *args) -> "tinyxml2::XMLDocument const *":
        return _tesseract_common_python.XMLDocument_ToDocument(self, *args)

    def Parse(self, *args) -> "tinyxml2::XMLError":
        r"""
        Parse an XML file from a character string.
        Returns XML_SUCCESS (0) on success, or
        an errorID.

        You may optionally pass in the 'nBytes', which is
        the number of bytes which will be parsed. If not
        specified, TinyXML-2 will assume 'xml' points to a
        null terminated string.
        """
        return _tesseract_common_python.XMLDocument_Parse(self, *args)

    def LoadFile(self, *args) -> "tinyxml2::XMLError":
        r"""
        *Overload 1:*

        	Load an XML file from disk.
        	Returns XML_SUCCESS (0) on success, or
        	an errorID.

        |

        *Overload 2:*

        	Load an XML file from disk. You are responsible
        	for providing and closing the FILE*.

            NOTE: The file should be opened as binary ("rb")
            not text in order for TinyXML-2 to correctly
            do newline normalization.

        	Returns XML_SUCCESS (0) on success, or
        	an errorID.
        """
        return _tesseract_common_python.XMLDocument_LoadFile(self, *args)

    def SaveFile(self, *args) -> "tinyxml2::XMLError":
        r"""
        *Overload 1:*

        	Save the XML file to disk.
        	Returns XML_SUCCESS (0) on success, or
        	an errorID.

        |

        *Overload 2:*

        	Save the XML file to disk. You are responsible
        	for providing and closing the FILE*.

        	Returns XML_SUCCESS (0) on success, or
        	an errorID.

        |

        *Overload 3:*

        	Save the XML file to disk. You are responsible
        	for providing and closing the FILE*.

        	Returns XML_SUCCESS (0) on success, or
        	an errorID.
        """
        return _tesseract_common_python.XMLDocument_SaveFile(self, *args)

    def ProcessEntities(self) -> "bool":
        return _tesseract_common_python.XMLDocument_ProcessEntities(self)

    def WhitespaceMode(self) -> "tinyxml2::Whitespace":
        return _tesseract_common_python.XMLDocument_WhitespaceMode(self)

    def HasBOM(self) -> "bool":
        r"""    	Returns true if this document has a leading Byte Order Mark of UTF8."""
        return _tesseract_common_python.XMLDocument_HasBOM(self)

    def SetBOM(self, useBOM: "bool") -> "void":
        r""" Sets whether to write the BOM when writing the file."""
        return _tesseract_common_python.XMLDocument_SetBOM(self, useBOM)

    def RootElement(self, *args) -> "tinyxml2::XMLElement const *":
        return _tesseract_common_python.XMLDocument_RootElement(self, *args)

    def Print(self, streamer: "XMLPrinter"=None) -> "void":
        r"""
         Print the Document. If the Printer is not provided, it will
                print to stdout. If you provide Printer, this can print to a file:
            	    	XMLPrinter printer( fp );
            	doc.Print( &printer );


            	Or you can use a printer to print to memory:
            	    	XMLPrinter printer;
            	doc.Print( &printer );
        printer.CStr() has a const char* to the XML

        """
        return _tesseract_common_python.XMLDocument_Print(self, streamer)

    def Accept(self, visitor: "XMLVisitor") -> "bool":
        return _tesseract_common_python.XMLDocument_Accept(self, visitor)

    def NewElement(self, name: "char const *") -> "tinyxml2::XMLElement *":
        r"""
        Create a new Element associated with
        this Document. The memory for the Element
        is managed by the Document.
        """
        return _tesseract_common_python.XMLDocument_NewElement(self, name)

    def NewComment(self, comment: "char const *") -> "tinyxml2::XMLComment *":
        r"""
        Create a new Comment associated with
        this Document. The memory for the Comment
        is managed by the Document.
        """
        return _tesseract_common_python.XMLDocument_NewComment(self, comment)

    def NewText(self, text: "char const *") -> "tinyxml2::XMLText *":
        r"""
        Create a new Text associated with
        this Document. The memory for the Text
        is managed by the Document.
        """
        return _tesseract_common_python.XMLDocument_NewText(self, text)

    def NewDeclaration(self, text: "char const *"=None) -> "tinyxml2::XMLDeclaration *":
        r"""
        Create a new Declaration associated with
        this Document. The memory for the object
        is managed by the Document.

        If the 'text' param is null, the standard
        declaration is used.:
            		<?xml version="1.0" encoding="UTF-8"?>

        """
        return _tesseract_common_python.XMLDocument_NewDeclaration(self, text)

    def NewUnknown(self, text: "char const *") -> "tinyxml2::XMLUnknown *":
        r"""
        Create a new Unknown associated with
        this Document. The memory for the object
        is managed by the Document.
        """
        return _tesseract_common_python.XMLDocument_NewUnknown(self, text)

    def DeleteNode(self, node: "XMLNode") -> "void":
        r"""
        Delete a node associated with this document.
        It will be unlinked from the DOM.
        """
        return _tesseract_common_python.XMLDocument_DeleteNode(self, node)

    def ClearError(self) -> "void":
        return _tesseract_common_python.XMLDocument_ClearError(self)

    def Error(self) -> "bool":
        r""" Return true if there was an error parsing the document."""
        return _tesseract_common_python.XMLDocument_Error(self)

    def ErrorID(self) -> "tinyxml2::XMLError":
        r""" Return the errorID."""
        return _tesseract_common_python.XMLDocument_ErrorID(self)

    def ErrorName(self) -> "char const *":
        return _tesseract_common_python.XMLDocument_ErrorName(self)

    @staticmethod
    def ErrorIDToName(errorID: "tinyxml2::XMLError") -> "char const *":
        return _tesseract_common_python.XMLDocument_ErrorIDToName(errorID)

    def ErrorStr(self) -> "char const *":
        r"""
        Returns a "long form" error description. A hopefully helpful
               diagnostic with location, line number, and/or additional info.
        """
        return _tesseract_common_python.XMLDocument_ErrorStr(self)

    def PrintError(self) -> "void":
        r""" A (trivial) utility function that prints the ErrorStr() to stdout."""
        return _tesseract_common_python.XMLDocument_PrintError(self)

    def ErrorLineNum(self) -> "int":
        r""" Return the line where the error occured, or zero if unknown."""
        return _tesseract_common_python.XMLDocument_ErrorLineNum(self)

    def Clear(self) -> "void":
        r""" Clear the document, resetting it to the initial state."""
        return _tesseract_common_python.XMLDocument_Clear(self)

    def DeepCopy(self, target: "XMLDocument") -> "void":
        r"""
        Copies this document to a target document.
        The target will be completely cleared before the copy.
        If you want to copy a sub-tree, see XMLNode::DeepClone().

        NOTE: that the 'target' must be non-null.
        """
        return _tesseract_common_python.XMLDocument_DeepCopy(self, target)

    def Identify(self, p: "char *", node: "tinyxml2::XMLNode **") -> "char *":
        return _tesseract_common_python.XMLDocument_Identify(self, p, node)

    def MarkInUse(self, arg2: "XMLNode") -> "void":
        return _tesseract_common_python.XMLDocument_MarkInUse(self, arg2)

    def ShallowClone(self, arg2: "XMLDocument") -> "tinyxml2::XMLNode *":
        return _tesseract_common_python.XMLDocument_ShallowClone(self, arg2)

    def ShallowEqual(self, arg2: "XMLNode") -> "bool":
        return _tesseract_common_python.XMLDocument_ShallowEqual(self, arg2)

# Register XMLDocument in _tesseract_common_python:
_tesseract_common_python.XMLDocument_swigregister(XMLDocument)

def XMLDocument_ErrorIDToName(errorID: "tinyxml2::XMLError") -> "char const *":
    return _tesseract_common_python.XMLDocument_ErrorIDToName(errorID)

class XMLHandle(object, metaclass=_SwigNonDynamicMeta):
    r"""
    	A XMLHandle is a class that wraps a node pointer with null checks; this is
    	an incredibly useful thing. Note that XMLHandle is not part of the TinyXML-2
    	DOM structure. It is a separate utility class.

    	Take an example:
    		<Document>
    		<Element attributeA = "valueA">
    			<Child attributeB = "value1" />
    			<Child attributeB = "value2" />
    		</Element>
    	</Document>


    	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
    	easy to write a *lot* of code that looks like:

    		XMLElement* root = document.FirstChildElement( "Document" );
    	if ( root )
    	{
    		XMLElement* element = root->FirstChildElement( "Element" );
    		if ( element )
    		{
    			XMLElement* child = element->FirstChildElement( "Child" );
    			if ( child )
    			{
    				XMLElement* child2 = child->NextSiblingElement( "Child" );
    				if ( child2 )
    				{
    Finally do something useful.


    	And that doesn't even cover "else" cases. XMLHandle addresses the verbosity
    	of such code. A XMLHandle checks for null pointers so it is perfectly safe
    	and correct to use:

    		XMLHandle docHandle( &document );
    	XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();
    	if ( child2 )
    	{
    do something useful


    	Which is MUCH more concise and useful.

    	It is also safe to copy handles - internally they are nothing more than node pointers.
    		XMLHandle handleCopy = handle;


    	See also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Create a handle from any node (at any depth of the tree.) This can be a null pointer.

        |

        *Overload 2:*
        Create a handle from a node.

        |

        *Overload 3:*
        Copy constructor
        """
        _tesseract_common_python.XMLHandle_swiginit(self, _tesseract_common_python.new_XMLHandle(*args))

    def FirstChild(self) -> "tinyxml2::XMLHandle":
        r""" Get the first child of this handle."""
        return _tesseract_common_python.XMLHandle_FirstChild(self)

    def FirstChildElement(self, name: "char const *"=None) -> "tinyxml2::XMLHandle":
        r""" Get the first child element of this handle."""
        return _tesseract_common_python.XMLHandle_FirstChildElement(self, name)

    def LastChild(self) -> "tinyxml2::XMLHandle":
        r""" Get the last child of this handle."""
        return _tesseract_common_python.XMLHandle_LastChild(self)

    def LastChildElement(self, name: "char const *"=None) -> "tinyxml2::XMLHandle":
        r""" Get the last child element of this handle."""
        return _tesseract_common_python.XMLHandle_LastChildElement(self, name)

    def PreviousSibling(self) -> "tinyxml2::XMLHandle":
        r""" Get the previous sibling of this handle."""
        return _tesseract_common_python.XMLHandle_PreviousSibling(self)

    def PreviousSiblingElement(self, name: "char const *"=None) -> "tinyxml2::XMLHandle":
        r""" Get the previous sibling element of this handle."""
        return _tesseract_common_python.XMLHandle_PreviousSiblingElement(self, name)

    def NextSibling(self) -> "tinyxml2::XMLHandle":
        r""" Get the next sibling of this handle."""
        return _tesseract_common_python.XMLHandle_NextSibling(self)

    def NextSiblingElement(self, name: "char const *"=None) -> "tinyxml2::XMLHandle":
        r""" Get the next sibling element of this handle."""
        return _tesseract_common_python.XMLHandle_NextSiblingElement(self, name)

    def ToNode(self) -> "tinyxml2::XMLNode *":
        r""" Safe cast to XMLNode. This can return null."""
        return _tesseract_common_python.XMLHandle_ToNode(self)

    def ToElement(self) -> "tinyxml2::XMLElement *":
        r""" Safe cast to XMLElement. This can return null."""
        return _tesseract_common_python.XMLHandle_ToElement(self)

    def ToText(self) -> "tinyxml2::XMLText *":
        r""" Safe cast to XMLText. This can return null."""
        return _tesseract_common_python.XMLHandle_ToText(self)

    def ToUnknown(self) -> "tinyxml2::XMLUnknown *":
        r""" Safe cast to XMLUnknown. This can return null."""
        return _tesseract_common_python.XMLHandle_ToUnknown(self)

    def ToDeclaration(self) -> "tinyxml2::XMLDeclaration *":
        r""" Safe cast to XMLDeclaration. This can return null."""
        return _tesseract_common_python.XMLHandle_ToDeclaration(self)
    __swig_destroy__ = _tesseract_common_python.delete_XMLHandle

# Register XMLHandle in _tesseract_common_python:
_tesseract_common_python.XMLHandle_swigregister(XMLHandle)

class XMLConstHandle(object, metaclass=_SwigNonDynamicMeta):
    r"""
    A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
    same in all regards, except for the 'const' qualifiers. See XMLHandle for API.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.XMLConstHandle_swiginit(self, _tesseract_common_python.new_XMLConstHandle(*args))

    def FirstChild(self) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_FirstChild(self)

    def FirstChildElement(self, name: "char const *"=None) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_FirstChildElement(self, name)

    def LastChild(self) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_LastChild(self)

    def LastChildElement(self, name: "char const *"=None) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_LastChildElement(self, name)

    def PreviousSibling(self) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_PreviousSibling(self)

    def PreviousSiblingElement(self, name: "char const *"=None) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_PreviousSiblingElement(self, name)

    def NextSibling(self) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_NextSibling(self)

    def NextSiblingElement(self, name: "char const *"=None) -> "tinyxml2::XMLConstHandle const":
        return _tesseract_common_python.XMLConstHandle_NextSiblingElement(self, name)

    def ToNode(self) -> "tinyxml2::XMLNode const *":
        return _tesseract_common_python.XMLConstHandle_ToNode(self)

    def ToElement(self) -> "tinyxml2::XMLElement const *":
        return _tesseract_common_python.XMLConstHandle_ToElement(self)

    def ToText(self) -> "tinyxml2::XMLText const *":
        return _tesseract_common_python.XMLConstHandle_ToText(self)

    def ToUnknown(self) -> "tinyxml2::XMLUnknown const *":
        return _tesseract_common_python.XMLConstHandle_ToUnknown(self)

    def ToDeclaration(self) -> "tinyxml2::XMLDeclaration const *":
        return _tesseract_common_python.XMLConstHandle_ToDeclaration(self)
    __swig_destroy__ = _tesseract_common_python.delete_XMLConstHandle

# Register XMLConstHandle in _tesseract_common_python:
_tesseract_common_python.XMLConstHandle_swigregister(XMLConstHandle)

class XMLPrinter(XMLVisitor):
    r"""
    Printing functionality. The XMLPrinter gives you more
    options than the XMLDocument::Print() method.

    It can:
    -# Print to memory.
    -# Print to a file you provide.
    -# Print XML without a XMLDocument.

    Print to Memory

    	XMLPrinter printer;
    doc.Print( &printer );
    SomeFunction( printer.CStr() );


    Print to a File

    You provide the file pointer.
    	XMLPrinter printer( fp );
    doc.Print( &printer );


    Print without a XMLDocument

    When loading, an XML parser is very useful. However, sometimes
    when saving, it just gets in the way. The code is often set up
    for streaming, and constructing the DOM is just overhead.

    The Printer supports the streaming case. The following code
    prints out a trivially simple XML file without ever creating
    an XML document.

    	XMLPrinter printer( fp );
    printer.OpenElement( "foo" );
    printer.PushAttribute( "foo", "bar" );
    printer.CloseElement();

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, file: "FILE *"=None, compact: "bool"=False, depth: "int"=0):
        r"""
        Construct the printer. If the FILE* is specified,
           	this will print to the FILE. Else it will print
           	to memory, and the result is available in CStr().
           	If 'compact' is set to true, then output is created
           	with only required whitespace and newlines.
        """
        _tesseract_common_python.XMLPrinter_swiginit(self, _tesseract_common_python.new_XMLPrinter(file, compact, depth))
    __swig_destroy__ = _tesseract_common_python.delete_XMLPrinter

    def PushHeader(self, writeBOM: "bool", writeDeclaration: "bool") -> "void":
        r""" If streaming, write the BOM and declaration."""
        return _tesseract_common_python.XMLPrinter_PushHeader(self, writeBOM, writeDeclaration)

    def OpenElement(self, name: "char const *", compactMode: "bool"=False) -> "void":
        r"""
        If streaming, start writing an element.
               The element must be closed with CloseElement()
        """
        return _tesseract_common_python.XMLPrinter_OpenElement(self, name, compactMode)

    def PushAttribute(self, *args) -> "void":
        return _tesseract_common_python.XMLPrinter_PushAttribute(self, *args)

    def CloseElement(self, compactMode: "bool"=False) -> "void":
        r""" If streaming, close the Element."""
        return _tesseract_common_python.XMLPrinter_CloseElement(self, compactMode)

    def PushText(self, *args) -> "void":
        r"""
        *Overload 1:*
        Add a text node.

        |

        *Overload 2:*
        Add a text node from an integer.

        |

        *Overload 3:*
        Add a text node from an unsigned.

        |

        *Overload 4:*
        Add a text node from an unsigned.

        |

        *Overload 5:*
        Add a text node from a bool.

        |

        *Overload 6:*
        Add a text node from a float.

        |

        *Overload 7:*
        Add a text node from a double.
        """
        return _tesseract_common_python.XMLPrinter_PushText(self, *args)

    def PushComment(self, comment: "char const *") -> "void":
        r""" Add a comment"""
        return _tesseract_common_python.XMLPrinter_PushComment(self, comment)

    def PushDeclaration(self, value: "char const *") -> "void":
        return _tesseract_common_python.XMLPrinter_PushDeclaration(self, value)

    def PushUnknown(self, value: "char const *") -> "void":
        return _tesseract_common_python.XMLPrinter_PushUnknown(self, value)

    def VisitEnter(self, *args) -> "bool":
        return _tesseract_common_python.XMLPrinter_VisitEnter(self, *args)

    def VisitExit(self, *args) -> "bool":
        return _tesseract_common_python.XMLPrinter_VisitExit(self, *args)

    def Visit(self, *args) -> "bool":
        return _tesseract_common_python.XMLPrinter_Visit(self, *args)

    def CStr(self) -> "char const *":
        r"""
        If in print to memory mode, return a pointer to
        the XML file in memory.
        """
        return _tesseract_common_python.XMLPrinter_CStr(self)

    def CStrSize(self) -> "int":
        r"""
        If in print to memory mode, return the size
        of the XML file in memory. (Note the size returned
        includes the terminating null.)
        """
        return _tesseract_common_python.XMLPrinter_CStrSize(self)

    def ClearBuffer(self) -> "void":
        r"""
        If in print to memory mode, reset the buffer to the
        beginning.
        """
        return _tesseract_common_python.XMLPrinter_ClearBuffer(self)

# Register XMLPrinter in _tesseract_common_python:
_tesseract_common_python.XMLPrinter_swigregister(XMLPrinter)

class FilesystemPath(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, s: "std::string const &"):
        _tesseract_common_python.FilesystemPath_swiginit(self, _tesseract_common_python.new_FilesystemPath(s))

    def string(self) -> "std::string":
        return _tesseract_common_python.FilesystemPath_string(self)

    def __str__(self):
        return self.string()

    __swig_destroy__ = _tesseract_common_python.delete_FilesystemPath

# Register FilesystemPath in _tesseract_common_python:
_tesseract_common_python.FilesystemPath_swigregister(FilesystemPath)

class Quaterniond(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.Quaterniond_swiginit(self, _tesseract_common_python.new_Quaterniond(*args))

    def FromTwoVectors(self, a: "Eigen::Vector3d const", b: "Eigen::Vector3d const") -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_FromTwoVectors(self, a, b)

    @staticmethod
    def UnitRandom() -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_UnitRandom()

    def angularDistance(self, other: "Quaterniond") -> "double":
        return _tesseract_common_python.Quaterniond_angularDistance(self, other)

    def conjugate(self) -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_conjugate(self)

    def dot(self, other: "Quaterniond") -> "double":
        return _tesseract_common_python.Quaterniond_dot(self, other)

    def inverse(self) -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_inverse(self)

    def isApprox(self, *args) -> "bool":
        return _tesseract_common_python.Quaterniond_isApprox(self, *args)

    def norm(self) -> "double":
        return _tesseract_common_python.Quaterniond_norm(self)

    def normalize(self) -> "void":
        return _tesseract_common_python.Quaterniond_normalize(self)

    def normalized(self) -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_normalized(self)

    def __mul__(self, *args) -> "Eigen::Isometry3d":
        return _tesseract_common_python.Quaterniond___mul__(self, *args)

    def setFromTwoVectors(self, a: "Eigen::Vector3d const", b: "Eigen::Vector3d const") -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_setFromTwoVectors(self, a, b)

    def setIdentity(self) -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_setIdentity(self)

    def slerp(self, t: "double", other: "Quaterniond") -> "Eigen::Quaterniond":
        return _tesseract_common_python.Quaterniond_slerp(self, t, other)

    def squaredNorm(self) -> "double":
        return _tesseract_common_python.Quaterniond_squaredNorm(self)

    def toRotationMatrix(self) -> "Eigen::Matrix3d":
        return _tesseract_common_python.Quaterniond_toRotationMatrix(self)

    def vec(self) -> "Eigen::Vector3d":
        return _tesseract_common_python.Quaterniond_vec(self)

    def w(self) -> "double":
        return _tesseract_common_python.Quaterniond_w(self)

    def x(self) -> "double":
        return _tesseract_common_python.Quaterniond_x(self)

    def y(self) -> "double":
        return _tesseract_common_python.Quaterniond_y(self)

    def z(self) -> "double":
        return _tesseract_common_python.Quaterniond_z(self)

    def setVec(self, vec: "Eigen::Vector3d const &") -> "void":
        return _tesseract_common_python.Quaterniond_setVec(self, vec)

    def setW(self, w: "double") -> "void":
        return _tesseract_common_python.Quaterniond_setW(self, w)

    def setX(self, x: "double") -> "void":
        return _tesseract_common_python.Quaterniond_setX(self, x)

    def setY(self, y: "double") -> "void":
        return _tesseract_common_python.Quaterniond_setY(self, y)

    def setZ(self, z: "double") -> "void":
        return _tesseract_common_python.Quaterniond_setZ(self, z)
    __swig_destroy__ = _tesseract_common_python.delete_Quaterniond

# Register Quaterniond in _tesseract_common_python:
_tesseract_common_python.Quaterniond_swigregister(Quaterniond)

def Quaterniond_UnitRandom() -> "Eigen::Quaterniond":
    return _tesseract_common_python.Quaterniond_UnitRandom()

class AngleAxisd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.AngleAxisd_swiginit(self, _tesseract_common_python.new_AngleAxisd(*args))

    def angle(self) -> "double":
        return _tesseract_common_python.AngleAxisd_angle(self)

    def axis(self) -> "Eigen::Vector3d":
        return _tesseract_common_python.AngleAxisd_axis(self)

    def setAngle(self, angle: "double") -> "void":
        return _tesseract_common_python.AngleAxisd_setAngle(self, angle)

    def setAxis(self, axis: "Eigen::Vector3d const &") -> "void":
        return _tesseract_common_python.AngleAxisd_setAxis(self, axis)

    def inverse(self) -> "Eigen::AngleAxisd":
        return _tesseract_common_python.AngleAxisd_inverse(self)

    def isApprox(self, *args) -> "bool":
        return _tesseract_common_python.AngleAxisd_isApprox(self, *args)

    def toRotationMatrix(self) -> "Eigen::Matrix3d":
        return _tesseract_common_python.AngleAxisd_toRotationMatrix(self)

    def fromRotationMatrix(self, mat: "Eigen::Matrix3d const &") -> "Eigen::AngleAxisd":
        return _tesseract_common_python.AngleAxisd_fromRotationMatrix(self, mat)

    def __mul__(self, *args) -> "Eigen::Isometry3d":
        return _tesseract_common_python.AngleAxisd___mul__(self, *args)
    __swig_destroy__ = _tesseract_common_python.delete_AngleAxisd

# Register AngleAxisd in _tesseract_common_python:
_tesseract_common_python.AngleAxisd_swigregister(AngleAxisd)

class Translation3d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.Translation3d_swiginit(self, _tesseract_common_python.new_Translation3d(*args))

    def __mul__(self, *args) -> "Eigen::Isometry3d":
        return _tesseract_common_python.Translation3d___mul__(self, *args)

    def x(self) -> "double":
        return _tesseract_common_python.Translation3d_x(self)

    def y(self) -> "double":
        return _tesseract_common_python.Translation3d_y(self)

    def z(self) -> "double":
        return _tesseract_common_python.Translation3d_z(self)

    def setX(self, x: "double") -> "void":
        return _tesseract_common_python.Translation3d_setX(self, x)

    def setY(self, y: "double") -> "void":
        return _tesseract_common_python.Translation3d_setY(self, y)

    def setZ(self, z: "double") -> "void":
        return _tesseract_common_python.Translation3d_setZ(self, z)
    __swig_destroy__ = _tesseract_common_python.delete_Translation3d

# Register Translation3d in _tesseract_common_python:
_tesseract_common_python.Translation3d_swigregister(Translation3d)

class Isometry3d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.Isometry3d_swiginit(self, _tesseract_common_python.new_Isometry3d(*args))

    def isApprox(self, *args) -> "bool":
        return _tesseract_common_python.Isometry3d_isApprox(self, *args)

    def inverse(self) -> "Eigen::Isometry3d":
        return _tesseract_common_python.Isometry3d_inverse(self)

    def matrix(self) -> "Eigen::Matrix4d":
        return _tesseract_common_python.Isometry3d_matrix(self)

    def rotation(self) -> "Eigen::Matrix3d":
        return _tesseract_common_python.Isometry3d_rotation(self)

    def translation(self) -> "Eigen::Vector3d":
        return _tesseract_common_python.Isometry3d_translation(self)

    def linear(self) -> "Eigen::Matrix3d":
        return _tesseract_common_python.Isometry3d_linear(self)

    def setMatrix(self, matrix: "Eigen::Matrix4d const &") -> "void":
        return _tesseract_common_python.Isometry3d_setMatrix(self, matrix)

    def setTranslation(self, translation: "Eigen::Vector3d const &") -> "void":
        return _tesseract_common_python.Isometry3d_setTranslation(self, translation)

    def setLinear(self, linear: "Eigen::Matrix3d const &") -> "void":
        return _tesseract_common_python.Isometry3d_setLinear(self, linear)

    def __mul__(self, *args) -> "Eigen::Matrix4d":
        return _tesseract_common_python.Isometry3d___mul__(self, *args)

    def rotate(self, *args) -> "void":
        return _tesseract_common_python.Isometry3d_rotate(self, *args)

    def translate(self, vec: "Eigen::Vector3d const &") -> "void":
        return _tesseract_common_python.Isometry3d_translate(self, vec)

    def prerotate(self, *args) -> "void":
        return _tesseract_common_python.Isometry3d_prerotate(self, *args)

    def pretranslate(self, vec: "Eigen::Vector3d const &") -> "void":
        return _tesseract_common_python.Isometry3d_pretranslate(self, vec)

    def setIdentity(self) -> "void":
        return _tesseract_common_python.Isometry3d_setIdentity(self)

    @staticmethod
    def Identity() -> "Eigen::Isometry3d":
        return _tesseract_common_python.Isometry3d_Identity()
    __swig_destroy__ = _tesseract_common_python.delete_Isometry3d

# Register Isometry3d in _tesseract_common_python:
_tesseract_common_python.Isometry3d_swigregister(Isometry3d)

def Isometry3d_Identity() -> "Eigen::Isometry3d":
    return _tesseract_common_python.Isometry3d_Identity()

CONSOLE_BRIDGE_LOG_DEBUG = _tesseract_common_python.CONSOLE_BRIDGE_LOG_DEBUG
CONSOLE_BRIDGE_LOG_INFO = _tesseract_common_python.CONSOLE_BRIDGE_LOG_INFO
CONSOLE_BRIDGE_LOG_WARN = _tesseract_common_python.CONSOLE_BRIDGE_LOG_WARN
CONSOLE_BRIDGE_LOG_ERROR = _tesseract_common_python.CONSOLE_BRIDGE_LOG_ERROR
CONSOLE_BRIDGE_LOG_NONE = _tesseract_common_python.CONSOLE_BRIDGE_LOG_NONE

def setLogLevel(level: "console_bridge::LogLevel") -> "void":
    r"""
    Set the minimum level of logging data to output. Messages with lower logging levels will
    not be recorded.
    """
    return _tesseract_common_python.setLogLevel(level)

def getLogLevel() -> "console_bridge::LogLevel":
    r"""
    Retrieve the current level of logging data. Messages with lower logging levels will not be
    recorded.
    """
    return _tesseract_common_python.getLogLevel()
class OutputHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == OutputHandler:
            _self = None
        else:
            _self = self
        _tesseract_common_python.OutputHandler_swiginit(self, _tesseract_common_python.new_OutputHandler(_self, ))
    __swig_destroy__ = _tesseract_common_python.delete_OutputHandler

    def log(self, text: "std::string const &", level: "console_bridge::LogLevel", filename: "char const *", line: "int") -> "void":
        r"""
        log a message to the output handler with the given text and logging level from a
        specific file and line number
        :type text: string
        :param text: to log
        :type level: int
        :param level: console_bridge log level
        :type filename: string
        :param filename: of the output log
        :type line: int
        :param line:
        """
        return _tesseract_common_python.OutputHandler_log(self, text, level, filename, line)
    def __disown__(self):
        self.this.disown()
        _tesseract_common_python.disown_OutputHandler(self)
        return weakref.proxy(self)

# Register OutputHandler in _tesseract_common_python:
_tesseract_common_python.OutputHandler_swigregister(OutputHandler)


def noOutputHandler() -> "void":
    r"""
    This function instructs console bridge that no messages should be outputted.
    Equivalent to useOutputHandler(NULL)
    """
    return _tesseract_common_python.noOutputHandler()

def restorePreviousOutputHandler() -> "void":
    r"""Restore the output handler that was previously in use (if any)"""
    return _tesseract_common_python.restorePreviousOutputHandler()

def useOutputHandler(oh: "OutputHandler") -> "void":
    r"""
    Specify the instance of the OutputHandler to use.
    By default, this is OutputHandlerSTD
    """
    return _tesseract_common_python.useOutputHandler(oh)

def log(file: "char const *", line: "int", level: "console_bridge::LogLevel", m: "char const *") -> "void":
    r"""
    Root level logging function.  This should not be invoked directly, but rather used via a
    'logging macro'. Formats the message string given the arguments and forwards the
    string to the output handler
    """
    return _tesseract_common_python.log(file, line, level, m)
class vector_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.vector_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.vector_string___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _tesseract_common_python.vector_string___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _tesseract_common_python.vector_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.vector_string___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _tesseract_common_python.vector_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _tesseract_common_python.vector_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_string___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _tesseract_common_python.vector_string_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _tesseract_common_python.vector_string_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.vector_string_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _tesseract_common_python.vector_string_size(self)

    def swap(self, v: "vector_string") -> "void":
        return _tesseract_common_python.vector_string_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _tesseract_common_python.vector_string_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _tesseract_common_python.vector_string_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _tesseract_common_python.vector_string_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _tesseract_common_python.vector_string_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.vector_string_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _tesseract_common_python.vector_string_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.vector_string_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _tesseract_common_python.vector_string_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.vector_string_swiginit(self, _tesseract_common_python.new_vector_string(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _tesseract_common_python.vector_string_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _tesseract_common_python.vector_string_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _tesseract_common_python.vector_string_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _tesseract_common_python.vector_string_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.vector_string_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.vector_string_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _tesseract_common_python.vector_string_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _tesseract_common_python.vector_string_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_vector_string

# Register vector_string in _tesseract_common_python:
_tesseract_common_python.vector_string_swigregister(vector_string)

class set_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.set_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.set_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.set_string___bool__(self)

    def __len__(self) -> "std::set< std::string >::size_type":
        return _tesseract_common_python.set_string___len__(self)

    def append(self, x: "std::set< std::string >::value_type") -> "void":
        return _tesseract_common_python.set_string_append(self, x)

    def __contains__(self, x: "std::set< std::string >::value_type") -> "bool":
        return _tesseract_common_python.set_string___contains__(self, x)

    def __getitem__(self, i: "std::set< std::string >::difference_type") -> "std::set< std::string >::value_type":
        return _tesseract_common_python.set_string___getitem__(self, i)

    def add(self, x: "std::set< std::string >::value_type") -> "void":
        return _tesseract_common_python.set_string_add(self, x)

    def discard(self, x: "std::set< std::string >::value_type") -> "void":
        return _tesseract_common_python.set_string_discard(self, x)

    def __init__(self, *args):
        _tesseract_common_python.set_string_swiginit(self, _tesseract_common_python.new_set_string(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.set_string_empty(self)

    def size(self) -> "std::set< std::string >::size_type":
        return _tesseract_common_python.set_string_size(self)

    def clear(self) -> "void":
        return _tesseract_common_python.set_string_clear(self)

    def swap(self, v: "set_string") -> "void":
        return _tesseract_common_python.set_string_swap(self, v)

    def count(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::size_type":
        return _tesseract_common_python.set_string_count(self, x)

    def begin(self) -> "std::set< std::string >::iterator":
        return _tesseract_common_python.set_string_begin(self)

    def end(self) -> "std::set< std::string >::iterator":
        return _tesseract_common_python.set_string_end(self)

    def rbegin(self) -> "std::set< std::string >::reverse_iterator":
        return _tesseract_common_python.set_string_rbegin(self)

    def rend(self) -> "std::set< std::string >::reverse_iterator":
        return _tesseract_common_python.set_string_rend(self)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.set_string_erase(self, *args)

    def find(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        return _tesseract_common_python.set_string_find(self, x)

    def lower_bound(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        return _tesseract_common_python.set_string_lower_bound(self, x)

    def upper_bound(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        return _tesseract_common_python.set_string_upper_bound(self, x)

    def equal_range(self, x: "std::set< std::string >::key_type const &") -> "std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >":
        return _tesseract_common_python.set_string_equal_range(self, x)

    def insert(self, __x: "std::set< std::string >::value_type const &") -> "std::pair< std::set< std::string >::iterator,bool >":
        return _tesseract_common_python.set_string_insert(self, __x)
    __swig_destroy__ = _tesseract_common_python.delete_set_string

# Register set_string in _tesseract_common_python:
_tesseract_common_python.set_string_swigregister(set_string)

class pair_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.pair_string_swiginit(self, _tesseract_common_python.new_pair_string(*args))
    first = property(_tesseract_common_python.pair_string_first_get, _tesseract_common_python.pair_string_first_set)
    second = property(_tesseract_common_python.pair_string_second_get, _tesseract_common_python.pair_string_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _tesseract_common_python.delete_pair_string

# Register pair_string in _tesseract_common_python:
_tesseract_common_python.pair_string_swigregister(pair_string)

class vector_pair_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.vector_pair_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.vector_pair_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.vector_pair_string___bool__(self)

    def __len__(self) -> "std::vector< std::pair< std::string,std::string > >::size_type":
        return _tesseract_common_python.vector_pair_string___len__(self)

    def __getslice__(self, i: "std::vector< std::pair< std::string,std::string > >::difference_type", j: "std::vector< std::pair< std::string,std::string > >::difference_type") -> "std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > > *":
        return _tesseract_common_python.vector_pair_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.vector_pair_string___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::pair< std::string,std::string > >::difference_type", j: "std::vector< std::pair< std::string,std::string > >::difference_type") -> "void":
        return _tesseract_common_python.vector_pair_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_pair_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< std::string,std::string > >::value_type const &":
        return _tesseract_common_python.vector_pair_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_pair_string___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< std::string,std::string > >::value_type":
        return _tesseract_common_python.vector_pair_string_pop(self)

    def append(self, x: "pair_string") -> "void":
        return _tesseract_common_python.vector_pair_string_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.vector_pair_string_empty(self)

    def size(self) -> "std::vector< std::pair< std::string,std::string > >::size_type":
        return _tesseract_common_python.vector_pair_string_size(self)

    def swap(self, v: "vector_pair_string") -> "void":
        return _tesseract_common_python.vector_pair_string_swap(self, v)

    def begin(self) -> "std::vector< std::pair< std::string,std::string > >::iterator":
        return _tesseract_common_python.vector_pair_string_begin(self)

    def end(self) -> "std::vector< std::pair< std::string,std::string > >::iterator":
        return _tesseract_common_python.vector_pair_string_end(self)

    def rbegin(self) -> "std::vector< std::pair< std::string,std::string > >::reverse_iterator":
        return _tesseract_common_python.vector_pair_string_rbegin(self)

    def rend(self) -> "std::vector< std::pair< std::string,std::string > >::reverse_iterator":
        return _tesseract_common_python.vector_pair_string_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.vector_pair_string_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< std::string,std::string > >::allocator_type":
        return _tesseract_common_python.vector_pair_string_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.vector_pair_string_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< std::string,std::string > >::iterator":
        return _tesseract_common_python.vector_pair_string_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.vector_pair_string_swiginit(self, _tesseract_common_python.new_vector_pair_string(*args))

    def push_back(self, x: "pair_string") -> "void":
        return _tesseract_common_python.vector_pair_string_push_back(self, x)

    def front(self) -> "std::vector< std::pair< std::string,std::string > >::value_type const &":
        return _tesseract_common_python.vector_pair_string_front(self)

    def back(self) -> "std::vector< std::pair< std::string,std::string > >::value_type const &":
        return _tesseract_common_python.vector_pair_string_back(self)

    def assign(self, n: "std::vector< std::pair< std::string,std::string > >::size_type", x: "pair_string") -> "void":
        return _tesseract_common_python.vector_pair_string_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.vector_pair_string_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.vector_pair_string_insert(self, *args)

    def reserve(self, n: "std::vector< std::pair< std::string,std::string > >::size_type") -> "void":
        return _tesseract_common_python.vector_pair_string_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< std::string,std::string > >::size_type":
        return _tesseract_common_python.vector_pair_string_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_vector_pair_string

# Register vector_pair_string in _tesseract_common_python:
_tesseract_common_python.vector_pair_string_swigregister(vector_pair_string)

class map_string_vector_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.map_string_vector_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.map_string_vector_string___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::vector< std::string > >::size_type":
        return _tesseract_common_python.map_string_vector_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::vector< std::string > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::string > >::mapped_type const &":
        return _tesseract_common_python.map_string_vector_string___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::vector< std::string > >::key_type const &") -> "void":
        return _tesseract_common_python.map_string_vector_string___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::vector< std::string > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_vector_string_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_string_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_string_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_string_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::vector< std::string > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_vector_string___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_string_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_string_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.map_string_vector_string___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_string_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.map_string_vector_string_swiginit(self, _tesseract_common_python.new_map_string_vector_string(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.map_string_vector_string_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::vector< std::string > >::size_type":
        return _tesseract_common_python.map_string_vector_string_size(self)

    def swap(self, v: "map_string_vector_string") -> "void":
        return _tesseract_common_python.map_string_vector_string_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::vector< std::string > >::iterator":
        return _tesseract_common_python.map_string_vector_string_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::vector< std::string > >::iterator":
        return _tesseract_common_python.map_string_vector_string_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.map_string_vector_string_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::vector< std::string > >::allocator_type":
        return _tesseract_common_python.map_string_vector_string_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::vector< std::string > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::string > >::size_type":
        return _tesseract_common_python.map_string_vector_string_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.map_string_vector_string_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::vector< std::string > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::string > >::iterator":
        return _tesseract_common_python.map_string_vector_string_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_map_string_vector_string

# Register map_string_vector_string in _tesseract_common_python:
_tesseract_common_python.map_string_vector_string_swigregister(map_string_vector_string)

class map_string_vector_pair_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_pair_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.map_string_vector_pair_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.map_string_vector_pair_string___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::size_type":
        return _tesseract_common_python.map_string_vector_pair_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::mapped_type const &":
        return _tesseract_common_python.map_string_vector_pair_string___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::key_type const &") -> "void":
        return _tesseract_common_python.map_string_vector_pair_string___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_vector_pair_string_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_pair_string_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_pair_string_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_pair_string_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_vector_pair_string___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_pair_string_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_pair_string_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.map_string_vector_pair_string___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_pair_string_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.map_string_vector_pair_string_swiginit(self, _tesseract_common_python.new_map_string_vector_pair_string(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.map_string_vector_pair_string_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::size_type":
        return _tesseract_common_python.map_string_vector_pair_string_size(self)

    def swap(self, v: "map_string_vector_pair_string") -> "void":
        return _tesseract_common_python.map_string_vector_pair_string_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::iterator":
        return _tesseract_common_python.map_string_vector_pair_string_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::iterator":
        return _tesseract_common_python.map_string_vector_pair_string_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.map_string_vector_pair_string_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::allocator_type":
        return _tesseract_common_python.map_string_vector_pair_string_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::size_type":
        return _tesseract_common_python.map_string_vector_pair_string_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.map_string_vector_pair_string_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::key_type const &") -> "std::unordered_map< std::string,std::vector< std::pair< std::string,std::string > > >::iterator":
        return _tesseract_common_python.map_string_vector_pair_string_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_map_string_vector_pair_string

# Register map_string_vector_pair_string in _tesseract_common_python:
_tesseract_common_python.map_string_vector_pair_string_swigregister(map_string_vector_pair_string)

class pair_vector_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.pair_vector_string_swiginit(self, _tesseract_common_python.new_pair_vector_string(*args))
    first = property(_tesseract_common_python.pair_vector_string_first_get, _tesseract_common_python.pair_vector_string_first_set)
    second = property(_tesseract_common_python.pair_vector_string_second_get, _tesseract_common_python.pair_vector_string_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _tesseract_common_python.delete_pair_vector_string

# Register pair_vector_string in _tesseract_common_python:
_tesseract_common_python.pair_vector_string_swigregister(pair_vector_string)

class vector_double(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.vector_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.vector_double___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _tesseract_common_python.vector_double___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _tesseract_common_python.vector_double___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.vector_double___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _tesseract_common_python.vector_double___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_double___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _tesseract_common_python.vector_double___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_double___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _tesseract_common_python.vector_double_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _tesseract_common_python.vector_double_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.vector_double_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _tesseract_common_python.vector_double_size(self)

    def swap(self, v: "vector_double") -> "void":
        return _tesseract_common_python.vector_double_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _tesseract_common_python.vector_double_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _tesseract_common_python.vector_double_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _tesseract_common_python.vector_double_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _tesseract_common_python.vector_double_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.vector_double_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _tesseract_common_python.vector_double_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.vector_double_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _tesseract_common_python.vector_double_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.vector_double_swiginit(self, _tesseract_common_python.new_vector_double(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _tesseract_common_python.vector_double_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _tesseract_common_python.vector_double_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _tesseract_common_python.vector_double_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _tesseract_common_python.vector_double_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.vector_double_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.vector_double_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _tesseract_common_python.vector_double_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _tesseract_common_python.vector_double_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_vector_double

# Register vector_double in _tesseract_common_python:
_tesseract_common_python.vector_double_swigregister(vector_double)

class map_string_vector_double(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.map_string_vector_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.map_string_vector_double___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::vector< double > >::size_type":
        return _tesseract_common_python.map_string_vector_double___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::vector< double > >::key_type const &") -> "std::unordered_map< std::string,std::vector< double > >::mapped_type const &":
        return _tesseract_common_python.map_string_vector_double___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::vector< double > >::key_type const &") -> "void":
        return _tesseract_common_python.map_string_vector_double___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::vector< double > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_vector_double_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_double_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_double_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_double_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::vector< double > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_vector_double___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_double_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_vector_double_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.map_string_vector_double___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.map_string_vector_double_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.map_string_vector_double_swiginit(self, _tesseract_common_python.new_map_string_vector_double(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.map_string_vector_double_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::vector< double > >::size_type":
        return _tesseract_common_python.map_string_vector_double_size(self)

    def swap(self, v: "map_string_vector_double") -> "void":
        return _tesseract_common_python.map_string_vector_double_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::vector< double > >::iterator":
        return _tesseract_common_python.map_string_vector_double_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::vector< double > >::iterator":
        return _tesseract_common_python.map_string_vector_double_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.map_string_vector_double_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::vector< double > >::allocator_type":
        return _tesseract_common_python.map_string_vector_double_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::vector< double > >::key_type const &") -> "std::unordered_map< std::string,std::vector< double > >::size_type":
        return _tesseract_common_python.map_string_vector_double_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.map_string_vector_double_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::vector< double > >::key_type const &") -> "std::unordered_map< std::string,std::vector< double > >::iterator":
        return _tesseract_common_python.map_string_vector_double_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_map_string_vector_double

# Register map_string_vector_double in _tesseract_common_python:
_tesseract_common_python.map_string_vector_double_swigregister(map_string_vector_double)

class map_string_double(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.map_string_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.map_string_double___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,double >::size_type":
        return _tesseract_common_python.map_string_double___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "std::unordered_map< std::string,double >::mapped_type const &":
        return _tesseract_common_python.map_string_double___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "void":
        return _tesseract_common_python.map_string_double___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_double_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.map_string_double_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.map_string_double_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.map_string_double_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_double___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_double_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_double_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.map_string_double___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.map_string_double_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.map_string_double_swiginit(self, _tesseract_common_python.new_map_string_double(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.map_string_double_empty(self)

    def size(self) -> "std::unordered_map< std::string,double >::size_type":
        return _tesseract_common_python.map_string_double_size(self)

    def swap(self, v: "map_string_double") -> "void":
        return _tesseract_common_python.map_string_double_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,double >::iterator":
        return _tesseract_common_python.map_string_double_begin(self)

    def end(self) -> "std::unordered_map< std::string,double >::iterator":
        return _tesseract_common_python.map_string_double_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.map_string_double_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,double >::allocator_type":
        return _tesseract_common_python.map_string_double_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,double >::key_type const &") -> "std::unordered_map< std::string,double >::size_type":
        return _tesseract_common_python.map_string_double_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.map_string_double_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,double >::key_type const &") -> "std::unordered_map< std::string,double >::iterator":
        return _tesseract_common_python.map_string_double_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_map_string_double

# Register map_string_double in _tesseract_common_python:
_tesseract_common_python.map_string_double_swigregister(map_string_double)

class map_string_map_string_double(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_double___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::size_type":
        return _tesseract_common_python.map_string_map_string_double___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,double > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::mapped_type const &":
        return _tesseract_common_python.map_string_map_string_double___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,double > >::key_type const &") -> "void":
        return _tesseract_common_python.map_string_map_string_double___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,double > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_map_string_double_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_double_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_double_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_double_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,double > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_map_string_double___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_double_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_double_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.map_string_map_string_double___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_double_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.map_string_map_string_double_swiginit(self, _tesseract_common_python.new_map_string_map_string_double(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_double_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::size_type":
        return _tesseract_common_python.map_string_map_string_double_size(self)

    def swap(self, v: "map_string_map_string_double") -> "void":
        return _tesseract_common_python.map_string_map_string_double_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::iterator":
        return _tesseract_common_python.map_string_map_string_double_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::iterator":
        return _tesseract_common_python.map_string_map_string_double_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.map_string_map_string_double_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::allocator_type":
        return _tesseract_common_python.map_string_map_string_double_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::unordered_map< std::string,double > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::size_type":
        return _tesseract_common_python.map_string_map_string_double_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.map_string_map_string_double_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::unordered_map< std::string,double > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,double > >::iterator":
        return _tesseract_common_python.map_string_map_string_double_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_map_string_map_string_double

# Register map_string_map_string_double in _tesseract_common_python:
_tesseract_common_python.map_string_map_string_double_swigregister(map_string_map_string_double)

class map_string_map_string_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_string___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::size_type":
        return _tesseract_common_python.map_string_map_string_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::mapped_type const &":
        return _tesseract_common_python.map_string_map_string_string___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::key_type const &") -> "void":
        return _tesseract_common_python.map_string_map_string_string___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_map_string_string_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_string_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_string_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_string_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_map_string_string___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_string_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_string_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.map_string_map_string_string___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_string_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.map_string_map_string_string_swiginit(self, _tesseract_common_python.new_map_string_map_string_string(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_string_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::size_type":
        return _tesseract_common_python.map_string_map_string_string_size(self)

    def swap(self, v: "map_string_map_string_string") -> "void":
        return _tesseract_common_python.map_string_map_string_string_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::iterator":
        return _tesseract_common_python.map_string_map_string_string_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::iterator":
        return _tesseract_common_python.map_string_map_string_string_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.map_string_map_string_string_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::allocator_type":
        return _tesseract_common_python.map_string_map_string_string_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::size_type":
        return _tesseract_common_python.map_string_map_string_string_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.map_string_map_string_string_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,std::string > >::iterator":
        return _tesseract_common_python.map_string_map_string_string_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_map_string_map_string_string

# Register map_string_map_string_string in _tesseract_common_python:
_tesseract_common_python.map_string_map_string_string_swigregister(map_string_map_string_string)

class map_string_map_string_map_string_double(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_map_string_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_map_string_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_map_string_double___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::size_type":
        return _tesseract_common_python.map_string_map_string_map_string_double___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::mapped_type const &":
        return _tesseract_common_python.map_string_map_string_map_string_double___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::key_type const &") -> "void":
        return _tesseract_common_python.map_string_map_string_map_string_double___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_map_string_map_string_double_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_map_string_double_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_map_string_double_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_map_string_double_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::key_type const &") -> "bool":
        return _tesseract_common_python.map_string_map_string_map_string_double___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_map_string_double_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.map_string_map_string_map_string_double_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.map_string_map_string_map_string_double___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.map_string_map_string_map_string_double_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.map_string_map_string_map_string_double_swiginit(self, _tesseract_common_python.new_map_string_map_string_map_string_double(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.map_string_map_string_map_string_double_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::size_type":
        return _tesseract_common_python.map_string_map_string_map_string_double_size(self)

    def swap(self, v: "map_string_map_string_map_string_double") -> "void":
        return _tesseract_common_python.map_string_map_string_map_string_double_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::iterator":
        return _tesseract_common_python.map_string_map_string_map_string_double_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::iterator":
        return _tesseract_common_python.map_string_map_string_map_string_double_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.map_string_map_string_map_string_double_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::allocator_type":
        return _tesseract_common_python.map_string_map_string_map_string_double_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::size_type":
        return _tesseract_common_python.map_string_map_string_map_string_double_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.map_string_map_string_map_string_double_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::key_type const &") -> "std::unordered_map< std::string,std::unordered_map< std::string,std::unordered_map< std::string,double > > >::iterator":
        return _tesseract_common_python.map_string_map_string_map_string_double_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_map_string_map_string_map_string_double

# Register map_string_map_string_map_string_double in _tesseract_common_python:
_tesseract_common_python.map_string_map_string_map_string_double_swigregister(map_string_map_string_map_string_double)

class vector_size_t(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.vector_size_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.vector_size_t___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.vector_size_t___bool__(self)

    def __len__(self) -> "std::vector< ::size_t >::size_type":
        return _tesseract_common_python.vector_size_t___len__(self)

    def __getslice__(self, i: "std::vector< ::size_t >::difference_type", j: "std::vector< ::size_t >::difference_type") -> "std::vector< ::size_t,std::allocator< ::size_t > > *":
        return _tesseract_common_python.vector_size_t___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.vector_size_t___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ::size_t >::difference_type", j: "std::vector< ::size_t >::difference_type") -> "void":
        return _tesseract_common_python.vector_size_t___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_size_t___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ::size_t >::value_type const &":
        return _tesseract_common_python.vector_size_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_size_t___setitem__(self, *args)

    def pop(self) -> "std::vector< ::size_t >::value_type":
        return _tesseract_common_python.vector_size_t_pop(self)

    def append(self, x: "std::vector< ::size_t >::value_type const &") -> "void":
        return _tesseract_common_python.vector_size_t_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.vector_size_t_empty(self)

    def size(self) -> "std::vector< ::size_t >::size_type":
        return _tesseract_common_python.vector_size_t_size(self)

    def swap(self, v: "vector_size_t") -> "void":
        return _tesseract_common_python.vector_size_t_swap(self, v)

    def begin(self) -> "std::vector< ::size_t >::iterator":
        return _tesseract_common_python.vector_size_t_begin(self)

    def end(self) -> "std::vector< ::size_t >::iterator":
        return _tesseract_common_python.vector_size_t_end(self)

    def rbegin(self) -> "std::vector< ::size_t >::reverse_iterator":
        return _tesseract_common_python.vector_size_t_rbegin(self)

    def rend(self) -> "std::vector< ::size_t >::reverse_iterator":
        return _tesseract_common_python.vector_size_t_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.vector_size_t_clear(self)

    def get_allocator(self) -> "std::vector< ::size_t >::allocator_type":
        return _tesseract_common_python.vector_size_t_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.vector_size_t_pop_back(self)

    def erase(self, *args) -> "std::vector< ::size_t >::iterator":
        return _tesseract_common_python.vector_size_t_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.vector_size_t_swiginit(self, _tesseract_common_python.new_vector_size_t(*args))

    def push_back(self, x: "std::vector< ::size_t >::value_type const &") -> "void":
        return _tesseract_common_python.vector_size_t_push_back(self, x)

    def front(self) -> "std::vector< ::size_t >::value_type const &":
        return _tesseract_common_python.vector_size_t_front(self)

    def back(self) -> "std::vector< ::size_t >::value_type const &":
        return _tesseract_common_python.vector_size_t_back(self)

    def assign(self, n: "std::vector< ::size_t >::size_type", x: "std::vector< ::size_t >::value_type const &") -> "void":
        return _tesseract_common_python.vector_size_t_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.vector_size_t_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.vector_size_t_insert(self, *args)

    def reserve(self, n: "std::vector< ::size_t >::size_type") -> "void":
        return _tesseract_common_python.vector_size_t_reserve(self, n)

    def capacity(self) -> "std::vector< ::size_t >::size_type":
        return _tesseract_common_python.vector_size_t_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_vector_size_t

# Register vector_size_t in _tesseract_common_python:
_tesseract_common_python.vector_size_t_swigregister(vector_size_t)

class array2_int(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.array2_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.array2_int___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.array2_int___bool__(self)

    def __len__(self) -> "std::array< int,2 >::size_type":
        return _tesseract_common_python.array2_int___len__(self)

    def __getslice__(self, i: "std::array< int,2 >::difference_type", j: "std::array< int,2 >::difference_type") -> "std::array< int,2 > *":
        return _tesseract_common_python.array2_int___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.array2_int___setslice__(self, *args)

    def __delslice__(self, i: "std::array< int,2 >::difference_type", j: "std::array< int,2 >::difference_type") -> "void":
        return _tesseract_common_python.array2_int___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_int___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::array< int,2 >::value_type const &":
        return _tesseract_common_python.array2_int___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_int___setitem__(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.array2_int_swiginit(self, _tesseract_common_python.new_array2_int(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.array2_int_empty(self)

    def size(self) -> "std::array< int,2 >::size_type":
        return _tesseract_common_python.array2_int_size(self)

    def swap(self, v: "array2_int") -> "void":
        return _tesseract_common_python.array2_int_swap(self, v)

    def begin(self) -> "std::array< int,2 >::iterator":
        return _tesseract_common_python.array2_int_begin(self)

    def end(self) -> "std::array< int,2 >::iterator":
        return _tesseract_common_python.array2_int_end(self)

    def rbegin(self) -> "std::array< int,2 >::reverse_iterator":
        return _tesseract_common_python.array2_int_rbegin(self)

    def rend(self) -> "std::array< int,2 >::reverse_iterator":
        return _tesseract_common_python.array2_int_rend(self)

    def front(self) -> "std::array< int,2 >::value_type const &":
        return _tesseract_common_python.array2_int_front(self)

    def back(self) -> "std::array< int,2 >::value_type const &":
        return _tesseract_common_python.array2_int_back(self)

    def fill(self, u: "std::array< int,2 >::value_type const &") -> "void":
        return _tesseract_common_python.array2_int_fill(self, u)
    __swig_destroy__ = _tesseract_common_python.delete_array2_int

# Register array2_int in _tesseract_common_python:
_tesseract_common_python.array2_int_swigregister(array2_int)

class array2_string(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.array2_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.array2_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.array2_string___bool__(self)

    def __len__(self) -> "std::array< std::string,2 >::size_type":
        return _tesseract_common_python.array2_string___len__(self)

    def __getslice__(self, i: "std::array< std::string,2 >::difference_type", j: "std::array< std::string,2 >::difference_type") -> "std::array< std::string,2 > *":
        return _tesseract_common_python.array2_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.array2_string___setslice__(self, *args)

    def __delslice__(self, i: "std::array< std::string,2 >::difference_type", j: "std::array< std::string,2 >::difference_type") -> "void":
        return _tesseract_common_python.array2_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::array< std::string,2 >::value_type const &":
        return _tesseract_common_python.array2_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_string___setitem__(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.array2_string_swiginit(self, _tesseract_common_python.new_array2_string(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.array2_string_empty(self)

    def size(self) -> "std::array< std::string,2 >::size_type":
        return _tesseract_common_python.array2_string_size(self)

    def swap(self, v: "array2_string") -> "void":
        return _tesseract_common_python.array2_string_swap(self, v)

    def begin(self) -> "std::array< std::string,2 >::iterator":
        return _tesseract_common_python.array2_string_begin(self)

    def end(self) -> "std::array< std::string,2 >::iterator":
        return _tesseract_common_python.array2_string_end(self)

    def rbegin(self) -> "std::array< std::string,2 >::reverse_iterator":
        return _tesseract_common_python.array2_string_rbegin(self)

    def rend(self) -> "std::array< std::string,2 >::reverse_iterator":
        return _tesseract_common_python.array2_string_rend(self)

    def front(self) -> "std::array< std::string,2 >::value_type const &":
        return _tesseract_common_python.array2_string_front(self)

    def back(self) -> "std::array< std::string,2 >::value_type const &":
        return _tesseract_common_python.array2_string_back(self)

    def fill(self, u: "std::array< std::string,2 >::value_type const &") -> "void":
        return _tesseract_common_python.array2_string_fill(self, u)
    __swig_destroy__ = _tesseract_common_python.delete_array2_string

# Register array2_string in _tesseract_common_python:
_tesseract_common_python.array2_string_swigregister(array2_string)

class array2_Vector3d(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.array2_Vector3d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.array2_Vector3d___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.array2_Vector3d___bool__(self)

    def __len__(self) -> "std::array< Eigen::Vector3d,2 >::size_type":
        return _tesseract_common_python.array2_Vector3d___len__(self)

    def __getslice__(self, i: "std::array< Eigen::Vector3d,2 >::difference_type", j: "std::array< Eigen::Vector3d,2 >::difference_type") -> "std::array< Eigen::Vector3d,2 > *":
        return _tesseract_common_python.array2_Vector3d___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.array2_Vector3d___setslice__(self, *args)

    def __delslice__(self, i: "std::array< Eigen::Vector3d,2 >::difference_type", j: "std::array< Eigen::Vector3d,2 >::difference_type") -> "void":
        return _tesseract_common_python.array2_Vector3d___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_Vector3d___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::array< Eigen::Vector3d,2 >::value_type const &":
        return _tesseract_common_python.array2_Vector3d___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_Vector3d___setitem__(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.array2_Vector3d_swiginit(self, _tesseract_common_python.new_array2_Vector3d(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.array2_Vector3d_empty(self)

    def size(self) -> "std::array< Eigen::Vector3d,2 >::size_type":
        return _tesseract_common_python.array2_Vector3d_size(self)

    def swap(self, v: "array2_Vector3d") -> "void":
        return _tesseract_common_python.array2_Vector3d_swap(self, v)

    def begin(self) -> "std::array< Eigen::Vector3d,2 >::iterator":
        return _tesseract_common_python.array2_Vector3d_begin(self)

    def end(self) -> "std::array< Eigen::Vector3d,2 >::iterator":
        return _tesseract_common_python.array2_Vector3d_end(self)

    def rbegin(self) -> "std::array< Eigen::Vector3d,2 >::reverse_iterator":
        return _tesseract_common_python.array2_Vector3d_rbegin(self)

    def rend(self) -> "std::array< Eigen::Vector3d,2 >::reverse_iterator":
        return _tesseract_common_python.array2_Vector3d_rend(self)

    def front(self) -> "std::array< Eigen::Vector3d,2 >::value_type const &":
        return _tesseract_common_python.array2_Vector3d_front(self)

    def back(self) -> "std::array< Eigen::Vector3d,2 >::value_type const &":
        return _tesseract_common_python.array2_Vector3d_back(self)

    def fill(self, u: "std::array< Eigen::Vector3d,2 >::value_type const &") -> "void":
        return _tesseract_common_python.array2_Vector3d_fill(self, u)
    __swig_destroy__ = _tesseract_common_python.delete_array2_Vector3d

# Register array2_Vector3d in _tesseract_common_python:
_tesseract_common_python.array2_Vector3d_swigregister(array2_Vector3d)

class array2_Isometry3d(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.array2_Isometry3d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.array2_Isometry3d___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.array2_Isometry3d___bool__(self)

    def __len__(self) -> "std::array< Eigen::Isometry3d,2 >::size_type":
        return _tesseract_common_python.array2_Isometry3d___len__(self)

    def __getslice__(self, i: "std::array< Eigen::Isometry3d,2 >::difference_type", j: "std::array< Eigen::Isometry3d,2 >::difference_type") -> "std::array< Eigen::Isometry3d,2 > *":
        return _tesseract_common_python.array2_Isometry3d___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.array2_Isometry3d___setslice__(self, *args)

    def __delslice__(self, i: "std::array< Eigen::Isometry3d,2 >::difference_type", j: "std::array< Eigen::Isometry3d,2 >::difference_type") -> "void":
        return _tesseract_common_python.array2_Isometry3d___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_Isometry3d___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::array< Eigen::Isometry3d,2 >::value_type const &":
        return _tesseract_common_python.array2_Isometry3d___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_Isometry3d___setitem__(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.array2_Isometry3d_swiginit(self, _tesseract_common_python.new_array2_Isometry3d(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.array2_Isometry3d_empty(self)

    def size(self) -> "std::array< Eigen::Isometry3d,2 >::size_type":
        return _tesseract_common_python.array2_Isometry3d_size(self)

    def swap(self, v: "array2_Isometry3d") -> "void":
        return _tesseract_common_python.array2_Isometry3d_swap(self, v)

    def begin(self) -> "std::array< Eigen::Isometry3d,2 >::iterator":
        return _tesseract_common_python.array2_Isometry3d_begin(self)

    def end(self) -> "std::array< Eigen::Isometry3d,2 >::iterator":
        return _tesseract_common_python.array2_Isometry3d_end(self)

    def rbegin(self) -> "std::array< Eigen::Isometry3d,2 >::reverse_iterator":
        return _tesseract_common_python.array2_Isometry3d_rbegin(self)

    def rend(self) -> "std::array< Eigen::Isometry3d,2 >::reverse_iterator":
        return _tesseract_common_python.array2_Isometry3d_rend(self)

    def front(self) -> "std::array< Eigen::Isometry3d,2 >::value_type const &":
        return _tesseract_common_python.array2_Isometry3d_front(self)

    def back(self) -> "std::array< Eigen::Isometry3d,2 >::value_type const &":
        return _tesseract_common_python.array2_Isometry3d_back(self)

    def fill(self, u: "Isometry3d") -> "void":
        return _tesseract_common_python.array2_Isometry3d_fill(self, u)
    __swig_destroy__ = _tesseract_common_python.delete_array2_Isometry3d

# Register array2_Isometry3d in _tesseract_common_python:
_tesseract_common_python.array2_Isometry3d_swigregister(array2_Isometry3d)

class array2_double(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.array2_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.array2_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.array2_double___bool__(self)

    def __len__(self) -> "std::array< double,2 >::size_type":
        return _tesseract_common_python.array2_double___len__(self)

    def __getslice__(self, i: "std::array< double,2 >::difference_type", j: "std::array< double,2 >::difference_type") -> "std::array< double,2 > *":
        return _tesseract_common_python.array2_double___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.array2_double___setslice__(self, *args)

    def __delslice__(self, i: "std::array< double,2 >::difference_type", j: "std::array< double,2 >::difference_type") -> "void":
        return _tesseract_common_python.array2_double___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_double___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::array< double,2 >::value_type const &":
        return _tesseract_common_python.array2_double___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.array2_double___setitem__(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.array2_double_swiginit(self, _tesseract_common_python.new_array2_double(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.array2_double_empty(self)

    def size(self) -> "std::array< double,2 >::size_type":
        return _tesseract_common_python.array2_double_size(self)

    def swap(self, v: "array2_double") -> "void":
        return _tesseract_common_python.array2_double_swap(self, v)

    def begin(self) -> "std::array< double,2 >::iterator":
        return _tesseract_common_python.array2_double_begin(self)

    def end(self) -> "std::array< double,2 >::iterator":
        return _tesseract_common_python.array2_double_end(self)

    def rbegin(self) -> "std::array< double,2 >::reverse_iterator":
        return _tesseract_common_python.array2_double_rbegin(self)

    def rend(self) -> "std::array< double,2 >::reverse_iterator":
        return _tesseract_common_python.array2_double_rend(self)

    def front(self) -> "std::array< double,2 >::value_type const &":
        return _tesseract_common_python.array2_double_front(self)

    def back(self) -> "std::array< double,2 >::value_type const &":
        return _tesseract_common_python.array2_double_back(self)

    def fill(self, u: "std::array< double,2 >::value_type const &") -> "void":
        return _tesseract_common_python.array2_double_fill(self, u)
    __swig_destroy__ = _tesseract_common_python.delete_array2_double

# Register array2_double in _tesseract_common_python:
_tesseract_common_python.array2_double_swigregister(array2_double)

class VectorIsometry3d(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.VectorIsometry3d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.VectorIsometry3d___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.VectorIsometry3d___bool__(self)

    def __len__(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::size_type":
        return _tesseract_common_python.VectorIsometry3d___len__(self)

    def __getslice__(self, i: "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::difference_type", j: "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::difference_type") -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > > *":
        return _tesseract_common_python.VectorIsometry3d___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.VectorIsometry3d___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::difference_type", j: "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::difference_type") -> "void":
        return _tesseract_common_python.VectorIsometry3d___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorIsometry3d___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::value_type const &":
        return _tesseract_common_python.VectorIsometry3d___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorIsometry3d___setitem__(self, *args)

    def pop(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::value_type":
        return _tesseract_common_python.VectorIsometry3d_pop(self)

    def append(self, x: "Isometry3d") -> "void":
        return _tesseract_common_python.VectorIsometry3d_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.VectorIsometry3d_empty(self)

    def size(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::size_type":
        return _tesseract_common_python.VectorIsometry3d_size(self)

    def swap(self, v: "VectorIsometry3d") -> "void":
        return _tesseract_common_python.VectorIsometry3d_swap(self, v)

    def begin(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::iterator":
        return _tesseract_common_python.VectorIsometry3d_begin(self)

    def end(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::iterator":
        return _tesseract_common_python.VectorIsometry3d_end(self)

    def rbegin(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::reverse_iterator":
        return _tesseract_common_python.VectorIsometry3d_rbegin(self)

    def rend(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::reverse_iterator":
        return _tesseract_common_python.VectorIsometry3d_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.VectorIsometry3d_clear(self)

    def get_allocator(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::allocator_type":
        return _tesseract_common_python.VectorIsometry3d_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.VectorIsometry3d_pop_back(self)

    def erase(self, *args) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::iterator":
        return _tesseract_common_python.VectorIsometry3d_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.VectorIsometry3d_swiginit(self, _tesseract_common_python.new_VectorIsometry3d(*args))

    def push_back(self, x: "Isometry3d") -> "void":
        return _tesseract_common_python.VectorIsometry3d_push_back(self, x)

    def front(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::value_type const &":
        return _tesseract_common_python.VectorIsometry3d_front(self)

    def back(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::value_type const &":
        return _tesseract_common_python.VectorIsometry3d_back(self)

    def assign(self, n: "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::size_type", x: "Isometry3d") -> "void":
        return _tesseract_common_python.VectorIsometry3d_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.VectorIsometry3d_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.VectorIsometry3d_insert(self, *args)

    def reserve(self, n: "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::size_type") -> "void":
        return _tesseract_common_python.VectorIsometry3d_reserve(self, n)

    def capacity(self) -> "std::vector< Eigen::Isometry3d,Eigen::aligned_allocator< Eigen::Isometry3d > >::size_type":
        return _tesseract_common_python.VectorIsometry3d_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_VectorIsometry3d

# Register VectorIsometry3d in _tesseract_common_python:
_tesseract_common_python.VectorIsometry3d_swigregister(VectorIsometry3d)

class VectorVector3d(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.VectorVector3d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.VectorVector3d___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.VectorVector3d___bool__(self)

    def __len__(self) -> "std::vector< Eigen::Vector3d >::size_type":
        return _tesseract_common_python.VectorVector3d___len__(self)

    def __getslice__(self, i: "std::vector< Eigen::Vector3d >::difference_type", j: "std::vector< Eigen::Vector3d >::difference_type") -> "std::vector< Eigen::Vector3d,std::allocator< Eigen::Vector3d > > *":
        return _tesseract_common_python.VectorVector3d___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector3d___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Eigen::Vector3d >::difference_type", j: "std::vector< Eigen::Vector3d >::difference_type") -> "void":
        return _tesseract_common_python.VectorVector3d___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector3d___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Eigen::Vector3d >::value_type const &":
        return _tesseract_common_python.VectorVector3d___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector3d___setitem__(self, *args)

    def pop(self) -> "std::vector< Eigen::Vector3d >::value_type":
        return _tesseract_common_python.VectorVector3d_pop(self)

    def append(self, x: "std::vector< Eigen::Vector3d >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector3d_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.VectorVector3d_empty(self)

    def size(self) -> "std::vector< Eigen::Vector3d >::size_type":
        return _tesseract_common_python.VectorVector3d_size(self)

    def swap(self, v: "std::vector< Eigen::Vector3d > &") -> "void":
        return _tesseract_common_python.VectorVector3d_swap(self, v)

    def begin(self) -> "std::vector< Eigen::Vector3d >::iterator":
        return _tesseract_common_python.VectorVector3d_begin(self)

    def end(self) -> "std::vector< Eigen::Vector3d >::iterator":
        return _tesseract_common_python.VectorVector3d_end(self)

    def rbegin(self) -> "std::vector< Eigen::Vector3d >::reverse_iterator":
        return _tesseract_common_python.VectorVector3d_rbegin(self)

    def rend(self) -> "std::vector< Eigen::Vector3d >::reverse_iterator":
        return _tesseract_common_python.VectorVector3d_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.VectorVector3d_clear(self)

    def get_allocator(self) -> "std::vector< Eigen::Vector3d >::allocator_type":
        return _tesseract_common_python.VectorVector3d_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.VectorVector3d_pop_back(self)

    def erase(self, *args) -> "std::vector< Eigen::Vector3d >::iterator":
        return _tesseract_common_python.VectorVector3d_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.VectorVector3d_swiginit(self, _tesseract_common_python.new_VectorVector3d(*args))

    def push_back(self, x: "std::vector< Eigen::Vector3d >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector3d_push_back(self, x)

    def front(self) -> "std::vector< Eigen::Vector3d >::value_type const &":
        return _tesseract_common_python.VectorVector3d_front(self)

    def back(self) -> "std::vector< Eigen::Vector3d >::value_type const &":
        return _tesseract_common_python.VectorVector3d_back(self)

    def assign(self, n: "std::vector< Eigen::Vector3d >::size_type", x: "std::vector< Eigen::Vector3d >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector3d_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.VectorVector3d_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.VectorVector3d_insert(self, *args)

    def reserve(self, n: "std::vector< Eigen::Vector3d >::size_type") -> "void":
        return _tesseract_common_python.VectorVector3d_reserve(self, n)

    def capacity(self) -> "std::vector< Eigen::Vector3d >::size_type":
        return _tesseract_common_python.VectorVector3d_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_VectorVector3d

# Register VectorVector3d in _tesseract_common_python:
_tesseract_common_python.VectorVector3d_swigregister(VectorVector3d)

class VectorVectorXd(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.VectorVectorXd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.VectorVectorXd___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.VectorVectorXd___bool__(self)

    def __len__(self) -> "std::vector< Eigen::VectorXd >::size_type":
        return _tesseract_common_python.VectorVectorXd___len__(self)

    def __getslice__(self, i: "std::vector< Eigen::VectorXd >::difference_type", j: "std::vector< Eigen::VectorXd >::difference_type") -> "std::vector< Eigen::VectorXd,std::allocator< Eigen::VectorXd > > *":
        return _tesseract_common_python.VectorVectorXd___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.VectorVectorXd___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Eigen::VectorXd >::difference_type", j: "std::vector< Eigen::VectorXd >::difference_type") -> "void":
        return _tesseract_common_python.VectorVectorXd___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVectorXd___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Eigen::VectorXd >::value_type const &":
        return _tesseract_common_python.VectorVectorXd___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVectorXd___setitem__(self, *args)

    def pop(self) -> "std::vector< Eigen::VectorXd >::value_type":
        return _tesseract_common_python.VectorVectorXd_pop(self)

    def append(self, x: "std::vector< Eigen::VectorXd >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVectorXd_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.VectorVectorXd_empty(self)

    def size(self) -> "std::vector< Eigen::VectorXd >::size_type":
        return _tesseract_common_python.VectorVectorXd_size(self)

    def swap(self, v: "std::vector< Eigen::VectorXd > &") -> "void":
        return _tesseract_common_python.VectorVectorXd_swap(self, v)

    def begin(self) -> "std::vector< Eigen::VectorXd >::iterator":
        return _tesseract_common_python.VectorVectorXd_begin(self)

    def end(self) -> "std::vector< Eigen::VectorXd >::iterator":
        return _tesseract_common_python.VectorVectorXd_end(self)

    def rbegin(self) -> "std::vector< Eigen::VectorXd >::reverse_iterator":
        return _tesseract_common_python.VectorVectorXd_rbegin(self)

    def rend(self) -> "std::vector< Eigen::VectorXd >::reverse_iterator":
        return _tesseract_common_python.VectorVectorXd_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.VectorVectorXd_clear(self)

    def get_allocator(self) -> "std::vector< Eigen::VectorXd >::allocator_type":
        return _tesseract_common_python.VectorVectorXd_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.VectorVectorXd_pop_back(self)

    def erase(self, *args) -> "std::vector< Eigen::VectorXd >::iterator":
        return _tesseract_common_python.VectorVectorXd_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.VectorVectorXd_swiginit(self, _tesseract_common_python.new_VectorVectorXd(*args))

    def push_back(self, x: "std::vector< Eigen::VectorXd >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVectorXd_push_back(self, x)

    def front(self) -> "std::vector< Eigen::VectorXd >::value_type const &":
        return _tesseract_common_python.VectorVectorXd_front(self)

    def back(self) -> "std::vector< Eigen::VectorXd >::value_type const &":
        return _tesseract_common_python.VectorVectorXd_back(self)

    def assign(self, n: "std::vector< Eigen::VectorXd >::size_type", x: "std::vector< Eigen::VectorXd >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVectorXd_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.VectorVectorXd_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.VectorVectorXd_insert(self, *args)

    def reserve(self, n: "std::vector< Eigen::VectorXd >::size_type") -> "void":
        return _tesseract_common_python.VectorVectorXd_reserve(self, n)

    def capacity(self) -> "std::vector< Eigen::VectorXd >::size_type":
        return _tesseract_common_python.VectorVectorXd_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_VectorVectorXd

# Register VectorVectorXd in _tesseract_common_python:
_tesseract_common_python.VectorVectorXd_swigregister(VectorVectorXd)

class VectorVector2d(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.VectorVector2d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.VectorVector2d___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.VectorVector2d___bool__(self)

    def __len__(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::size_type":
        return _tesseract_common_python.VectorVector2d___len__(self)

    def __getslice__(self, i: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::difference_type", j: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::difference_type") -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > > *":
        return _tesseract_common_python.VectorVector2d___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector2d___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::difference_type", j: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::difference_type") -> "void":
        return _tesseract_common_python.VectorVector2d___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector2d___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::value_type const &":
        return _tesseract_common_python.VectorVector2d___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector2d___setitem__(self, *args)

    def pop(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::value_type":
        return _tesseract_common_python.VectorVector2d_pop(self)

    def append(self, x: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector2d_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.VectorVector2d_empty(self)

    def size(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::size_type":
        return _tesseract_common_python.VectorVector2d_size(self)

    def swap(self, v: "VectorVector2d") -> "void":
        return _tesseract_common_python.VectorVector2d_swap(self, v)

    def begin(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::iterator":
        return _tesseract_common_python.VectorVector2d_begin(self)

    def end(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::iterator":
        return _tesseract_common_python.VectorVector2d_end(self)

    def rbegin(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::reverse_iterator":
        return _tesseract_common_python.VectorVector2d_rbegin(self)

    def rend(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::reverse_iterator":
        return _tesseract_common_python.VectorVector2d_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.VectorVector2d_clear(self)

    def get_allocator(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::allocator_type":
        return _tesseract_common_python.VectorVector2d_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.VectorVector2d_pop_back(self)

    def erase(self, *args) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::iterator":
        return _tesseract_common_python.VectorVector2d_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.VectorVector2d_swiginit(self, _tesseract_common_python.new_VectorVector2d(*args))

    def push_back(self, x: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector2d_push_back(self, x)

    def front(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::value_type const &":
        return _tesseract_common_python.VectorVector2d_front(self)

    def back(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::value_type const &":
        return _tesseract_common_python.VectorVector2d_back(self)

    def assign(self, n: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::size_type", x: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector2d_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.VectorVector2d_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.VectorVector2d_insert(self, *args)

    def reserve(self, n: "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::size_type") -> "void":
        return _tesseract_common_python.VectorVector2d_reserve(self, n)

    def capacity(self) -> "std::vector< Eigen::Vector2d,Eigen::aligned_allocator< Eigen::Vector2d > >::size_type":
        return _tesseract_common_python.VectorVector2d_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_VectorVector2d

# Register VectorVector2d in _tesseract_common_python:
_tesseract_common_python.VectorVector2d_swigregister(VectorVector2d)

class VectorVector4d(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.VectorVector4d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.VectorVector4d___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.VectorVector4d___bool__(self)

    def __len__(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::size_type":
        return _tesseract_common_python.VectorVector4d___len__(self)

    def __getslice__(self, i: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::difference_type", j: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::difference_type") -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > > *":
        return _tesseract_common_python.VectorVector4d___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector4d___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::difference_type", j: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::difference_type") -> "void":
        return _tesseract_common_python.VectorVector4d___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector4d___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::value_type const &":
        return _tesseract_common_python.VectorVector4d___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.VectorVector4d___setitem__(self, *args)

    def pop(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::value_type":
        return _tesseract_common_python.VectorVector4d_pop(self)

    def append(self, x: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector4d_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.VectorVector4d_empty(self)

    def size(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::size_type":
        return _tesseract_common_python.VectorVector4d_size(self)

    def swap(self, v: "VectorVector4d") -> "void":
        return _tesseract_common_python.VectorVector4d_swap(self, v)

    def begin(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::iterator":
        return _tesseract_common_python.VectorVector4d_begin(self)

    def end(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::iterator":
        return _tesseract_common_python.VectorVector4d_end(self)

    def rbegin(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::reverse_iterator":
        return _tesseract_common_python.VectorVector4d_rbegin(self)

    def rend(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::reverse_iterator":
        return _tesseract_common_python.VectorVector4d_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.VectorVector4d_clear(self)

    def get_allocator(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::allocator_type":
        return _tesseract_common_python.VectorVector4d_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.VectorVector4d_pop_back(self)

    def erase(self, *args) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::iterator":
        return _tesseract_common_python.VectorVector4d_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.VectorVector4d_swiginit(self, _tesseract_common_python.new_VectorVector4d(*args))

    def push_back(self, x: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector4d_push_back(self, x)

    def front(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::value_type const &":
        return _tesseract_common_python.VectorVector4d_front(self)

    def back(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::value_type const &":
        return _tesseract_common_python.VectorVector4d_back(self)

    def assign(self, n: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::size_type", x: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::value_type const &") -> "void":
        return _tesseract_common_python.VectorVector4d_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.VectorVector4d_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.VectorVector4d_insert(self, *args)

    def reserve(self, n: "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::size_type") -> "void":
        return _tesseract_common_python.VectorVector4d_reserve(self, n)

    def capacity(self) -> "std::vector< Eigen::Vector4d,Eigen::aligned_allocator< Eigen::Vector4d > >::size_type":
        return _tesseract_common_python.VectorVector4d_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_VectorVector4d

# Register VectorVector4d in _tesseract_common_python:
_tesseract_common_python.VectorVector4d_swigregister(VectorVector4d)

class TransformMap(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.TransformMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.TransformMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.TransformMap___bool__(self)

    def __len__(self) -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::size_type":
        return _tesseract_common_python.TransformMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::mapped_type const &":
        return _tesseract_common_python.TransformMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "void":
        return _tesseract_common_python.TransformMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "bool":
        return _tesseract_common_python.TransformMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.TransformMap_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.TransformMap_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.TransformMap_items(self)

    def __contains__(self, key: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "bool":
        return _tesseract_common_python.TransformMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.TransformMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.TransformMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.TransformMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.TransformMap_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.TransformMap_swiginit(self, _tesseract_common_python.new_TransformMap(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.TransformMap_empty(self)

    def size(self) -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::size_type":
        return _tesseract_common_python.TransformMap_size(self)

    def swap(self, v: "TransformMap") -> "void":
        return _tesseract_common_python.TransformMap_swap(self, v)

    def begin(self) -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::iterator":
        return _tesseract_common_python.TransformMap_begin(self)

    def end(self) -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::iterator":
        return _tesseract_common_python.TransformMap_end(self)

    def rbegin(self) -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::reverse_iterator":
        return _tesseract_common_python.TransformMap_rbegin(self)

    def rend(self) -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::reverse_iterator":
        return _tesseract_common_python.TransformMap_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.TransformMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::allocator_type":
        return _tesseract_common_python.TransformMap_get_allocator(self)

    def count(self, x: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::size_type":
        return _tesseract_common_python.TransformMap_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.TransformMap_erase(self, *args)

    def find(self, x: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::iterator":
        return _tesseract_common_python.TransformMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::iterator":
        return _tesseract_common_python.TransformMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::key_type const &") -> "std::map< std::string,Eigen::Isometry3d,std::less< std::string >,Eigen::aligned_allocator< std::pair< std::string const,Eigen::Isometry3d > > >::iterator":
        return _tesseract_common_python.TransformMap_upper_bound(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_TransformMap

# Register TransformMap in _tesseract_common_python:
_tesseract_common_python.TransformMap_swigregister(TransformMap)

class type_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def hash_code(self) -> "std::size_t":
        return _tesseract_common_python.type_index_hash_code(self)

    def name(self) -> "char const *":
        return _tesseract_common_python.type_index_name(self)
    __swig_destroy__ = _tesseract_common_python.delete_type_index

# Register type_index in _tesseract_common_python:
_tesseract_common_python.type_index_swigregister(type_index)

class SimpleResourceLocatorFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a: "std::string const &") -> "std::string":
        return _tesseract_common_python.SimpleResourceLocatorFnBase_call(self, a)
    __swig_destroy__ = _tesseract_common_python.delete_SimpleResourceLocatorFnBase

    def __init__(self):
        if self.__class__ == SimpleResourceLocatorFnBase:
            _self = None
        else:
            _self = self
        _tesseract_common_python.SimpleResourceLocatorFnBase_swiginit(self, _tesseract_common_python.new_SimpleResourceLocatorFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_common_python.disown_SimpleResourceLocatorFnBase(self)
        return weakref.proxy(self)

# Register SimpleResourceLocatorFnBase in _tesseract_common_python:
_tesseract_common_python.SimpleResourceLocatorFnBase_swigregister(SimpleResourceLocatorFnBase)



class SimpleResourceLocatorFn(SimpleResourceLocatorFnBase):
  def __init__(self,fn):
    super(SimpleResourceLocatorFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

class vector_uint8(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.vector_uint8_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.vector_uint8___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.vector_uint8___bool__(self)

    def __len__(self) -> "std::vector< unsigned char >::size_type":
        return _tesseract_common_python.vector_uint8___len__(self)

    def __getslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        return _tesseract_common_python.vector_uint8___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.vector_uint8___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "void":
        return _tesseract_common_python.vector_uint8___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_uint8___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        return _tesseract_common_python.vector_uint8___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.vector_uint8___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned char >::value_type":
        return _tesseract_common_python.vector_uint8_pop(self)

    def append(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _tesseract_common_python.vector_uint8_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.vector_uint8_empty(self)

    def size(self) -> "std::vector< unsigned char >::size_type":
        return _tesseract_common_python.vector_uint8_size(self)

    def swap(self, v: "vector_uint8") -> "void":
        return _tesseract_common_python.vector_uint8_swap(self, v)

    def begin(self) -> "std::vector< unsigned char >::iterator":
        return _tesseract_common_python.vector_uint8_begin(self)

    def end(self) -> "std::vector< unsigned char >::iterator":
        return _tesseract_common_python.vector_uint8_end(self)

    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _tesseract_common_python.vector_uint8_rbegin(self)

    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _tesseract_common_python.vector_uint8_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.vector_uint8_clear(self)

    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        return _tesseract_common_python.vector_uint8_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.vector_uint8_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        return _tesseract_common_python.vector_uint8_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.vector_uint8_swiginit(self, _tesseract_common_python.new_vector_uint8(*args))

    def push_back(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _tesseract_common_python.vector_uint8_push_back(self, x)

    def front(self) -> "std::vector< unsigned char >::value_type const &":
        return _tesseract_common_python.vector_uint8_front(self)

    def back(self) -> "std::vector< unsigned char >::value_type const &":
        return _tesseract_common_python.vector_uint8_back(self)

    def assign(self, n: "std::vector< unsigned char >::size_type", x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _tesseract_common_python.vector_uint8_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.vector_uint8_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.vector_uint8_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned char >::size_type") -> "void":
        return _tesseract_common_python.vector_uint8_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned char >::size_type":
        return _tesseract_common_python.vector_uint8_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_vector_uint8

# Register vector_uint8 in _tesseract_common_python:
_tesseract_common_python.vector_uint8_swigregister(vector_uint8)

class PairHash(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __call__(self, pair: "pair_string") -> "std::size_t":
        return _tesseract_common_python.PairHash___call__(self, pair)

    def __init__(self):
        _tesseract_common_python.PairHash_swiginit(self, _tesseract_common_python.new_PairHash())
    __swig_destroy__ = _tesseract_common_python.delete_PairHash

# Register PairHash in _tesseract_common_python:
_tesseract_common_python.PairHash_swigregister(PairHash)


def makeOrderedLinkPair(link_name1: "std::string const &", link_name2: "std::string const &") -> "tesseract_common::LinkNamesPair":
    r"""
    Create a pair of strings, where the pair.first is always <= pair.second.

    This is commonly used along with PairHash as the key to an unordered_map<LinkNamesPair, Type, PairHash>
    :type link_name1: string
    :param link_name1: First link name
    :type link_name2: string
    :param link_name2: Second link name
    :rtype: :py:class:`LinkNamesPair`
    :return: LinkNamesPair a lexicographically sorted pair of strings
    """
    return _tesseract_common_python.makeOrderedLinkPair(link_name1, link_name2)
class PluginInfo(object, metaclass=_SwigNonDynamicMeta):
    r""" The Plugin Information struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    class_name = property(_tesseract_common_python.PluginInfo_class_name_get, _tesseract_common_python.PluginInfo_class_name_set, doc=r""" The plugin class name""")
    config = property(_tesseract_common_python.PluginInfo_config_get, _tesseract_common_python.PluginInfo_config_set, doc=r""" The plugin config data""")

    def getConfigString(self) -> "std::string":
        r""" Get the yaml config as a string"""
        return _tesseract_common_python.PluginInfo_getConfigString(self)

    def __eq__(self, rhs: "PluginInfo") -> "bool":
        return _tesseract_common_python.PluginInfo___eq__(self, rhs)

    def __ne__(self, rhs: "PluginInfo") -> "bool":
        return _tesseract_common_python.PluginInfo___ne__(self, rhs)

    def __init__(self):
        _tesseract_common_python.PluginInfo_swiginit(self, _tesseract_common_python.new_PluginInfo())
    __swig_destroy__ = _tesseract_common_python.delete_PluginInfo

# Register PluginInfo in _tesseract_common_python:
_tesseract_common_python.PluginInfo_swigregister(PluginInfo)

class PluginInfoContainer(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    default_plugin = property(_tesseract_common_python.PluginInfoContainer_default_plugin_get, _tesseract_common_python.PluginInfoContainer_default_plugin_set)
    plugins = property(_tesseract_common_python.PluginInfoContainer_plugins_get, _tesseract_common_python.PluginInfoContainer_plugins_set)

    def clear(self) -> "void":
        return _tesseract_common_python.PluginInfoContainer_clear(self)

    def __eq__(self, rhs: "PluginInfoContainer") -> "bool":
        return _tesseract_common_python.PluginInfoContainer___eq__(self, rhs)

    def __ne__(self, rhs: "PluginInfoContainer") -> "bool":
        return _tesseract_common_python.PluginInfoContainer___ne__(self, rhs)

    def __init__(self):
        _tesseract_common_python.PluginInfoContainer_swiginit(self, _tesseract_common_python.new_PluginInfoContainer())
    __swig_destroy__ = _tesseract_common_python.delete_PluginInfoContainer

# Register PluginInfoContainer in _tesseract_common_python:
_tesseract_common_python.PluginInfoContainer_swigregister(PluginInfoContainer)

class KinematicsPluginInfo(object, metaclass=_SwigNonDynamicMeta):
    r""" The kinematics plugin information structure"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    search_paths = property(_tesseract_common_python.KinematicsPluginInfo_search_paths_get, _tesseract_common_python.KinematicsPluginInfo_search_paths_set, doc=r""" A list of paths to search for plugins""")
    search_libraries = property(_tesseract_common_python.KinematicsPluginInfo_search_libraries_get, _tesseract_common_python.KinematicsPluginInfo_search_libraries_set, doc=r""" A list of library names without the prefix or suffix that contain plugins""")
    fwd_plugin_infos = property(_tesseract_common_python.KinematicsPluginInfo_fwd_plugin_infos_get, _tesseract_common_python.KinematicsPluginInfo_fwd_plugin_infos_set, doc=r""" A map of group name to forward kinematics plugin information""")
    inv_plugin_infos = property(_tesseract_common_python.KinematicsPluginInfo_inv_plugin_infos_get, _tesseract_common_python.KinematicsPluginInfo_inv_plugin_infos_set, doc=r""" A map of group name to inverse kinematics plugin information""")

    def insert(self, other: "KinematicsPluginInfo") -> "void":
        r""" Insert the content of an other KinematicsPluginInfo"""
        return _tesseract_common_python.KinematicsPluginInfo_insert(self, other)

    def clear(self) -> "void":
        r""" Clear the contents"""
        return _tesseract_common_python.KinematicsPluginInfo_clear(self)

    def empty(self) -> "bool":
        r""" Check if structure is empty"""
        return _tesseract_common_python.KinematicsPluginInfo_empty(self)

    def __eq__(self, rhs: "KinematicsPluginInfo") -> "bool":
        return _tesseract_common_python.KinematicsPluginInfo___eq__(self, rhs)

    def __ne__(self, rhs: "KinematicsPluginInfo") -> "bool":
        return _tesseract_common_python.KinematicsPluginInfo___ne__(self, rhs)

    def __init__(self):
        _tesseract_common_python.KinematicsPluginInfo_swiginit(self, _tesseract_common_python.new_KinematicsPluginInfo())
    __swig_destroy__ = _tesseract_common_python.delete_KinematicsPluginInfo

# Register KinematicsPluginInfo in _tesseract_common_python:
_tesseract_common_python.KinematicsPluginInfo_swigregister(KinematicsPluginInfo)

class ContactManagersPluginInfo(object, metaclass=_SwigNonDynamicMeta):
    r""" The contact managers plugin information structure"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    search_paths = property(_tesseract_common_python.ContactManagersPluginInfo_search_paths_get, _tesseract_common_python.ContactManagersPluginInfo_search_paths_set, doc=r""" A list of paths to search for plugins""")
    search_libraries = property(_tesseract_common_python.ContactManagersPluginInfo_search_libraries_get, _tesseract_common_python.ContactManagersPluginInfo_search_libraries_set, doc=r""" A list of library names without the prefix or suffix that contain plugins""")
    discrete_plugin_infos = property(_tesseract_common_python.ContactManagersPluginInfo_discrete_plugin_infos_get, _tesseract_common_python.ContactManagersPluginInfo_discrete_plugin_infos_set, doc=r""" A map of name to discrete contact manager plugin information""")
    continuous_plugin_infos = property(_tesseract_common_python.ContactManagersPluginInfo_continuous_plugin_infos_get, _tesseract_common_python.ContactManagersPluginInfo_continuous_plugin_infos_set, doc=r""" A map of name to continuous contact manager plugin information""")

    def insert(self, other: "ContactManagersPluginInfo") -> "void":
        r""" Insert the content of an other ContactManagersPluginInfo"""
        return _tesseract_common_python.ContactManagersPluginInfo_insert(self, other)

    def clear(self) -> "void":
        r""" Clear the contents"""
        return _tesseract_common_python.ContactManagersPluginInfo_clear(self)

    def empty(self) -> "bool":
        r""" Check if structure is empty"""
        return _tesseract_common_python.ContactManagersPluginInfo_empty(self)

    def __eq__(self, rhs: "ContactManagersPluginInfo") -> "bool":
        return _tesseract_common_python.ContactManagersPluginInfo___eq__(self, rhs)

    def __ne__(self, rhs: "ContactManagersPluginInfo") -> "bool":
        return _tesseract_common_python.ContactManagersPluginInfo___ne__(self, rhs)

    def __init__(self):
        _tesseract_common_python.ContactManagersPluginInfo_swiginit(self, _tesseract_common_python.new_ContactManagersPluginInfo())
    __swig_destroy__ = _tesseract_common_python.delete_ContactManagersPluginInfo

# Register ContactManagersPluginInfo in _tesseract_common_python:
_tesseract_common_python.ContactManagersPluginInfo_swigregister(ContactManagersPluginInfo)

class CalibrationInfo(object, metaclass=_SwigNonDynamicMeta):
    r""" The CalibrationInfo struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        _tesseract_common_python.CalibrationInfo_swiginit(self, _tesseract_common_python.new_CalibrationInfo())
    joints = property(_tesseract_common_python.CalibrationInfo_joints_get, _tesseract_common_python.CalibrationInfo_joints_set, doc=r"""
     The joint origin calibration information
     For each entry in ``joints`` the environment will apply a ChangeJointOriginCommand replacing the current
    joint origin with what is stored in the TransformMap
    """)

    def insert(self, other: "CalibrationInfo") -> "void":
        r""" Insert the content of an other CalibrationInfo"""
        return _tesseract_common_python.CalibrationInfo_insert(self, other)

    def clear(self) -> "void":
        r""" Clear the contents"""
        return _tesseract_common_python.CalibrationInfo_clear(self)

    def empty(self) -> "bool":
        r""" Check if structure is empty"""
        return _tesseract_common_python.CalibrationInfo_empty(self)

    def __eq__(self, rhs: "CalibrationInfo") -> "bool":
        return _tesseract_common_python.CalibrationInfo___eq__(self, rhs)

    def __ne__(self, rhs: "CalibrationInfo") -> "bool":
        return _tesseract_common_python.CalibrationInfo___ne__(self, rhs)
    __swig_destroy__ = _tesseract_common_python.delete_CalibrationInfo

# Register CalibrationInfo in _tesseract_common_python:
_tesseract_common_python.CalibrationInfo_swigregister(CalibrationInfo)

class AllowedCollisionEntries(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.AllowedCollisionEntries_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.AllowedCollisionEntries___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.AllowedCollisionEntries___bool__(self)

    def __len__(self) -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::size_type":
        return _tesseract_common_python.AllowedCollisionEntries___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "pair_string") -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::mapped_type const &":
        return _tesseract_common_python.AllowedCollisionEntries___getitem__(self, key)

    def __delitem__(self, key: "pair_string") -> "void":
        return _tesseract_common_python.AllowedCollisionEntries___delitem__(self, key)

    def has_key(self, key: "pair_string") -> "bool":
        return _tesseract_common_python.AllowedCollisionEntries_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.AllowedCollisionEntries_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.AllowedCollisionEntries_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.AllowedCollisionEntries_items(self)

    def __contains__(self, key: "pair_string") -> "bool":
        return _tesseract_common_python.AllowedCollisionEntries___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.AllowedCollisionEntries_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.AllowedCollisionEntries_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.AllowedCollisionEntries___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.AllowedCollisionEntries_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.AllowedCollisionEntries_swiginit(self, _tesseract_common_python.new_AllowedCollisionEntries(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.AllowedCollisionEntries_empty(self)

    def size(self) -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::size_type":
        return _tesseract_common_python.AllowedCollisionEntries_size(self)

    def swap(self, v: "AllowedCollisionEntries") -> "void":
        return _tesseract_common_python.AllowedCollisionEntries_swap(self, v)

    def begin(self) -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::iterator":
        return _tesseract_common_python.AllowedCollisionEntries_begin(self)

    def end(self) -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::iterator":
        return _tesseract_common_python.AllowedCollisionEntries_end(self)

    def clear(self) -> "void":
        return _tesseract_common_python.AllowedCollisionEntries_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::allocator_type":
        return _tesseract_common_python.AllowedCollisionEntries_get_allocator(self)

    def count(self, x: "pair_string") -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::size_type":
        return _tesseract_common_python.AllowedCollisionEntries_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.AllowedCollisionEntries_erase(self, *args)

    def find(self, x: "pair_string") -> "std::unordered_map< std::pair< std::string,std::string >,std::string,tesseract_common::PairHash >::iterator":
        return _tesseract_common_python.AllowedCollisionEntries_find(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_AllowedCollisionEntries

# Register AllowedCollisionEntries in _tesseract_common_python:
_tesseract_common_python.AllowedCollisionEntries_swigregister(AllowedCollisionEntries)

class PluginInfoMap(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.PluginInfoMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.PluginInfoMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.PluginInfoMap___bool__(self)

    def __len__(self) -> "std::map< std::string,tesseract_common::PluginInfo >::size_type":
        return _tesseract_common_python.PluginInfoMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "std::map< std::string,tesseract_common::PluginInfo >::mapped_type const &":
        return _tesseract_common_python.PluginInfoMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "void":
        return _tesseract_common_python.PluginInfoMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "bool":
        return _tesseract_common_python.PluginInfoMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_common_python.PluginInfoMap_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_common_python.PluginInfoMap_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_common_python.PluginInfoMap_items(self)

    def __contains__(self, key: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "bool":
        return _tesseract_common_python.PluginInfoMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.PluginInfoMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.PluginInfoMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.PluginInfoMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_common_python.PluginInfoMap_asdict(self)

    def __init__(self, *args):
        _tesseract_common_python.PluginInfoMap_swiginit(self, _tesseract_common_python.new_PluginInfoMap(*args))

    def empty(self) -> "bool":
        return _tesseract_common_python.PluginInfoMap_empty(self)

    def size(self) -> "std::map< std::string,tesseract_common::PluginInfo >::size_type":
        return _tesseract_common_python.PluginInfoMap_size(self)

    def swap(self, v: "PluginInfoMap") -> "void":
        return _tesseract_common_python.PluginInfoMap_swap(self, v)

    def begin(self) -> "std::map< std::string,tesseract_common::PluginInfo >::iterator":
        return _tesseract_common_python.PluginInfoMap_begin(self)

    def end(self) -> "std::map< std::string,tesseract_common::PluginInfo >::iterator":
        return _tesseract_common_python.PluginInfoMap_end(self)

    def rbegin(self) -> "std::map< std::string,tesseract_common::PluginInfo >::reverse_iterator":
        return _tesseract_common_python.PluginInfoMap_rbegin(self)

    def rend(self) -> "std::map< std::string,tesseract_common::PluginInfo >::reverse_iterator":
        return _tesseract_common_python.PluginInfoMap_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.PluginInfoMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,tesseract_common::PluginInfo >::allocator_type":
        return _tesseract_common_python.PluginInfoMap_get_allocator(self)

    def count(self, x: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "std::map< std::string,tesseract_common::PluginInfo >::size_type":
        return _tesseract_common_python.PluginInfoMap_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_common_python.PluginInfoMap_erase(self, *args)

    def find(self, x: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "std::map< std::string,tesseract_common::PluginInfo >::iterator":
        return _tesseract_common_python.PluginInfoMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "std::map< std::string,tesseract_common::PluginInfo >::iterator":
        return _tesseract_common_python.PluginInfoMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,tesseract_common::PluginInfo >::key_type const &") -> "std::map< std::string,tesseract_common::PluginInfo >::iterator":
        return _tesseract_common_python.PluginInfoMap_upper_bound(self, x)
    __swig_destroy__ = _tesseract_common_python.delete_PluginInfoMap

# Register PluginInfoMap in _tesseract_common_python:
_tesseract_common_python.PluginInfoMap_swigregister(PluginInfoMap)

class StatusCategory(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_StatusCategory

    def name(self) -> "std::string const &":
        return _tesseract_common_python.StatusCategory_name(self)

    def message(self, code: "int") -> "std::string":
        return _tesseract_common_python.StatusCategory_message(self, code)

    def __eq__(self, rhs: "StatusCategory") -> "bool":
        return _tesseract_common_python.StatusCategory___eq__(self, rhs)

    def __ne__(self, rhs: "StatusCategory") -> "bool":
        return _tesseract_common_python.StatusCategory___ne__(self, rhs)

# Register StatusCategory in _tesseract_common_python:
_tesseract_common_python.StatusCategory_swigregister(StatusCategory)

class GeneralStatusCategory(StatusCategory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.GeneralStatusCategory_swiginit(self, _tesseract_common_python.new_GeneralStatusCategory(*args))

    def name(self) -> "std::string const &":
        return _tesseract_common_python.GeneralStatusCategory_name(self)

    def message(self, code: "int") -> "std::string":
        return _tesseract_common_python.GeneralStatusCategory_message(self, code)
    IsConfigured = _tesseract_common_python.GeneralStatusCategory_IsConfigured
    Success = _tesseract_common_python.GeneralStatusCategory_Success
    Failure = _tesseract_common_python.GeneralStatusCategory_Failure
    IsNotConfigured = _tesseract_common_python.GeneralStatusCategory_IsNotConfigured
    __swig_destroy__ = _tesseract_common_python.delete_GeneralStatusCategory

# Register GeneralStatusCategory in _tesseract_common_python:
_tesseract_common_python.GeneralStatusCategory_swigregister(GeneralStatusCategory)

class StatusCode(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_StatusCode

    def __init__(self, *args):
        _tesseract_common_python.StatusCode_swiginit(self, _tesseract_common_python.new_StatusCode(*args))

    def value(self) -> "int":
        return _tesseract_common_python.StatusCode_value(self)

    def category(self) -> "tesseract_common::StatusCategory::ConstPtr const &":
        return _tesseract_common_python.StatusCode_category(self)

    def message(self) -> "std::string":
        return _tesseract_common_python.StatusCode_message(self)

    def setChild(self, child: "tesseract_common::StatusCode::ConstPtr") -> "void":
        r"""
        Set the child status code
        :type child: :py:class:`StatusCode`
        :param child: The child status code to assign
        """
        return _tesseract_common_python.StatusCode_setChild(self, child)

    def getChild(self) -> "tesseract_common::StatusCode::ConstPtr const &":
        r"""
        Get the child status code if it exist
        :rtype: :py:class:`StatusCode`
        :return: Child status code, nullptr if it does not have a child.
        """
        return _tesseract_common_python.StatusCode_getChild(self)

    def __nonzero__(self):
        return _tesseract_common_python.StatusCode___nonzero__(self)
    __bool__ = __nonzero__



    def __eq__(self, rhs: "StatusCode") -> "bool":
        return _tesseract_common_python.StatusCode___eq__(self, rhs)

    def __ne__(self, rhs: "StatusCode") -> "bool":
        return _tesseract_common_python.StatusCode___ne__(self, rhs)

# Register StatusCode in _tesseract_common_python:
_tesseract_common_python.StatusCode_swigregister(StatusCode)

class ResourceLocator(object):
    r""" Abstract class for resource loaders"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_ResourceLocator

    def locateResource(self, url: "std::string const &") -> "std::shared_ptr< tesseract_common::Resource >":
        r"""
        Locate a resource based on a URL

        :type url: string
        :param url: The URL of the resource
        :rtype: :py:class:`Resource`
        :return: A shared pointer to a Resource instance, or nullptr if not found
        """
        return _tesseract_common_python.ResourceLocator_locateResource(self, url)

    def __eq__(self, rhs: "ResourceLocator") -> "bool":
        return _tesseract_common_python.ResourceLocator___eq__(self, rhs)

    def __ne__(self, rhs: "ResourceLocator") -> "bool":
        return _tesseract_common_python.ResourceLocator___ne__(self, rhs)

    def __init__(self):
        if self.__class__ == ResourceLocator:
            _self = None
        else:
            _self = self
        _tesseract_common_python.ResourceLocator_swiginit(self, _tesseract_common_python.new_ResourceLocator(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_common_python.disown_ResourceLocator(self)
        return weakref.proxy(self)

# Register ResourceLocator in _tesseract_common_python:
_tesseract_common_python.ResourceLocator_swigregister(ResourceLocator)

class Resource(ResourceLocator):
    r"""  Represents resource data available from a file or url"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isFile(self) -> "bool":
        r"""
        Returns true if the located resource is a local file

        :rtype: boolean
        :return: true if the resource is a local file, otherwise false
        """
        return _tesseract_common_python.Resource_isFile(self)

    def getUrl(self) -> "std::string":
        r"""
        Get the original URL used to locate the file

        :rtype: string
        :return: The URL of the resource
        """
        return _tesseract_common_python.Resource_getUrl(self)

    def getFilePath(self) -> "std::string":
        r"""
        Get the file path of the resource. Only valid if isFile() is true.

        :rtype: string
        :return: The file path to the resource
        """
        return _tesseract_common_python.Resource_getFilePath(self)

    def getResourceContents(self) -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        r"""
        Get the resource as bytes. This function may block

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: Resource bytes as a uint8_t vector
        """
        return _tesseract_common_python.Resource_getResourceContents(self)

    def getResourceContentStream(self) -> "std::shared_ptr< std::istream >":
        r"""
        Get the resource as a std::istream. This function and the returned stream may block

        :rtype: std::shared_ptr< std::istream >
        :return: A std::istream shared pointer for the resource data
        """
        return _tesseract_common_python.Resource_getResourceContentStream(self)

    def __eq__(self, rhs: "Resource") -> "bool":
        return _tesseract_common_python.Resource___eq__(self, rhs)

    def __ne__(self, rhs: "Resource") -> "bool":
        return _tesseract_common_python.Resource___ne__(self, rhs)
    __swig_destroy__ = _tesseract_common_python.delete_Resource

# Register Resource in _tesseract_common_python:
_tesseract_common_python.Resource_swigregister(Resource)

class SimpleLocatedResource(Resource):
    r""" Resource implementation for a local file"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_SimpleLocatedResource

    def __init__(self, *args):
        _tesseract_common_python.SimpleLocatedResource_swiginit(self, _tesseract_common_python.new_SimpleLocatedResource(*args))

    def isFile(self) -> "bool":
        return _tesseract_common_python.SimpleLocatedResource_isFile(self)

    def getUrl(self) -> "std::string":
        return _tesseract_common_python.SimpleLocatedResource_getUrl(self)

    def getFilePath(self) -> "std::string":
        return _tesseract_common_python.SimpleLocatedResource_getFilePath(self)

    def getResourceContents(self) -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        return _tesseract_common_python.SimpleLocatedResource_getResourceContents(self)

    def getResourceContentStream(self) -> "std::shared_ptr< std::istream >":
        return _tesseract_common_python.SimpleLocatedResource_getResourceContentStream(self)

    def locateResource(self, url: "std::string const &") -> "tesseract_common::Resource::Ptr":
        return _tesseract_common_python.SimpleLocatedResource_locateResource(self, url)

    def __eq__(self, rhs: "SimpleLocatedResource") -> "bool":
        return _tesseract_common_python.SimpleLocatedResource___eq__(self, rhs)

    def __ne__(self, rhs: "SimpleLocatedResource") -> "bool":
        return _tesseract_common_python.SimpleLocatedResource___ne__(self, rhs)

# Register SimpleLocatedResource in _tesseract_common_python:
_tesseract_common_python.SimpleLocatedResource_swigregister(SimpleLocatedResource)

class BytesResource(Resource):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_BytesResource

    def __init__(self, *args):
        _tesseract_common_python.BytesResource_swiginit(self, _tesseract_common_python.new_BytesResource(*args))

    def isFile(self) -> "bool":
        return _tesseract_common_python.BytesResource_isFile(self)

    def getUrl(self) -> "std::string":
        return _tesseract_common_python.BytesResource_getUrl(self)

    def getFilePath(self) -> "std::string":
        return _tesseract_common_python.BytesResource_getFilePath(self)

    def getResourceContents(self) -> "std::vector< uint8_t,std::allocator< uint8_t > >":
        return _tesseract_common_python.BytesResource_getResourceContents(self)

    def getResourceContentStream(self) -> "std::shared_ptr< std::istream >":
        return _tesseract_common_python.BytesResource_getResourceContentStream(self)

    def locateResource(self, url: "std::string const &") -> "tesseract_common::Resource::Ptr":
        return _tesseract_common_python.BytesResource_locateResource(self, url)

    def __eq__(self, rhs: "BytesResource") -> "bool":
        return _tesseract_common_python.BytesResource___eq__(self, rhs)

    def __ne__(self, rhs: "BytesResource") -> "bool":
        return _tesseract_common_python.BytesResource___ne__(self, rhs)

# Register BytesResource in _tesseract_common_python:
_tesseract_common_python.BytesResource_swigregister(BytesResource)

class ManipulatorInfo(object, metaclass=_SwigNonDynamicMeta):
    r"""Contains information about a robot manipulator"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.ManipulatorInfo_swiginit(self, _tesseract_common_python.new_ManipulatorInfo(*args))
    manipulator = property(_tesseract_common_python.ManipulatorInfo_manipulator_get, _tesseract_common_python.ManipulatorInfo_manipulator_set, doc=r""" Name of the manipulator group""")
    working_frame = property(_tesseract_common_python.ManipulatorInfo_working_frame_get, _tesseract_common_python.ManipulatorInfo_working_frame_set, doc=r"""
    The working frame to which waypoints are relative.
    If the tcp_frame is external to manipulator then the working frame must be an active frame on the
    manipulator
    """)
    tcp_frame = property(_tesseract_common_python.ManipulatorInfo_tcp_frame_get, _tesseract_common_python.ManipulatorInfo_tcp_frame_set, doc=r"""
    The coordinate frame within to the environment to use as the reference frame for the tool center
    point (TCP) which is defined by an offset transform relative to this frame
    """)
    manipulator_ik_solver = property(_tesseract_common_python.ManipulatorInfo_manipulator_ik_solver_get, _tesseract_common_python.ManipulatorInfo_manipulator_ik_solver_set, doc=r""" (Optional) IK Solver to be used""")

    def getCombined(self, manip_info_override: "ManipulatorInfo") -> "tesseract_common::ManipulatorInfo":
        r"""
        If the provided manipulator information member is not empty it will override this and return a
        new manipulator information with the combined results
        :type manip_info_override: :py:class:`ManipulatorInfo`
        :param manip_info_override: The manipulator information to check for overrides
        :rtype: :py:class:`ManipulatorInfo`
        :return: The combined manipulator information
        """
        return _tesseract_common_python.ManipulatorInfo_getCombined(self, manip_info_override)

    def empty(self) -> "bool":
        r"""
        Check if any data is current being stored
        :rtype: boolean
        :return: True if empty otherwise false
        """
        return _tesseract_common_python.ManipulatorInfo_empty(self)

    def __eq__(self, rhs: "ManipulatorInfo") -> "bool":
        return _tesseract_common_python.ManipulatorInfo___eq__(self, rhs)

    def __ne__(self, rhs: "ManipulatorInfo") -> "bool":
        return _tesseract_common_python.ManipulatorInfo___ne__(self, rhs)

    def _setTcpOffset(self, *args) -> "void":
        return _tesseract_common_python.ManipulatorInfo__setTcpOffset(self, *args)

    def _getTcpOffsetIndex(self) -> "std::size_t":
        return _tesseract_common_python.ManipulatorInfo__getTcpOffsetIndex(self)

    def _getTcpOffsetIsometry3d(self) -> "Eigen::Isometry3d":
        return _tesseract_common_python.ManipulatorInfo__getTcpOffsetIsometry3d(self)

    def _getTcpOffsetString(self) -> "std::string":
        return _tesseract_common_python.ManipulatorInfo__getTcpOffsetString(self)

    def _getTcpOffset(self):
      if self._getTcpOffsetIndex() == 0:
        return self._getTcpOffsetString()
      else:
        return self._getTcpOffsetIsometry3d()
    tcp_offset = property(_getTcpOffset, _setTcpOffset)

    __swig_destroy__ = _tesseract_common_python.delete_ManipulatorInfo

# Register ManipulatorInfo in _tesseract_common_python:
_tesseract_common_python.ManipulatorInfo_swigregister(ManipulatorInfo)

class JointState(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.JointState_swiginit(self, _tesseract_common_python.new_JointState(*args))
    joint_names = property(_tesseract_common_python.JointState_joint_names_get, _tesseract_common_python.JointState_joint_names_set, doc=r""" The joint corresponding to the position vector.""")
    position = property(_tesseract_common_python.JointState_position_get, _tesseract_common_python.JointState_position_set, doc=r""" The joint position at the waypoint""")
    velocity = property(_tesseract_common_python.JointState_velocity_get, _tesseract_common_python.JointState_velocity_set, doc=r""" The velocity at the waypoint (optional)""")
    acceleration = property(_tesseract_common_python.JointState_acceleration_get, _tesseract_common_python.JointState_acceleration_set, doc=r""" The Acceleration at the waypoint (optional)""")
    effort = property(_tesseract_common_python.JointState_effort_get, _tesseract_common_python.JointState_effort_set, doc=r""" The Effort at the waypoint (optional)""")
    time = property(_tesseract_common_python.JointState_time_get, _tesseract_common_python.JointState_time_set, doc=r""" The Time from start at the waypoint (optional)""")

    def __eq__(self, other: "JointState") -> "bool":
        return _tesseract_common_python.JointState___eq__(self, other)

    def __ne__(self, rhs: "JointState") -> "bool":
        return _tesseract_common_python.JointState___ne__(self, rhs)
    __swig_destroy__ = _tesseract_common_python.delete_JointState

# Register JointState in _tesseract_common_python:
_tesseract_common_python.JointState_swigregister(JointState)

class JointStates(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.JointStates_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.JointStates___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.JointStates___bool__(self)

    def __len__(self) -> "std::vector< tesseract_common::JointState >::size_type":
        return _tesseract_common_python.JointStates___len__(self)

    def __getslice__(self, i: "std::vector< tesseract_common::JointState >::difference_type", j: "std::vector< tesseract_common::JointState >::difference_type") -> "std::vector< tesseract_common::JointState,std::allocator< tesseract_common::JointState > > *":
        return _tesseract_common_python.JointStates___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.JointStates___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< tesseract_common::JointState >::difference_type", j: "std::vector< tesseract_common::JointState >::difference_type") -> "void":
        return _tesseract_common_python.JointStates___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.JointStates___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< tesseract_common::JointState >::value_type const &":
        return _tesseract_common_python.JointStates___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.JointStates___setitem__(self, *args)

    def pop(self) -> "std::vector< tesseract_common::JointState >::value_type":
        return _tesseract_common_python.JointStates_pop(self)

    def append(self, x: "JointState") -> "void":
        return _tesseract_common_python.JointStates_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.JointStates_empty(self)

    def size(self) -> "std::vector< tesseract_common::JointState >::size_type":
        return _tesseract_common_python.JointStates_size(self)

    def swap(self, v: "JointStates") -> "void":
        return _tesseract_common_python.JointStates_swap(self, v)

    def begin(self) -> "std::vector< tesseract_common::JointState >::iterator":
        return _tesseract_common_python.JointStates_begin(self)

    def end(self) -> "std::vector< tesseract_common::JointState >::iterator":
        return _tesseract_common_python.JointStates_end(self)

    def rbegin(self) -> "std::vector< tesseract_common::JointState >::reverse_iterator":
        return _tesseract_common_python.JointStates_rbegin(self)

    def rend(self) -> "std::vector< tesseract_common::JointState >::reverse_iterator":
        return _tesseract_common_python.JointStates_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.JointStates_clear(self)

    def get_allocator(self) -> "std::vector< tesseract_common::JointState >::allocator_type":
        return _tesseract_common_python.JointStates_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.JointStates_pop_back(self)

    def erase(self, *args) -> "std::vector< tesseract_common::JointState >::iterator":
        return _tesseract_common_python.JointStates_erase(self, *args)

    def __init__(self, *args):
        _tesseract_common_python.JointStates_swiginit(self, _tesseract_common_python.new_JointStates(*args))

    def push_back(self, x: "JointState") -> "void":
        return _tesseract_common_python.JointStates_push_back(self, x)

    def front(self) -> "std::vector< tesseract_common::JointState >::value_type const &":
        return _tesseract_common_python.JointStates_front(self)

    def back(self) -> "std::vector< tesseract_common::JointState >::value_type const &":
        return _tesseract_common_python.JointStates_back(self)

    def assign(self, n: "std::vector< tesseract_common::JointState >::size_type", x: "JointState") -> "void":
        return _tesseract_common_python.JointStates_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_common_python.JointStates_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_common_python.JointStates_insert(self, *args)

    def reserve(self, n: "std::vector< tesseract_common::JointState >::size_type") -> "void":
        return _tesseract_common_python.JointStates_reserve(self, n)

    def capacity(self) -> "std::vector< tesseract_common::JointState >::size_type":
        return _tesseract_common_python.JointStates_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_JointStates

# Register JointStates in _tesseract_common_python:
_tesseract_common_python.JointStates_swigregister(JointStates)

class JointTrajectory(object, metaclass=_SwigNonDynamicMeta):
    r""" Represents a joint trajectory"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.JointTrajectory_swiginit(self, _tesseract_common_python.new_JointTrajectory(*args))
    states = property(_tesseract_common_python.JointTrajectory_states_get, _tesseract_common_python.JointTrajectory_states_set)
    description = property(_tesseract_common_python.JointTrajectory_description_get, _tesseract_common_python.JointTrajectory_description_set)

    def __eq__(self, other: "JointTrajectory") -> "bool":
        return _tesseract_common_python.JointTrajectory___eq__(self, other)

    def __ne__(self, rhs: "JointTrajectory") -> "bool":
        return _tesseract_common_python.JointTrajectory___ne__(self, rhs)

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_common_python.JointTrajectory_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_common_python.JointTrajectory___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_common_python.JointTrajectory___bool__(self)

    def __len__(self) -> "tesseract_common::JointTrajectory::size_type":
        return _tesseract_common_python.JointTrajectory___len__(self)

    def __getslice__(self, i: "tesseract_common::JointTrajectory::difference_type", j: "tesseract_common::JointTrajectory::difference_type") -> "tesseract_common::JointTrajectory *":
        return _tesseract_common_python.JointTrajectory___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_common_python.JointTrajectory___setslice__(self, *args)

    def __delslice__(self, i: "tesseract_common::JointTrajectory::difference_type", j: "tesseract_common::JointTrajectory::difference_type") -> "void":
        return _tesseract_common_python.JointTrajectory___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_common_python.JointTrajectory___delitem__(self, *args)

    def __getitem__(self, *args) -> "tesseract_common::JointTrajectory::value_type const &":
        return _tesseract_common_python.JointTrajectory___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_common_python.JointTrajectory___setitem__(self, *args)

    def pop(self) -> "tesseract_common::JointTrajectory::value_type":
        return _tesseract_common_python.JointTrajectory_pop(self)

    def append(self, x: "JointState") -> "void":
        return _tesseract_common_python.JointTrajectory_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_common_python.JointTrajectory_empty(self)

    def size(self) -> "tesseract_common::JointTrajectory::size_type":
        return _tesseract_common_python.JointTrajectory_size(self)

    def begin(self) -> "tesseract_common::JointTrajectory::iterator":
        return _tesseract_common_python.JointTrajectory_begin(self)

    def end(self) -> "tesseract_common::JointTrajectory::iterator":
        return _tesseract_common_python.JointTrajectory_end(self)

    def rbegin(self) -> "tesseract_common::JointTrajectory::reverse_iterator":
        return _tesseract_common_python.JointTrajectory_rbegin(self)

    def rend(self) -> "tesseract_common::JointTrajectory::reverse_iterator":
        return _tesseract_common_python.JointTrajectory_rend(self)

    def clear(self) -> "void":
        return _tesseract_common_python.JointTrajectory_clear(self)

    def pop_back(self) -> "void":
        return _tesseract_common_python.JointTrajectory_pop_back(self)

    def erase(self, *args) -> "tesseract_common::JointTrajectory::iterator":
        return _tesseract_common_python.JointTrajectory_erase(self, *args)

    def push_back(self, x: "JointState") -> "void":
        return _tesseract_common_python.JointTrajectory_push_back(self, x)

    def front(self) -> "tesseract_common::JointTrajectory::value_type const &":
        return _tesseract_common_python.JointTrajectory_front(self)

    def back(self) -> "tesseract_common::JointTrajectory::value_type const &":
        return _tesseract_common_python.JointTrajectory_back(self)

    def reserve(self, n: "tesseract_common::JointTrajectory::size_type") -> "void":
        return _tesseract_common_python.JointTrajectory_reserve(self, n)

    def capacity(self) -> "tesseract_common::JointTrajectory::size_type":
        return _tesseract_common_python.JointTrajectory_capacity(self)
    __swig_destroy__ = _tesseract_common_python.delete_JointTrajectory

# Register JointTrajectory in _tesseract_common_python:
_tesseract_common_python.JointTrajectory_swigregister(JointTrajectory)

CollisionMarginOverrideType_NONE = _tesseract_common_python.CollisionMarginOverrideType_NONE
r""" Do not apply contact margin data"""
CollisionMarginOverrideType_REPLACE = _tesseract_common_python.CollisionMarginOverrideType_REPLACE
r""" Replace the contact manager's CollisionMarginData"""
CollisionMarginOverrideType_MODIFY = _tesseract_common_python.CollisionMarginOverrideType_MODIFY
r"""
    Modify the contact managers default margin and pair margins
    This will preserve existing pairs not being modified by the provided margin data.
    If a pair already exist it will be updated with the provided margin data.
    """
CollisionMarginOverrideType_OVERRIDE_DEFAULT_MARGIN = _tesseract_common_python.CollisionMarginOverrideType_OVERRIDE_DEFAULT_MARGIN
r""" Override the contact managers default margin only"""
CollisionMarginOverrideType_OVERRIDE_PAIR_MARGIN = _tesseract_common_python.CollisionMarginOverrideType_OVERRIDE_PAIR_MARGIN
r""" Override the contact managers pair margin only. This does not preserve any existing pair margin data"""
CollisionMarginOverrideType_MODIFY_PAIR_MARGIN = _tesseract_common_python.CollisionMarginOverrideType_MODIFY_PAIR_MARGIN
r"""
    Modify the contact managers pair margin only.
    This will preserve existing pairs not being modified by the provided margin data.
    If a pair already exist it will be updated with the provided margin data.
    """
class CollisionMarginData(object, metaclass=_SwigNonDynamicMeta):
    r""" Stores information about how the margins allowed between collision objects"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_common_python.CollisionMarginData_swiginit(self, _tesseract_common_python.new_CollisionMarginData(*args))

    def setDefaultCollisionMargin(self, default_collision_margin: "double") -> "void":
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_common_python.CollisionMarginData_setDefaultCollisionMargin(self, default_collision_margin)

    def getDefaultCollisionMargin(self) -> "double":
        r"""
        Get the default collision margin
        :rtype: float
        :return: default collision margin
        """
        return _tesseract_common_python.CollisionMarginData_getDefaultCollisionMargin(self)

    def setPairCollisionMargin(self, obj1: "std::string const &", obj2: "std::string const &", collision_margin: "double") -> "void":
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :type obj1: string
        :param obj1: The first object name. Order doesn't matter
        :type obj2: string
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_common_python.CollisionMarginData_setPairCollisionMargin(self, obj1, obj2, collision_margin)

    def getPairCollisionMargin(self, obj1: "std::string const &", obj2: "std::string const &") -> "double":
        r"""
        Get the pairs collision margin data

        If a collision margin for the request pair does not exist it returns the default collision margin data.

        :type obj1: string
        :param obj1: The first object name
        :type obj2: string
        :param obj2: The second object name
        :rtype: float
        :return: A Vector2d[Contact Distance Threshold, Coefficient]
        """
        return _tesseract_common_python.CollisionMarginData_getPairCollisionMargin(self, obj1, obj2)

    def getPairCollisionMargins(self) -> "tesseract_common::PairsCollisionMarginData const &":
        r"""
        Get Collision Margin Data for stored pairs
        :rtype: tesseract_common::PairsCollisionMarginData
        :return: A map of link pairs collision margin data
        """
        return _tesseract_common_python.CollisionMarginData_getPairCollisionMargins(self)

    def getMaxCollisionMargin(self) -> "double":
        r"""
        Get the largest collision margin

        This used when setting the contact distance in the contact manager.

        :rtype: float
        :return: Max contact distance threshold
        """
        return _tesseract_common_python.CollisionMarginData_getMaxCollisionMargin(self)

    def incrementMargins(self, increment: "double const &") -> "void":
        r"""
        Increment all margins by input amount. Useful for inflating or reducing margins
        :type increment: float
        :param increment: Amount to increment margins
        """
        return _tesseract_common_python.CollisionMarginData_incrementMargins(self, increment)

    def scaleMargins(self, scale: "double const &") -> "void":
        r"""
        Scale all margins by input value
        :type scale: float
        :param scale: Value by which all margins are multiplied
        """
        return _tesseract_common_python.CollisionMarginData_scaleMargins(self, scale)

    def apply(self, collision_margin_data: "CollisionMarginData", override_type: "tesseract_common::CollisionMarginOverrideType") -> "void":
        r"""
        Apply the contents of the provide CollisionMarginData based on the override type
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: The collision margin data to apply
        :type override_type: int
        :param override_type: The type indicating how the provided data should be applied.
        """
        return _tesseract_common_python.CollisionMarginData_apply(self, collision_margin_data, override_type)

    def __eq__(self, rhs: "CollisionMarginData") -> "bool":
        return _tesseract_common_python.CollisionMarginData___eq__(self, rhs)

    def __ne__(self, rhs: "CollisionMarginData") -> "bool":
        return _tesseract_common_python.CollisionMarginData___ne__(self, rhs)
    __swig_destroy__ = _tesseract_common_python.delete_CollisionMarginData

# Register CollisionMarginData in _tesseract_common_python:
_tesseract_common_python.CollisionMarginData_swigregister(CollisionMarginData)


def __eq__(entries_1: "AllowedCollisionEntries", entries_2: "AllowedCollisionEntries") -> "bool":
    return _tesseract_common_python.__eq__(entries_1, entries_2)
class AllowedCollisionMatrix(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_common_python.delete_AllowedCollisionMatrix

    def __init__(self, *args):
        _tesseract_common_python.AllowedCollisionMatrix_swiginit(self, _tesseract_common_python.new_AllowedCollisionMatrix(*args))

    def addAllowedCollision(self, link_name1: "std::string const &", link_name2: "std::string const &", reason: "std::string const &") -> "void":
        r"""
        Disable collision between two collision objects
        :param obj1: Collision object name
        :param obj2: Collision object name
        :type reason: string
        :param reason: The reason for disabling collison
        """
        return _tesseract_common_python.AllowedCollisionMatrix_addAllowedCollision(self, link_name1, link_name2, reason)

    def getAllAllowedCollisions(self) -> "tesseract_common::AllowedCollisionEntries const &":
        r"""
        Get all of the entries in the allowed collision matrix
        :rtype: :py:class:`AllowedCollisionEntries`
        :return: AllowedCollisionEntries an unordered map containing all allowed
                    collision entries. The keys of the unordered map are a std::pair
                    of the link names in the allowed collision pair.
        """
        return _tesseract_common_python.AllowedCollisionMatrix_getAllAllowedCollisions(self)

    def removeAllowedCollision(self, *args) -> "void":
        r"""
        *Overload 1:*

        Remove disabled collision pair from allowed collision matrix
        :param obj1: Collision object name
        :param obj2: Collision object name

        |

        *Overload 2:*

        Remove disabled collision for any pair with link_name from allowed collision matrix
        :type link_name: string
        :param link_name: Collision object name
        """
        return _tesseract_common_python.AllowedCollisionMatrix_removeAllowedCollision(self, *args)

    def isCollisionAllowed(self, link_name1: "std::string const &", link_name2: "std::string const &") -> "bool":
        r"""
        This checks if two links are allowed to be in collision
        :type link_name1: string
        :param link_name1: First link name
        :type link_name2: string
        :param link_name2: Second link anme
        :rtype: boolean
        :return: True if allowed to be in collision, otherwise false
        """
        return _tesseract_common_python.AllowedCollisionMatrix_isCollisionAllowed(self, link_name1, link_name2)

    def clearAllowedCollisions(self) -> "void":
        r"""
        Clears the list of allowed collisions, so that no collision will be
               allowed.
        """
        return _tesseract_common_python.AllowedCollisionMatrix_clearAllowedCollisions(self)

    def insertAllowedCollisionMatrix(self, acm: "AllowedCollisionMatrix") -> "void":
        r"""
        Inserts an allowable collision matrix ignoring duplicate pairs
        :type acm: :py:class:`AllowedCollisionMatrix`
        :param acm: ACM to be inserted
        """
        return _tesseract_common_python.AllowedCollisionMatrix_insertAllowedCollisionMatrix(self, acm)

    def __eq__(self, rhs: "AllowedCollisionMatrix") -> "bool":
        return _tesseract_common_python.AllowedCollisionMatrix___eq__(self, rhs)

    def __ne__(self, rhs: "AllowedCollisionMatrix") -> "bool":
        return _tesseract_common_python.AllowedCollisionMatrix___ne__(self, rhs)

# Register AllowedCollisionMatrix in _tesseract_common_python:
_tesseract_common_python.AllowedCollisionMatrix_swigregister(AllowedCollisionMatrix)

class KinematicLimits(object, metaclass=_SwigNonDynamicMeta):
    r""" Store kinematic limits"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    joint_limits = property(_tesseract_common_python.KinematicLimits_joint_limits_get, _tesseract_common_python.KinematicLimits_joint_limits_set, doc=r""" The position limits""")
    velocity_limits = property(_tesseract_common_python.KinematicLimits_velocity_limits_get, _tesseract_common_python.KinematicLimits_velocity_limits_set, doc=r""" The velocity limits""")
    acceleration_limits = property(_tesseract_common_python.KinematicLimits_acceleration_limits_get, _tesseract_common_python.KinematicLimits_acceleration_limits_set, doc=r""" The acceleration limits""")

    def resize(self, size: "Eigen::Index") -> "void":
        return _tesseract_common_python.KinematicLimits_resize(self, size)

    def __eq__(self, rhs: "KinematicLimits") -> "bool":
        return _tesseract_common_python.KinematicLimits___eq__(self, rhs)

    def __ne__(self, rhs: "KinematicLimits") -> "bool":
        return _tesseract_common_python.KinematicLimits___ne__(self, rhs)

    def __init__(self):
        _tesseract_common_python.KinematicLimits_swiginit(self, _tesseract_common_python.new_KinematicLimits())
    __swig_destroy__ = _tesseract_common_python.delete_KinematicLimits

# Register KinematicLimits in _tesseract_common_python:
_tesseract_common_python.KinematicLimits_swigregister(KinematicLimits)

class Timer(object, metaclass=_SwigNonDynamicMeta):
    r""" A simple timer class leveraging chrono high resolution clock"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def start(self) -> "void":
        r""" Start the timer"""
        return _tesseract_common_python.Timer_start(self)

    def stop(self) -> "void":
        r""" Stop the timer"""
        return _tesseract_common_python.Timer_stop(self)

    def elapsedMilliseconds(self) -> "double":
        r"""
        Get the elapsed time in milliseconds
        If timer is actively running it will use Clock::now() as the end time
        :rtype: float
        :return: The elapsed time in milliseconds
        """
        return _tesseract_common_python.Timer_elapsedMilliseconds(self)

    def elapsedSeconds(self) -> "double":
        r"""
        Get the elapsed time in seconds
        If timer is actively running it will use Clock::now() as the end time
        :rtype: float
        :return: The elapsed time in seconds
        """
        return _tesseract_common_python.Timer_elapsedSeconds(self)

    def __init__(self):
        _tesseract_common_python.Timer_swiginit(self, _tesseract_common_python.new_Timer())
    __swig_destroy__ = _tesseract_common_python.delete_Timer

# Register Timer in _tesseract_common_python:
_tesseract_common_python.Timer_swigregister(Timer)


def isWithinPositionLimits(joint_positions: "Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const > const &", position_limits: "Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,2 > const > const &") -> "bool":
    r"""
    Check if within position limits
    :type joint_positions: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param joint_positions: The joint position to check
    :type position_limits: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,2 > const >
    :param position_limits: The joint limits to perform check
    :rtype: boolean
    :return: 
    """
    return _tesseract_common_python.isWithinPositionLimits(joint_positions, position_limits)

def satisfiesPositionLimits(*args) -> "bool":
    r"""
    *Overload 1:*

    Check if joint position is within bounds or relatively equal to a limit
    :type joint_positions: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param joint_positions: The joint position to check
    :param joint_limits: The joint limits to perform check
    :type max_diff: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param max_diff: The max diff when comparing position to limit value max(abs(position - limit)) <= max_diff, if true
        they are considered equal
    :type max_rel_diff: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param max_rel_diff: The max relative diff between position and limit abs(position - limit) <= largest * max_rel_diff,
        if true considered equal. The largest is the largest of the absolute values of position and limit.
    :rtype: boolean
    :return: True if the all position are within the limits or relatively equal to the limit, otherwise false.

    |

    *Overload 2:*

    Check if joint position is within bounds or relatively equal to a limit
    :type joint_positions: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param joint_positions: The joint position to check
    :param joint_limits: The joint limits to perform check
    :type max_diff: float, optional
    :param max_diff: The max diff when comparing position to limit value max(abs(position - limit)) <= max_diff, if true
        they are considered equal
    :type max_rel_diff: float, optional
    :param max_rel_diff: The max relative diff between position and limit abs(position - limit) <= largest * max_rel_diff,
        if true considered equal. The largest is the largest of the absolute values of position and limit.
    :rtype: boolean
    :return: True if the all position are within the limits or relatively equal to the limit, otherwise false.

    |

    *Overload 3:*

    Check if joint position is within bounds or relatively equal to a limit
    :type joint_positions: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param joint_positions: The joint position to check
    :param joint_limits: The joint limits to perform check
    :type max_diff: float, optional
    :param max_diff: The max diff when comparing position to limit value max(abs(position - limit)) <= max_diff, if true
        they are considered equal
    :param max_rel_diff: The max relative diff between position and limit abs(position - limit) <= largest * max_rel_diff,
        if true considered equal. The largest is the largest of the absolute values of position and limit.
    :rtype: boolean
    :return: True if the all position are within the limits or relatively equal to the limit, otherwise false.

    |

    *Overload 4:*

    Check if joint position is within bounds or relatively equal to a limit
    :type joint_positions: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param joint_positions: The joint position to check
    :param joint_limits: The joint limits to perform check
    :param max_diff: The max diff when comparing position to limit value max(abs(position - limit)) <= max_diff, if true
        they are considered equal
    :param max_rel_diff: The max relative diff between position and limit abs(position - limit) <= largest * max_rel_diff,
        if true considered equal. The largest is the largest of the absolute values of position and limit.
    :rtype: boolean
    :return: True if the all position are within the limits or relatively equal to the limit, otherwise false.
    """
    return _tesseract_common_python.satisfiesPositionLimits(*args)


