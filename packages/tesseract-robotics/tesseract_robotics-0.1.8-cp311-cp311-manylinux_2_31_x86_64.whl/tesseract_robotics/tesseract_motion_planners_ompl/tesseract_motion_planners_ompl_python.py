# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_motion_planners_ompl_python
else:
    import _tesseract_motion_planners_ompl_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_motion_planners_ompl_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_motion_planners_ompl_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.vector_eigen_index_swiginit(self, _tesseract_motion_planners_ompl_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_ompl_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python
import tesseract_robotics.tesseract_environment.tesseract_environment_python
import tesseract_robotics.tesseract_kinematics.tesseract_kinematics_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
import tesseract_robotics.tesseract_collision.tesseract_collision_python
import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
OMPLPlannerType_SBL = _tesseract_motion_planners_ompl_python.OMPLPlannerType_SBL
OMPLPlannerType_EST = _tesseract_motion_planners_ompl_python.OMPLPlannerType_EST
OMPLPlannerType_LBKPIECE1 = _tesseract_motion_planners_ompl_python.OMPLPlannerType_LBKPIECE1
OMPLPlannerType_BKPIECE1 = _tesseract_motion_planners_ompl_python.OMPLPlannerType_BKPIECE1
OMPLPlannerType_KPIECE1 = _tesseract_motion_planners_ompl_python.OMPLPlannerType_KPIECE1
OMPLPlannerType_BiTRRT = _tesseract_motion_planners_ompl_python.OMPLPlannerType_BiTRRT
OMPLPlannerType_RRT = _tesseract_motion_planners_ompl_python.OMPLPlannerType_RRT
OMPLPlannerType_RRTConnect = _tesseract_motion_planners_ompl_python.OMPLPlannerType_RRTConnect
OMPLPlannerType_RRTstar = _tesseract_motion_planners_ompl_python.OMPLPlannerType_RRTstar
OMPLPlannerType_TRRT = _tesseract_motion_planners_ompl_python.OMPLPlannerType_TRRT
OMPLPlannerType_PRM = _tesseract_motion_planners_ompl_python.OMPLPlannerType_PRM
OMPLPlannerType_PRMstar = _tesseract_motion_planners_ompl_python.OMPLPlannerType_PRMstar
OMPLPlannerType_LazyPRMstar = _tesseract_motion_planners_ompl_python.OMPLPlannerType_LazyPRMstar
OMPLPlannerType_SPARS = _tesseract_motion_planners_ompl_python.OMPLPlannerType_SPARS
class OMPLPlannerConfigurator(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLPlannerConfigurator

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.OMPLPlannerConfigurator_getType(self)

# Register OMPLPlannerConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLPlannerConfigurator_swigregister(OMPLPlannerConfigurator)

class SBLConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_SBLConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.SBLConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_SBLConfigurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.SBLConfigurator_range_get, _tesseract_motion_planners_ompl_python.SBLConfigurator_range_set, doc=r""" Max motion added to tree""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.SBLConfigurator_getType(self)

# Register SBLConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.SBLConfigurator_swigregister(SBLConfigurator)

class ESTConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_ESTConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.ESTConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_ESTConfigurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.ESTConfigurator_range_get, _tesseract_motion_planners_ompl_python.ESTConfigurator_range_set, doc=r""" Max motion added to tree""")
    goal_bias = property(_tesseract_motion_planners_ompl_python.ESTConfigurator_goal_bias_get, _tesseract_motion_planners_ompl_python.ESTConfigurator_goal_bias_set, doc=r""" When close to goal select goal, with this probability.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.ESTConfigurator_getType(self)

# Register ESTConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.ESTConfigurator_swigregister(ESTConfigurator)

class LBKPIECE1Configurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_LBKPIECE1Configurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_LBKPIECE1Configurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_range_get, _tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_range_set, doc=r""" Max motion added to tree""")
    border_fraction = property(_tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_border_fraction_get, _tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_border_fraction_set, doc=r""" Fraction of time focused on boarder (0.0,1.]""")
    min_valid_path_fraction = property(_tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_min_valid_path_fraction_get, _tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_min_valid_path_fraction_set, doc=r""" Accept partially valid moves above fraction.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_getType(self)

# Register LBKPIECE1Configurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.LBKPIECE1Configurator_swigregister(LBKPIECE1Configurator)

class BKPIECE1Configurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_BKPIECE1Configurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.BKPIECE1Configurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_BKPIECE1Configurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.BKPIECE1Configurator_range_get, _tesseract_motion_planners_ompl_python.BKPIECE1Configurator_range_set, doc=r""" Max motion added to tree""")
    border_fraction = property(_tesseract_motion_planners_ompl_python.BKPIECE1Configurator_border_fraction_get, _tesseract_motion_planners_ompl_python.BKPIECE1Configurator_border_fraction_set, doc=r""" Fraction of time focused on boarder (0.0,1.]""")
    failed_expansion_score_factor = property(_tesseract_motion_planners_ompl_python.BKPIECE1Configurator_failed_expansion_score_factor_get, _tesseract_motion_planners_ompl_python.BKPIECE1Configurator_failed_expansion_score_factor_set, doc=r""" When extending motion fails, scale score by factor.""")
    min_valid_path_fraction = property(_tesseract_motion_planners_ompl_python.BKPIECE1Configurator_min_valid_path_fraction_get, _tesseract_motion_planners_ompl_python.BKPIECE1Configurator_min_valid_path_fraction_set, doc=r""" Accept partially valid moves above fraction.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.BKPIECE1Configurator_getType(self)

# Register BKPIECE1Configurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.BKPIECE1Configurator_swigregister(BKPIECE1Configurator)

class KPIECE1Configurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_KPIECE1Configurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.KPIECE1Configurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_KPIECE1Configurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.KPIECE1Configurator_range_get, _tesseract_motion_planners_ompl_python.KPIECE1Configurator_range_set, doc=r""" Max motion added to tree""")
    goal_bias = property(_tesseract_motion_planners_ompl_python.KPIECE1Configurator_goal_bias_get, _tesseract_motion_planners_ompl_python.KPIECE1Configurator_goal_bias_set, doc=r""" When close to goal select goal, with this probability.""")
    border_fraction = property(_tesseract_motion_planners_ompl_python.KPIECE1Configurator_border_fraction_get, _tesseract_motion_planners_ompl_python.KPIECE1Configurator_border_fraction_set, doc=r""" Fraction of time focused on boarder (0.0,1.]""")
    failed_expansion_score_factor = property(_tesseract_motion_planners_ompl_python.KPIECE1Configurator_failed_expansion_score_factor_get, _tesseract_motion_planners_ompl_python.KPIECE1Configurator_failed_expansion_score_factor_set, doc=r""" When extending motion fails, scale score by factor.""")
    min_valid_path_fraction = property(_tesseract_motion_planners_ompl_python.KPIECE1Configurator_min_valid_path_fraction_get, _tesseract_motion_planners_ompl_python.KPIECE1Configurator_min_valid_path_fraction_set, doc=r""" Accept partially valid moves above fraction.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.KPIECE1Configurator_getType(self)

# Register KPIECE1Configurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.KPIECE1Configurator_swigregister(KPIECE1Configurator)

class BiTRRTConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_BiTRRTConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_BiTRRTConfigurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.BiTRRTConfigurator_range_get, _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_range_set, doc=r""" Max motion added to tree""")
    temp_change_factor = property(_tesseract_motion_planners_ompl_python.BiTRRTConfigurator_temp_change_factor_get, _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_temp_change_factor_set, doc=r""" How much to increase or decrease temp.""")
    cost_threshold = property(_tesseract_motion_planners_ompl_python.BiTRRTConfigurator_cost_threshold_get, _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_cost_threshold_set, doc=r"""
     Any motion cost that is not better than this cost (according to the optimization objective) will not be
    expanded by the planner.
    """)
    init_temperature = property(_tesseract_motion_planners_ompl_python.BiTRRTConfigurator_init_temperature_get, _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_init_temperature_set, doc=r""" Initial temperature.""")
    frontier_threshold = property(_tesseract_motion_planners_ompl_python.BiTRRTConfigurator_frontier_threshold_get, _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_frontier_threshold_set, doc=r""" Dist new state to nearest neighbor to disqualify as frontier.""")
    frontier_node_ratio = property(_tesseract_motion_planners_ompl_python.BiTRRTConfigurator_frontier_node_ratio_get, _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_frontier_node_ratio_set, doc=r""" 1/10, or 1 nonfrontier for every 10 frontier.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.BiTRRTConfigurator_getType(self)

# Register BiTRRTConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.BiTRRTConfigurator_swigregister(BiTRRTConfigurator)

class RRTConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_RRTConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.RRTConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_RRTConfigurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.RRTConfigurator_range_get, _tesseract_motion_planners_ompl_python.RRTConfigurator_range_set, doc=r""" Max motion added to tree""")
    goal_bias = property(_tesseract_motion_planners_ompl_python.RRTConfigurator_goal_bias_get, _tesseract_motion_planners_ompl_python.RRTConfigurator_goal_bias_set, doc=r""" When close to goal select goal, with this probability.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.RRTConfigurator_getType(self)

# Register RRTConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.RRTConfigurator_swigregister(RRTConfigurator)

class RRTConnectConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_RRTConnectConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.RRTConnectConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_RRTConnectConfigurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.RRTConnectConfigurator_range_get, _tesseract_motion_planners_ompl_python.RRTConnectConfigurator_range_set, doc=r""" Max motion added to tree""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.RRTConnectConfigurator_getType(self)

# Register RRTConnectConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.RRTConnectConfigurator_swigregister(RRTConnectConfigurator)

class RRTstarConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_RRTstarConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.RRTstarConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_RRTstarConfigurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.RRTstarConfigurator_range_get, _tesseract_motion_planners_ompl_python.RRTstarConfigurator_range_set, doc=r""" Max motion added to tree""")
    goal_bias = property(_tesseract_motion_planners_ompl_python.RRTstarConfigurator_goal_bias_get, _tesseract_motion_planners_ompl_python.RRTstarConfigurator_goal_bias_set, doc=r""" When close to goal select goal, with this probability.""")
    delay_collision_checking = property(_tesseract_motion_planners_ompl_python.RRTstarConfigurator_delay_collision_checking_get, _tesseract_motion_planners_ompl_python.RRTstarConfigurator_delay_collision_checking_set, doc=r""" Stop collision checking as soon as C-free parent found.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.RRTstarConfigurator_getType(self)

# Register RRTstarConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.RRTstarConfigurator_swigregister(RRTstarConfigurator)

class TRRTConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_TRRTConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.TRRTConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_TRRTConfigurator(*args))
    range = property(_tesseract_motion_planners_ompl_python.TRRTConfigurator_range_get, _tesseract_motion_planners_ompl_python.TRRTConfigurator_range_set, doc=r""" Max motion added to tree""")
    goal_bias = property(_tesseract_motion_planners_ompl_python.TRRTConfigurator_goal_bias_get, _tesseract_motion_planners_ompl_python.TRRTConfigurator_goal_bias_set, doc=r""" When close to goal select goal, with this probability.""")
    temp_change_factor = property(_tesseract_motion_planners_ompl_python.TRRTConfigurator_temp_change_factor_get, _tesseract_motion_planners_ompl_python.TRRTConfigurator_temp_change_factor_set, doc=r""" How much to increase or decrease temp.""")
    init_temperature = property(_tesseract_motion_planners_ompl_python.TRRTConfigurator_init_temperature_get, _tesseract_motion_planners_ompl_python.TRRTConfigurator_init_temperature_set, doc=r""" Initial temperature.""")
    frontier_threshold = property(_tesseract_motion_planners_ompl_python.TRRTConfigurator_frontier_threshold_get, _tesseract_motion_planners_ompl_python.TRRTConfigurator_frontier_threshold_set, doc=r""" Dist new state to nearest neighbor to disqualify as frontier.""")
    frontier_node_ratio = property(_tesseract_motion_planners_ompl_python.TRRTConfigurator_frontier_node_ratio_get, _tesseract_motion_planners_ompl_python.TRRTConfigurator_frontier_node_ratio_set, doc=r""" 1/10, or 1 nonfrontier for every 10 frontier.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.TRRTConfigurator_getType(self)

# Register TRRTConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.TRRTConfigurator_swigregister(TRRTConfigurator)

class PRMConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_PRMConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.PRMConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_PRMConfigurator(*args))
    max_nearest_neighbors = property(_tesseract_motion_planners_ompl_python.PRMConfigurator_max_nearest_neighbors_get, _tesseract_motion_planners_ompl_python.PRMConfigurator_max_nearest_neighbors_set, doc=r""" Use k nearest neighbors.""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.PRMConfigurator_getType(self)

# Register PRMConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.PRMConfigurator_swigregister(PRMConfigurator)

class PRMstarConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_PRMstarConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.PRMstarConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_PRMstarConfigurator(*args))

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.PRMstarConfigurator_getType(self)

# Register PRMstarConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.PRMstarConfigurator_swigregister(PRMstarConfigurator)

class LazyPRMstarConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_LazyPRMstarConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.LazyPRMstarConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_LazyPRMstarConfigurator(*args))

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.LazyPRMstarConfigurator_getType(self)

# Register LazyPRMstarConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.LazyPRMstarConfigurator_swigregister(LazyPRMstarConfigurator)

class SPARSConfigurator(OMPLPlannerConfigurator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_SPARSConfigurator

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.SPARSConfigurator_swiginit(self, _tesseract_motion_planners_ompl_python.new_SPARSConfigurator(*args))
    max_failures = property(_tesseract_motion_planners_ompl_python.SPARSConfigurator_max_failures_get, _tesseract_motion_planners_ompl_python.SPARSConfigurator_max_failures_set, doc=r""" The maximum number of failures before terminating the algorithm""")
    dense_delta_fraction = property(_tesseract_motion_planners_ompl_python.SPARSConfigurator_dense_delta_fraction_get, _tesseract_motion_planners_ompl_python.SPARSConfigurator_dense_delta_fraction_set, doc=r""" Dense graph connection distance as a fraction of max. extent""")
    sparse_delta_fraction = property(_tesseract_motion_planners_ompl_python.SPARSConfigurator_sparse_delta_fraction_get, _tesseract_motion_planners_ompl_python.SPARSConfigurator_sparse_delta_fraction_set, doc=r""" Sparse Roadmap connection distance as a fraction of max. extent""")
    stretch_factor = property(_tesseract_motion_planners_ompl_python.SPARSConfigurator_stretch_factor_get, _tesseract_motion_planners_ompl_python.SPARSConfigurator_stretch_factor_set, doc=r""" The stretch factor in terms of graph spanners for SPARS to check against""")

    def getType(self) -> "tesseract_planning::OMPLPlannerType":
        return _tesseract_motion_planners_ompl_python.SPARSConfigurator_getType(self)

# Register SPARSConfigurator in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.SPARSConfigurator_swigregister(SPARSConfigurator)

class OMPLPlanners(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::difference_type", j: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::difference_type") -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const >,std::allocator< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > > > *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::difference_type", j: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::difference_type") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::value_type const &":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::value_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_size(self)

    def swap(self, v: "OMPLPlanners") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::reverse_iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::reverse_iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_rend(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::allocator_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_erase(self, *args)

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.OMPLPlanners_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLPlanners(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::value_type const &":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_front(self)

    def back(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::value_type const &":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::size_type", x: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::size_type") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLPlannerConfigurator const > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanners_capacity(self)
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLPlanners

# Register OMPLPlanners in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLPlanners_swigregister(OMPLPlanners)

OMPLProblemStateSpace_REAL_STATE_SPACE = _tesseract_motion_planners_ompl_python.OMPLProblemStateSpace_REAL_STATE_SPACE
OMPLProblemStateSpace_REAL_CONSTRAINTED_STATE_SPACE = _tesseract_motion_planners_ompl_python.OMPLProblemStateSpace_REAL_CONSTRAINTED_STATE_SPACE
OMPLProblemStateSpace_SE3_STATE_SPACE = _tesseract_motion_planners_ompl_python.OMPLProblemStateSpace_SE3_STATE_SPACE
class OMPLProblem(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    env = property(_tesseract_motion_planners_ompl_python.OMPLProblem_env_get, _tesseract_motion_planners_ompl_python.OMPLProblem_env_set)
    env_state = property(_tesseract_motion_planners_ompl_python.OMPLProblem_env_state_get, _tesseract_motion_planners_ompl_python.OMPLProblem_env_state_set)
    contact_checker = property(_tesseract_motion_planners_ompl_python.OMPLProblem_contact_checker_get, _tesseract_motion_planners_ompl_python.OMPLProblem_contact_checker_set)
    state_space = property(_tesseract_motion_planners_ompl_python.OMPLProblem_state_space_get, _tesseract_motion_planners_ompl_python.OMPLProblem_state_space_set)
    manip = property(_tesseract_motion_planners_ompl_python.OMPLProblem_manip_get, _tesseract_motion_planners_ompl_python.OMPLProblem_manip_set)
    planning_time = property(_tesseract_motion_planners_ompl_python.OMPLProblem_planning_time_get, _tesseract_motion_planners_ompl_python.OMPLProblem_planning_time_set, doc=r""" Max planning time allowed in seconds""")
    max_solutions = property(_tesseract_motion_planners_ompl_python.OMPLProblem_max_solutions_get, _tesseract_motion_planners_ompl_python.OMPLProblem_max_solutions_set, doc=r""" The max number of solutions. If max solutions are hit it will exit even if other threads are running.""")
    simplify = property(_tesseract_motion_planners_ompl_python.OMPLProblem_simplify_get, _tesseract_motion_planners_ompl_python.OMPLProblem_simplify_set, doc=r"""
    Simplify trajectory.

    Note: If set to true it ignores n_output_states and returns the simplest trajectory.
    """)
    n_output_states = property(_tesseract_motion_planners_ompl_python.OMPLProblem_n_output_states_get, _tesseract_motion_planners_ompl_python.OMPLProblem_n_output_states_set, doc=r"""
    Number of states in the output trajectory
      Note: This is ignored if the simplify is set to true.
      Note: The trajectory can be longer if original trajectory is longer and reducing the number of states causes
            the solution to be invalid.
    """)
    optimize = property(_tesseract_motion_planners_ompl_python.OMPLProblem_optimize_get, _tesseract_motion_planners_ompl_python.OMPLProblem_optimize_set, doc=r"""
    This uses all available planning time to create the most optimized trajectory given the objective function.

    This is required because not all OMPL planners are optimize graph planners. If the planner you choose is an
    optimize graph planner then setting this to true has no affect. In the case of non-optimize planners they still
    use the OptimizeObjective function but only when searching the graph to find the most optimize solution based
    on the provided optimize objective function. In the case of these type of planners like RRT and RRTConnect if set
    to true it will leverage all planning time to keep finding solutions up to your max solutions count to find the
    most optimal solution.
    """)
    simple_setup = property(_tesseract_motion_planners_ompl_python.OMPLProblem_simple_setup_get, _tesseract_motion_planners_ompl_python.OMPLProblem_simple_setup_set, doc=r""" OMPL problem to be solved ***REQUIRED***""")
    planners = property(_tesseract_motion_planners_ompl_python.OMPLProblem_planners_get, _tesseract_motion_planners_ompl_python.OMPLProblem_planners_set, doc=r"""
    The planner configurators ***REQUIRED***

    This will create a new thread for each planner configurator provided. T
    """)

    def getTrajectory(self) -> "tesseract_common::TrajArray":
        r"""
        Convert the path stored in simple_setup to tesseract trajectory
        This is required because the motion planner is not aware of the state space type.
        :rtype: tesseract_common::TrajArray
        :return: Tesseract Trajectory
        """
        return _tesseract_motion_planners_ompl_python.OMPLProblem_getTrajectory(self)

    def __init__(self):
        _tesseract_motion_planners_ompl_python.OMPLProblem_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLProblem())
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLProblem

# Register OMPLProblem in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLProblem_swigregister(OMPLProblem)

class OMPLProblems(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::difference_type", j: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::difference_type") -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem >,std::allocator< std::shared_ptr< tesseract_planning::OMPLProblem > > > *":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::difference_type", j: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::difference_type") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::value_type const &":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::value_type":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_size(self)

    def swap(self, v: "OMPLProblems") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::reverse_iterator":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::reverse_iterator":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_rend(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::allocator_type":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_erase(self, *args)

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.OMPLProblems_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLProblems(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::value_type const &":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_front(self)

    def back(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::value_type const &":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::size_type", x: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::value_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::size_type") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLProblems_capacity(self)
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLProblems

# Register OMPLProblems in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLProblems_swigregister(OMPLProblems)

class OMPLMotionPlannerStatusCategory(tesseract_robotics.tesseract_common.tesseract_common_python.StatusCategory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, name: "std::string"):
        _tesseract_motion_planners_ompl_python.OMPLMotionPlannerStatusCategory_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLMotionPlannerStatusCategory(name))

    def name(self) -> "std::string const &":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlannerStatusCategory_name(self)

    def message(self, code: "int") -> "std::string":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlannerStatusCategory_message(self, code)
    SolutionFound = _tesseract_motion_planners_ompl_python.OMPLMotionPlannerStatusCategory_SolutionFound
    ErrorInvalidInput = _tesseract_motion_planners_ompl_python.OMPLMotionPlannerStatusCategory_ErrorInvalidInput
    ErrorFailedToFindValidSolution = _tesseract_motion_planners_ompl_python.OMPLMotionPlannerStatusCategory_ErrorFailedToFindValidSolution
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLMotionPlannerStatusCategory

# Register OMPLMotionPlannerStatusCategory in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLMotionPlannerStatusCategory_swigregister(OMPLMotionPlannerStatusCategory)

class OMPLPlanProfile(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLPlanProfile

    def setup(self, prob: "OMPLProblem") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfile_setup(self, prob)

    def applyGoalStates(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfile_applyGoalStates(self, *args)

    def applyStartStates(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfile_applyStartStates(self, *args)

# Register OMPLPlanProfile in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLPlanProfile_swigregister(OMPLPlanProfile)

class OMPLPlanProfileMap(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::mapped_type const &":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::key_type const &") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::key_type const &") -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::key_type const &") -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_asdict(self)

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLPlanProfileMap(*args))

    def empty(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_size(self)

    def swap(self, v: "OMPLPlanProfileMap") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_end(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::allocator_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::size_type":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > >::iterator":
        return _tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_find(self, x)
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLPlanProfileMap

# Register OMPLPlanProfileMap in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLPlanProfileMap_swigregister(OMPLPlanProfileMap)


def ProfileDictionary_hasProfileEntry_OMPLPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "bool":
    return _tesseract_motion_planners_ompl_python.ProfileDictionary_hasProfileEntry_OMPLPlanProfile(profile_dictionary, ns)

def ProfileDictionary_removeProfileEntry_OMPLPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "void":
    return _tesseract_motion_planners_ompl_python.ProfileDictionary_removeProfileEntry_OMPLPlanProfile(profile_dictionary, ns)

def ProfileDictionary_getProfileEntry_OMPLPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::OMPLPlanProfile const >,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,std::shared_ptr< tesseract_planning::OMPLPlanProfile const > > > >":
    return _tesseract_motion_planners_ompl_python.ProfileDictionary_getProfileEntry_OMPLPlanProfile(profile_dictionary, ns)

def ProfileDictionary_addProfile_OMPLPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &", profile: "std::shared_ptr< tesseract_planning::OMPLPlanProfile const >") -> "void":
    return _tesseract_motion_planners_ompl_python.ProfileDictionary_addProfile_OMPLPlanProfile(profile_dictionary, ns, profile_name, profile)

def ProfileDictionary_getProfile_OMPLPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "std::shared_ptr< tesseract_planning::OMPLPlanProfile const >":
    return _tesseract_motion_planners_ompl_python.ProfileDictionary_getProfile_OMPLPlanProfile(profile_dictionary, ns, profile_name)

def ProfileDictionary_hasProfile_OMPLPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "bool":
    return _tesseract_motion_planners_ompl_python.ProfileDictionary_hasProfile_OMPLPlanProfile(profile_dictionary, ns, profile_name)

def ProfileDictionary_removeProfile_OMPLPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "void":
    return _tesseract_motion_planners_ompl_python.ProfileDictionary_removeProfile_OMPLPlanProfile(profile_dictionary, ns, profile_name)
class OMPLDefaultPlanProfile(OMPLPlanProfile):
    r"""
    OMPL does not support the concept of multi waypoint planning like descartes and trajopt. Because of this
    every plan instruction will be its a seperate ompl motion plan and therefore planning information is relevent
    for this motion planner in the profile.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLDefaultPlanProfile

    def __init__(self, *args):
        _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLDefaultPlanProfile(*args))
    state_space = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_state_space_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_state_space_set, doc=r""" The OMPL state space to use when planning""")
    planning_time = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_planning_time_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_planning_time_set, doc=r""" Max planning time allowed in seconds""")
    max_solutions = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_max_solutions_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_max_solutions_set, doc=r""" The max number of solutions. If max solutions are hit it will exit even if other threads are running.""")
    simplify = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_simplify_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_simplify_set, doc=r"""
    Simplify trajectory.

    Note: If set to true it ignores n_output_states and returns the simplest trajectory.
    """)
    optimize = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_optimize_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_optimize_set, doc=r"""
    This uses all available planning time to create the most optimized trajectory given the objective function.

    This is required because not all OMPL planners are optimize graph planners. If the planner you choose is an
    optimize graph planner then setting this to true has no affect. In the case of non-optimize planners they still
    use the OptimizeObjective function but only when searching the graph to find the most optimize solution based
    on the provided optimize objective function. In the case of these type of planners like RRT and RRTConnect if set
    to true it will leverage all planning time to keep finding solutions up to your max solutions count to find the
    most optimal solution.
    """)
    planners = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_planners_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_planners_set, doc=r"""
    The planner configurators

    This defaults to two RRTConnectConfigurator

    This will create a new thread for each planner configurator provided. T
    """)
    collision_check_config = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_collision_check_config_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_collision_check_config_set, doc=r""" The collision check configuration""")
    state_sampler_allocator = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_state_sampler_allocator_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_state_sampler_allocator_set, doc=r""" The state sampler allocator. This can be null and it will use Tesseract default state sampler allocator.""")
    optimization_objective_allocator = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_optimization_objective_allocator_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_optimization_objective_allocator_set, doc=r""" Set the optimization objective function allocator. Default is to minimize path length""")
    svc_allocator = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_svc_allocator_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_svc_allocator_set, doc=r"""
     The ompl state validity checker. If nullptr and collision checking enabled it uses
    StateCollisionValidator
    """)
    mv_allocator = property(_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_mv_allocator_get, _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_mv_allocator_set, doc=r"""
     The ompl motion validator. If nullptr and continuous collision checking enabled it used
    ContinuousMotionValidator
    """)

    def setup(self, prob: "OMPLProblem") -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_setup(self, prob)

    def applyGoalStates(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_applyGoalStates(self, *args)

    def applyStartStates(self, *args) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_applyStartStates(self, *args)

# Register OMPLDefaultPlanProfile in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLDefaultPlanProfile_swigregister(OMPLDefaultPlanProfile)

class OMPLProblemGeneratorFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a: "std::string const &", b: "PlannerRequest", c: "OMPLPlanProfileMap") -> "std::vector< std::shared_ptr< tesseract_planning::OMPLProblem >,std::allocator< std::shared_ptr< tesseract_planning::OMPLProblem > > >":
        return _tesseract_motion_planners_ompl_python.OMPLProblemGeneratorFnBase_call(self, a, b, c)
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLProblemGeneratorFnBase

    def __init__(self):
        if self.__class__ == OMPLProblemGeneratorFnBase:
            _self = None
        else:
            _self = self
        _tesseract_motion_planners_ompl_python.OMPLProblemGeneratorFnBase_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLProblemGeneratorFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_motion_planners_ompl_python.disown_OMPLProblemGeneratorFnBase(self)
        return weakref.proxy(self)

# Register OMPLProblemGeneratorFnBase in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLProblemGeneratorFnBase_swigregister(OMPLProblemGeneratorFnBase)



class OMPLProblemGeneratorFn(OMPLProblemGeneratorFnBase):
  def __init__(self,fn):
    super(OMPLProblemGeneratorFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

class OMPLMotionPlanner(tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python.MotionPlanner):
    r"""
    This planner is intended to provide an easy to use interface to OMPL for freespace planning. It is made to
    take a start and end point and automate the generation of the OMPL problem.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" Construct a planner"""
        _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_swiginit(self, _tesseract_motion_planners_ompl_python.new_OMPLMotionPlanner(*args))

    def getName(self) -> "std::string const &":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_getName(self)

    def solve(self, request: "PlannerRequest", response: "PlannerResponse", verbose: "bool"=False) -> "tesseract_common::StatusCode":
        r"""
        Sets up the OMPL problem then solves. It is intended to simplify setting up
        and solving freespace motion problems.

        This planner leverages OMPL ParallelPlan which supports being called multiple times. So you are able to
        setConfiguration and keep calling solve and with each solve it will continue to build the existing planner graph.
        If you want to start with a clean graph you must call setConfiguration() before calling solve again.

        This planner (and the associated config passed to the setConfiguration) does not expose all of the available
        configuration data in OMPL. This is done to simplify the interface. However, many problems may require more
        specific setups. In that case, the source code for this planner may be used as an example.

        Note: This does not use the request information because everything is provided by config parameter

        :type response: :py:class:`PlannerResponse`
        :param response: The results of OMPL.
        :param check_type: The type of validation check to be performed on the planned trajectory
        :type verbose: boolean, optional
        :param verbose: Flag for printing more detailed planning information
        :rtype: :py:class:`StatusCode`
        :return: true if valid solution was found
        """
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_solve(self, request, response, verbose)

    def terminate(self) -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_terminate(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_clear(self)

    def clone(self) -> "tesseract_planning::MotionPlanner::Ptr":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_clone(self)

    @staticmethod
    def checkUserInput(request: "PlannerRequest") -> "bool":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_checkUserInput(request)

    def createProblems(self, request: "PlannerRequest") -> "std::vector< tesseract_planning::OMPLProblem::Ptr,std::allocator< tesseract_planning::OMPLProblem::Ptr > >":
        return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_createProblems(self, request)
    __swig_destroy__ = _tesseract_motion_planners_ompl_python.delete_OMPLMotionPlanner

# Register OMPLMotionPlanner in _tesseract_motion_planners_ompl_python:
_tesseract_motion_planners_ompl_python.OMPLMotionPlanner_swigregister(OMPLMotionPlanner)

def OMPLMotionPlanner_checkUserInput(request: "PlannerRequest") -> "bool":
    return _tesseract_motion_planners_ompl_python.OMPLMotionPlanner_checkUserInput(request)


def toXMLDocument(plan_profile: "OMPLPlanProfile") -> "std::shared_ptr< tinyxml2::XMLDocument >":
    return _tesseract_motion_planners_ompl_python.toXMLDocument(plan_profile)

def toXMLFile(plan_profile: "OMPLPlanProfile", file_path: "std::string const &") -> "bool":
    return _tesseract_motion_planners_ompl_python.toXMLFile(plan_profile, file_path)

def toXMLString(plan_profile: "OMPLPlanProfile") -> "std::string":
    return _tesseract_motion_planners_ompl_python.toXMLString(plan_profile)

def omplPlanParser(xml_element: "XMLElement") -> "tesseract_planning::OMPLDefaultPlanProfile":
    return _tesseract_motion_planners_ompl_python.omplPlanParser(xml_element)

def omplPlanFromXMLElement(profile_xml: "XMLElement") -> "tesseract_planning::OMPLDefaultPlanProfile":
    return _tesseract_motion_planners_ompl_python.omplPlanFromXMLElement(profile_xml)

def omplPlanFromXMLDocument(xml_doc: "XMLDocument") -> "tesseract_planning::OMPLDefaultPlanProfile":
    return _tesseract_motion_planners_ompl_python.omplPlanFromXMLDocument(xml_doc)

def omplPlanFromXMLFile(file_path: "std::string const &") -> "tesseract_planning::OMPLDefaultPlanProfile":
    return _tesseract_motion_planners_ompl_python.omplPlanFromXMLFile(file_path)

def omplPlanFromXMLString(xml_string: "std::string const &") -> "tesseract_planning::OMPLDefaultPlanProfile":
    return _tesseract_motion_planners_ompl_python.omplPlanFromXMLString(xml_string)


