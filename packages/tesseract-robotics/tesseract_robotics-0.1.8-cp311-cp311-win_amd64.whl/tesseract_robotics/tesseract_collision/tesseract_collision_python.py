# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_collision_python
else:
    import _tesseract_collision_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_collision_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_collision_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_collision_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_collision_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_collision_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_collision_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_collision_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_collision_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_collision_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_collision_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_collision_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_collision_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_collision_python:
_tesseract_collision_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_collision_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_collision_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_collision_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_collision_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_collision_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_collision_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_collision_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_collision_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_collision_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_collision_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_collision_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_collision_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_collision_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_collision_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_collision_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_collision_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_collision_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_collision_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_collision_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_collision_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_collision_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_collision_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_collision_python.vector_eigen_index_swiginit(self, _tesseract_collision_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_collision_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_collision_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_collision_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_collision_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_collision_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_collision_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_collision_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_collision_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_collision_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_collision_python:
_tesseract_collision_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_common.tesseract_common_python
class IsContactAllowedFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a: "std::string const &", b: "std::string const &") -> "bool":
        return _tesseract_collision_python.IsContactAllowedFnBase_call(self, a, b)
    __swig_destroy__ = _tesseract_collision_python.delete_IsContactAllowedFnBase

    def __init__(self):
        if self.__class__ == IsContactAllowedFnBase:
            _self = None
        else:
            _self = self
        _tesseract_collision_python.IsContactAllowedFnBase_swiginit(self, _tesseract_collision_python.new_IsContactAllowedFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_collision_python.disown_IsContactAllowedFnBase(self)
        return weakref.proxy(self)

# Register IsContactAllowedFnBase in _tesseract_collision_python:
_tesseract_collision_python.IsContactAllowedFnBase_swigregister(IsContactAllowedFnBase)



class IsContactAllowedFn(IsContactAllowedFnBase):
  def __init__(self,fn):
    super(IsContactAllowedFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

class IsContactValidFnBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def call(self, a: "ContactResult") -> "bool":
        return _tesseract_collision_python.IsContactValidFnBase_call(self, a)
    __swig_destroy__ = _tesseract_collision_python.delete_IsContactValidFnBase

    def __init__(self):
        if self.__class__ == IsContactValidFnBase:
            _self = None
        else:
            _self = self
        _tesseract_collision_python.IsContactValidFnBase_swiginit(self, _tesseract_collision_python.new_IsContactValidFnBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _tesseract_collision_python.disown_IsContactValidFnBase(self)
        return weakref.proxy(self)

# Register IsContactValidFnBase in _tesseract_collision_python:
_tesseract_collision_python.IsContactValidFnBase_swigregister(IsContactValidFnBase)



class IsContactValidFn(IsContactValidFnBase):
  def __init__(self,fn):
    super(IsContactValidFn,self).__init__()
    self._fn = fn

  def call(self,*args):
    return self._fn(*args)

class ContinuousContactManagerUPtr(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.ContinuousContactManagerUPtr_swiginit(self, _tesseract_collision_python.new_ContinuousContactManagerUPtr(*args))

    def __deref__(self) -> "std::unique_ptr< tesseract_collision::ContinuousContactManager >::pointer":
        return _tesseract_collision_python.ContinuousContactManagerUPtr___deref__(self)

    def release(self) -> "std::unique_ptr< tesseract_collision::ContinuousContactManager >::pointer":
        return _tesseract_collision_python.ContinuousContactManagerUPtr_release(self)

    def reset(self, *args) -> "void":
        return _tesseract_collision_python.ContinuousContactManagerUPtr_reset(self, *args)

    def swap(self, __u: "ContinuousContactManagerUPtr") -> "void":
        return _tesseract_collision_python.ContinuousContactManagerUPtr_swap(self, __u)

    def get(self) -> "std::unique_ptr< tesseract_collision::ContinuousContactManager >::pointer":
        return _tesseract_collision_python.ContinuousContactManagerUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_collision_python.ContinuousContactManagerUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_collision_python.delete_ContinuousContactManagerUPtr

    def getName(self) -> "std::string":
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getName(self)

    def clone(self) -> "tesseract_collision::ContinuousContactManager::UPtr":
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_clone(self)

    def addCollisionObject(self, name: "std::string const &", mask_id: "int const &", shapes: "GeometriesConst", shape_poses: "VectorIsometry3d", enabled: "bool"=True) -> "bool":
        r"""
        Add a collision object to the checker

        All objects are added should initially be added as static objects. Use the
        setContactRequest method of defining which collision objects are moving.

        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :param shape_types:     A vector of shape types for encode the collision object. If the vector is of length 1 it is
            used for all shapes.
        :param collision_object_types: A int identifying a conversion mode for the object. (ex. convert meshes to
            convex_hulls)
        :type enabled: boolean, optional
        :param enabled:         Indicate if the object is enabled for collision checking.
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name: "std::string const &") -> "tesseract_collision::CollisionShapesConst const &":
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name: "std::string const &") -> "tesseract_common::VectorIsometry3d const &":
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_hasCollisionObject(self, name)

    def removeCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_removeCollisionObject(self, name)

    def enableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_enableCollisionObject(self, name)

    def disableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name: "std::string const &") -> "bool":
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args) -> "void":
        r"""
        *Overload 1:*

        Set a single static collision object's tansforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The tranformation in world

        |

        *Overload 2:*

        Set a series of static collision object's tranforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The tranformation in world

        |

        *Overload 3:*

        Set a series of static collision object's tranforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>

        |

        *Overload 4:*

        Set a single cast(moving) collision object's tansforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type name: string
        :param name: The name of the object
        :type pose1: :py:class:`Isometry3d`
        :param pose1: The start tranformation in world
        :type pose2: :py:class:`Isometry3d`
        :param pose2: The end tranformation in world

        |

        *Overload 5:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type pose1: :py:class:`VectorIsometry3d`
        :param pose1: The start tranformations in world
        :type pose2: :py:class:`VectorIsometry3d`
        :param pose2: The end tranformations in world

        |

        *Overload 6:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type pose1: :py:class:`TransformMap`
        :param pose1: A start transform map <name, pose>
        :type pose2: :py:class:`TransformMap`
        :param pose2: A end transform map <name, pose>
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names: "vector_string") -> "void":
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args) -> "void":
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin: "double") -> "void":
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1: "std::string const &", name2: "std::string const &", collision_margin: "double") -> "void":
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self) -> "tesseract_collision::CollisionMarginData const &":
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_getCollisionMarginData(self)

    def setIsContactAllowedFn(self, fn: "tesseract_collision::IsContactAllowedFn") -> "void":
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.ContinuousContactManagerUPtr_setIsContactAllowedFn(self, fn)

    def contactTest(self, collisions: "ContactResultMap", request: "ContactRequest") -> "void":
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The Contact results data
        :param type: The type of contact test
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config: "ContactManagerConfig") -> "void":
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.ContinuousContactManagerUPtr_applyContactManagerConfig(self, config)

# Register ContinuousContactManagerUPtr in _tesseract_collision_python:
_tesseract_collision_python.ContinuousContactManagerUPtr_swigregister(ContinuousContactManagerUPtr)

class DiscreteContactManagerUPtr(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.DiscreteContactManagerUPtr_swiginit(self, _tesseract_collision_python.new_DiscreteContactManagerUPtr(*args))

    def __deref__(self) -> "std::unique_ptr< tesseract_collision::DiscreteContactManager >::pointer":
        return _tesseract_collision_python.DiscreteContactManagerUPtr___deref__(self)

    def release(self) -> "std::unique_ptr< tesseract_collision::DiscreteContactManager >::pointer":
        return _tesseract_collision_python.DiscreteContactManagerUPtr_release(self)

    def reset(self, *args) -> "void":
        return _tesseract_collision_python.DiscreteContactManagerUPtr_reset(self, *args)

    def swap(self, __u: "DiscreteContactManagerUPtr") -> "void":
        return _tesseract_collision_python.DiscreteContactManagerUPtr_swap(self, __u)

    def get(self) -> "std::unique_ptr< tesseract_collision::DiscreteContactManager >::pointer":
        return _tesseract_collision_python.DiscreteContactManagerUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_collision_python.DiscreteContactManagerUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_collision_python.delete_DiscreteContactManagerUPtr

    def getName(self) -> "std::string":
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getName(self)

    def clone(self) -> "tesseract_collision::DiscreteContactManager::UPtr":
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_clone(self)

    def addCollisionObject(self, name: "std::string const &", mask_id: "int const &", shapes: "GeometriesConst", shape_poses: "VectorIsometry3d", enabled: "bool"=True) -> "bool":
        r"""
        Add a object to the checker
        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name: "std::string const &") -> "tesseract_collision::CollisionShapesConst const &":
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name: "std::string const &") -> "tesseract_common::VectorIsometry3d const &":
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_hasCollisionObject(self, name)

    def removeCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_removeCollisionObject(self, name)

    def enableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_enableCollisionObject(self, name)

    def disableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name: "std::string const &") -> "bool":
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args) -> "void":
        r"""
        *Overload 1:*

        Set a single collision object's transforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The transformation in world

        |

        *Overload 2:*

        Set a series of collision object's transforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The transformation in world

        |

        *Overload 3:*

        Set a series of collision object's transforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names: "vector_string") -> "void":
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args) -> "void":
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin: "double") -> "void":
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1: "std::string const &", name2: "std::string const &", collision_margin: "double") -> "void":
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self) -> "tesseract_collision::CollisionMarginData const &":
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_getCollisionMarginData(self)

    def setIsContactAllowedFn(self, fn: "tesseract_collision::IsContactAllowedFn") -> "void":
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.DiscreteContactManagerUPtr_setIsContactAllowedFn(self, fn)

    def contactTest(self, collisions: "ContactResultMap", request: "ContactRequest") -> "void":
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The contact results data
        :type request: :py:class:`ContactRequest`
        :param request: The contact request data
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config: "ContactManagerConfig") -> "void":
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.DiscreteContactManagerUPtr_applyContactManagerConfig(self, config)

# Register DiscreteContactManagerUPtr in _tesseract_collision_python:
_tesseract_collision_python.DiscreteContactManagerUPtr_swigregister(DiscreteContactManagerUPtr)

class ContactResultVector(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.ContactResultVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_collision_python.ContactResultVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_collision_python.ContactResultVector___bool__(self)

    def __len__(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::size_type":
        return _tesseract_collision_python.ContactResultVector___len__(self)

    def __getslice__(self, i: "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::difference_type", j: "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::difference_type") -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > *":
        return _tesseract_collision_python.ContactResultVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_collision_python.ContactResultVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::difference_type", j: "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::difference_type") -> "void":
        return _tesseract_collision_python.ContactResultVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_collision_python.ContactResultVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::value_type const &":
        return _tesseract_collision_python.ContactResultVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_collision_python.ContactResultVector___setitem__(self, *args)

    def pop(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::value_type":
        return _tesseract_collision_python.ContactResultVector_pop(self)

    def append(self, x: "ContactResult") -> "void":
        return _tesseract_collision_python.ContactResultVector_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_collision_python.ContactResultVector_empty(self)

    def size(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::size_type":
        return _tesseract_collision_python.ContactResultVector_size(self)

    def swap(self, v: "ContactResultVector") -> "void":
        return _tesseract_collision_python.ContactResultVector_swap(self, v)

    def begin(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::iterator":
        return _tesseract_collision_python.ContactResultVector_begin(self)

    def end(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::iterator":
        return _tesseract_collision_python.ContactResultVector_end(self)

    def rbegin(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::reverse_iterator":
        return _tesseract_collision_python.ContactResultVector_rbegin(self)

    def rend(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::reverse_iterator":
        return _tesseract_collision_python.ContactResultVector_rend(self)

    def clear(self) -> "void":
        return _tesseract_collision_python.ContactResultVector_clear(self)

    def get_allocator(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::allocator_type":
        return _tesseract_collision_python.ContactResultVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_collision_python.ContactResultVector_pop_back(self)

    def erase(self, *args) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::iterator":
        return _tesseract_collision_python.ContactResultVector_erase(self, *args)

    def __init__(self, *args):
        _tesseract_collision_python.ContactResultVector_swiginit(self, _tesseract_collision_python.new_ContactResultVector(*args))

    def push_back(self, x: "ContactResult") -> "void":
        return _tesseract_collision_python.ContactResultVector_push_back(self, x)

    def front(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::value_type const &":
        return _tesseract_collision_python.ContactResultVector_front(self)

    def back(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::value_type const &":
        return _tesseract_collision_python.ContactResultVector_back(self)

    def assign(self, n: "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::size_type", x: "ContactResult") -> "void":
        return _tesseract_collision_python.ContactResultVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_collision_python.ContactResultVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_collision_python.ContactResultVector_insert(self, *args)

    def reserve(self, n: "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::size_type") -> "void":
        return _tesseract_collision_python.ContactResultVector_reserve(self, n)

    def capacity(self) -> "std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >::size_type":
        return _tesseract_collision_python.ContactResultVector_capacity(self)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactResultVector

# Register ContactResultVector in _tesseract_collision_python:
_tesseract_collision_python.ContactResultVector_swigregister(ContactResultVector)

class ContactResultMap(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.ContactResultMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_collision_python.ContactResultMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_collision_python.ContactResultMap___bool__(self)

    def __len__(self) -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::size_type":
        return _tesseract_collision_python.ContactResultMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "pair_string") -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::mapped_type const &":
        return _tesseract_collision_python.ContactResultMap___getitem__(self, key)

    def __delitem__(self, key: "pair_string") -> "void":
        return _tesseract_collision_python.ContactResultMap___delitem__(self, key)

    def has_key(self, key: "pair_string") -> "bool":
        return _tesseract_collision_python.ContactResultMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_collision_python.ContactResultMap_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_collision_python.ContactResultMap_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_collision_python.ContactResultMap_items(self)

    def __contains__(self, key: "pair_string") -> "bool":
        return _tesseract_collision_python.ContactResultMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.ContactResultMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_collision_python.ContactResultMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_collision_python.ContactResultMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_collision_python.ContactResultMap_asdict(self)

    def __init__(self, *args):
        _tesseract_collision_python.ContactResultMap_swiginit(self, _tesseract_collision_python.new_ContactResultMap(*args))

    def empty(self) -> "bool":
        return _tesseract_collision_python.ContactResultMap_empty(self)

    def size(self) -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::size_type":
        return _tesseract_collision_python.ContactResultMap_size(self)

    def swap(self, v: "ContactResultMap") -> "void":
        return _tesseract_collision_python.ContactResultMap_swap(self, v)

    def begin(self) -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::iterator":
        return _tesseract_collision_python.ContactResultMap_begin(self)

    def end(self) -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::iterator":
        return _tesseract_collision_python.ContactResultMap_end(self)

    def rbegin(self) -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::reverse_iterator":
        return _tesseract_collision_python.ContactResultMap_rbegin(self)

    def rend(self) -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::reverse_iterator":
        return _tesseract_collision_python.ContactResultMap_rend(self)

    def clear(self) -> "void":
        return _tesseract_collision_python.ContactResultMap_clear(self)

    def get_allocator(self) -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::allocator_type":
        return _tesseract_collision_python.ContactResultMap_get_allocator(self)

    def count(self, x: "pair_string") -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::size_type":
        return _tesseract_collision_python.ContactResultMap_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_collision_python.ContactResultMap_erase(self, *args)

    def find(self, x: "pair_string") -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::iterator":
        return _tesseract_collision_python.ContactResultMap_find(self, x)

    def lower_bound(self, x: "pair_string") -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::iterator":
        return _tesseract_collision_python.ContactResultMap_lower_bound(self, x)

    def upper_bound(self, x: "pair_string") -> "std::map< std::pair< std::string,std::string >,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > >,std::less< std::pair< std::string,std::string > >,Eigen::aligned_allocator< std::pair< std::pair< std::string,std::string > const,std::vector< tesseract_collision::ContactResult,Eigen::aligned_allocator< tesseract_collision::ContactResult > > > > >::iterator":
        return _tesseract_collision_python.ContactResultMap_upper_bound(self, x)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactResultMap

# Register ContactResultMap in _tesseract_collision_python:
_tesseract_collision_python.ContactResultMap_swigregister(ContactResultMap)

ContinuousCollisionType_CCType_None = _tesseract_collision_python.ContinuousCollisionType_CCType_None
ContinuousCollisionType_CCType_Time0 = _tesseract_collision_python.ContinuousCollisionType_CCType_Time0
ContinuousCollisionType_CCType_Time1 = _tesseract_collision_python.ContinuousCollisionType_CCType_Time1
ContinuousCollisionType_CCType_Between = _tesseract_collision_python.ContinuousCollisionType_CCType_Between
ContactTestType_FIRST = _tesseract_collision_python.ContactTestType_FIRST
r""" Return at first contact for any pair of objects"""
ContactTestType_CLOSEST = _tesseract_collision_python.ContactTestType_CLOSEST
r""" Return the global minimum for a pair of objects"""
ContactTestType_ALL = _tesseract_collision_python.ContactTestType_ALL
r""" Return all contacts for a pair of objects"""
ContactTestType_LIMITED = _tesseract_collision_python.ContactTestType_LIMITED
r""" Return limited set of contacts for a pair of objects"""
class ContactResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    distance = property(_tesseract_collision_python.ContactResult_distance_get, _tesseract_collision_python.ContactResult_distance_set, doc=r""" The distance between two links""")
    type_id = property(_tesseract_collision_python.ContactResult_type_id_get, _tesseract_collision_python.ContactResult_type_id_set, doc=r""" A user defined type id that is added to the contact shapes""")
    link_names = property(_tesseract_collision_python.ContactResult_link_names_get, _tesseract_collision_python.ContactResult_link_names_set, doc=r""" The two links that are in contact""")
    shape_id = property(_tesseract_collision_python.ContactResult_shape_id_get, _tesseract_collision_python.ContactResult_shape_id_set, doc=r""" The two shapes that are in contact. Each link can be made up of multiple shapes""")
    subshape_id = property(_tesseract_collision_python.ContactResult_subshape_id_get, _tesseract_collision_python.ContactResult_subshape_id_set, doc=r""" Some shapes like octomap and mesh have subshape (boxes and triangles)""")
    nearest_points = property(_tesseract_collision_python.ContactResult_nearest_points_get, _tesseract_collision_python.ContactResult_nearest_points_set, doc=r""" The nearest point on both links in world coordinates""")
    nearest_points_local = property(_tesseract_collision_python.ContactResult_nearest_points_local_get, _tesseract_collision_python.ContactResult_nearest_points_local_set, doc=r""" The nearest point on both links in local(link) coordinates""")
    transform = property(_tesseract_collision_python.ContactResult_transform_get, _tesseract_collision_python.ContactResult_transform_set, doc=r""" The transform of link in world coordinates""")
    normal = property(_tesseract_collision_python.ContactResult_normal_get, _tesseract_collision_python.ContactResult_normal_set, doc=r"""
    The normal vector to move the two objects out of contact in world coordinates

    Notes: This points from link_name[0] to link_name[1], so it shows the direction to move link_name[1] to avoid or get
          out of collision with link_name[0].
    """)
    cc_time = property(_tesseract_collision_python.ContactResult_cc_time_get, _tesseract_collision_python.ContactResult_cc_time_set, doc=r""" This is between 0 and 1 indicating the point of contact""")
    cc_type = property(_tesseract_collision_python.ContactResult_cc_type_get, _tesseract_collision_python.ContactResult_cc_type_set, doc=r""" The type of continuous contact""")
    cc_transform = property(_tesseract_collision_python.ContactResult_cc_transform_get, _tesseract_collision_python.ContactResult_cc_transform_set, doc=r"""
     The transform of link in world coordinates at its desired final location.
    Note: This is not the location of the link at the point of contact but the final location the link when performing
          continuous collision checking. If you desire the location of contact use cc_time and interpolate between
          transform and cc_transform;
    """)
    single_contact_point = property(_tesseract_collision_python.ContactResult_single_contact_point_get, _tesseract_collision_python.ContactResult_single_contact_point_set, doc=r"""
     Some collision checkers only provide a single contact point for a given pair. This is used to indicate
    if only one contact point is provided which means nearest_points[0] must equal nearest_points[1].
    """)

    def __init__(self):
        _tesseract_collision_python.ContactResult_swiginit(self, _tesseract_collision_python.new_ContactResult())

    def clear(self) -> "void":
        r""" reset to default values"""
        return _tesseract_collision_python.ContactResult_clear(self)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactResult

# Register ContactResult in _tesseract_collision_python:
_tesseract_collision_python.ContactResult_swigregister(ContactResult)
cvar = _tesseract_collision_python.cvar
ContactTestTypeStrings = cvar.ContactTestTypeStrings

class ContactRequest(object, metaclass=_SwigNonDynamicMeta):
    r""" The ContactRequest struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    type = property(_tesseract_collision_python.ContactRequest_type_get, _tesseract_collision_python.ContactRequest_type_set, doc=r""" This controls the exit condition for the contact test type""")
    calculate_penetration = property(_tesseract_collision_python.ContactRequest_calculate_penetration_get, _tesseract_collision_python.ContactRequest_calculate_penetration_set, doc=r""" This enables the calculation of penetration contact data if two objects are in collision""")
    calculate_distance = property(_tesseract_collision_python.ContactRequest_calculate_distance_get, _tesseract_collision_python.ContactRequest_calculate_distance_set, doc=r""" This enables the calculation of distance data if two objects are within the contact threshold""")
    contact_limit = property(_tesseract_collision_python.ContactRequest_contact_limit_get, _tesseract_collision_python.ContactRequest_contact_limit_set, doc=r"""
     This is used if the ContactTestType is set to LIMITED, where the test will exit when number of contacts
    reach this limit
    """)
    is_valid = property(_tesseract_collision_python.ContactRequest_is_valid_get, _tesseract_collision_python.ContactRequest_is_valid_set, doc=r""" This provides a user defined function approve/reject contact results""")

    def __init__(self, *args):
        _tesseract_collision_python.ContactRequest_swiginit(self, _tesseract_collision_python.new_ContactRequest(*args))
    __swig_destroy__ = _tesseract_collision_python.delete_ContactRequest

# Register ContactRequest in _tesseract_collision_python:
_tesseract_collision_python.ContactRequest_swigregister(ContactRequest)


def flattenMoveResults(m: "ContactResultMap", v: "ContactResultVector") -> "std::size_t":
    return _tesseract_collision_python.flattenMoveResults(m, v)

def flattenCopyResults(m: "ContactResultMap", v: "ContactResultVector") -> "std::size_t":
    return _tesseract_collision_python.flattenCopyResults(m, v)

def flattenResults(m: "ContactResultMap", v: "ContactResultVector") -> "std::size_t":
    return _tesseract_collision_python.flattenResults(m, v)
CollisionEvaluatorType_NONE = _tesseract_collision_python.CollisionEvaluatorType_NONE
r""" None"""
CollisionEvaluatorType_DISCRETE = _tesseract_collision_python.CollisionEvaluatorType_DISCRETE
r""" Discrete contact manager using only steps specified"""
CollisionEvaluatorType_LVS_DISCRETE = _tesseract_collision_python.CollisionEvaluatorType_LVS_DISCRETE
r""" Discrete contact manager interpolating using longest valid segment"""
CollisionEvaluatorType_CONTINUOUS = _tesseract_collision_python.CollisionEvaluatorType_CONTINUOUS
r""" Continuous contact manager using only steps specified"""
CollisionEvaluatorType_LVS_CONTINUOUS = _tesseract_collision_python.CollisionEvaluatorType_LVS_CONTINUOUS
r""" Continuous contact manager interpolating using longest valid segment"""
ACMOverrideType_NONE = _tesseract_collision_python.ACMOverrideType_NONE
r""" Do not apply AllowedCollisionMatrix"""
ACMOverrideType_ASSIGN = _tesseract_collision_python.ACMOverrideType_ASSIGN
r""" Replace the current IsContactAllowedFn with one generated from the ACM provided"""
ACMOverrideType_AND = _tesseract_collision_python.ACMOverrideType_AND
r""" New IsContactAllowedFn combines the contact manager fn and the ACM generated fn with and AND"""
ACMOverrideType_OR = _tesseract_collision_python.ACMOverrideType_OR
r""" New IsContactAllowedFn combines the contact manager fn and the ACM generated fn with and OR"""
class ContactManagerConfig(object, metaclass=_SwigNonDynamicMeta):
    r"""
    Contains parameters used to configure a contact manager before a series of contact checks.

    It should not contain information that is usually specific to a single contactTest such as CollisionObjectTransforms
    or specific to the way contactTests are carried out such as LVS parameters

    Notes: Active links were not added to this config since this config could be shared by multiple manipulators, and
    those are set based on which one is being checked
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.ContactManagerConfig_swiginit(self, _tesseract_collision_python.new_ContactManagerConfig(*args))
    margin_data_override_type = property(_tesseract_collision_python.ContactManagerConfig_margin_data_override_type_get, _tesseract_collision_python.ContactManagerConfig_margin_data_override_type_set, doc=r""" Identify how the collision margin data should be applied to the contact manager""")
    margin_data = property(_tesseract_collision_python.ContactManagerConfig_margin_data_get, _tesseract_collision_python.ContactManagerConfig_margin_data_set, doc=r""" Stores information about how the margins allowed between collision objects""")
    acm = property(_tesseract_collision_python.ContactManagerConfig_acm_get, _tesseract_collision_python.ContactManagerConfig_acm_set, doc=r""" Additional AllowedCollisionMatrix to consider for this collision check.""")
    acm_override_type = property(_tesseract_collision_python.ContactManagerConfig_acm_override_type_get, _tesseract_collision_python.ContactManagerConfig_acm_override_type_set, doc=r""" Specifies how to combine the IsContactAllowedFn from acm with the one preset in the contact manager""")
    modify_object_enabled = property(_tesseract_collision_python.ContactManagerConfig_modify_object_enabled_get, _tesseract_collision_python.ContactManagerConfig_modify_object_enabled_set, doc=r"""
     Each key is an object name. Objects will be enabled/disabled based on the value. Objects that aren't in the
    map are unmodified from the defaults
    """)
    __swig_destroy__ = _tesseract_collision_python.delete_ContactManagerConfig

# Register ContactManagerConfig in _tesseract_collision_python:
_tesseract_collision_python.ContactManagerConfig_swigregister(ContactManagerConfig)

class CollisionCheckConfig(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This is a high level structure containing common information that collision checking utilities need. The goal
    of this config is to allow all collision checking utilities and planners to use the same data structure
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_collision_python.CollisionCheckConfig_swiginit(self, _tesseract_collision_python.new_CollisionCheckConfig(*args))
    contact_manager_config = property(_tesseract_collision_python.CollisionCheckConfig_contact_manager_config_get, _tesseract_collision_python.CollisionCheckConfig_contact_manager_config_set, doc=r""" Used to configure the contact manager prior to a series of checks""")
    contact_request = property(_tesseract_collision_python.CollisionCheckConfig_contact_request_get, _tesseract_collision_python.CollisionCheckConfig_contact_request_set, doc=r""" ContactRequest that will be used for this check. Default test type: FIRST""")
    type = property(_tesseract_collision_python.CollisionCheckConfig_type_get, _tesseract_collision_python.CollisionCheckConfig_type_set, doc=r""" Specifies the type of collision check to be performed. Default: DISCRETE""")
    longest_valid_segment_length = property(_tesseract_collision_python.CollisionCheckConfig_longest_valid_segment_length_get, _tesseract_collision_python.CollisionCheckConfig_longest_valid_segment_length_set, doc=r""" Longest valid segment to use if type supports lvs. Default: 0.005""")
    __swig_destroy__ = _tesseract_collision_python.delete_CollisionCheckConfig

# Register CollisionCheckConfig in _tesseract_collision_python:
_tesseract_collision_python.CollisionCheckConfig_swigregister(CollisionCheckConfig)

class DiscreteContactManager(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_DiscreteContactManager

    def getName(self) -> "std::string":
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.DiscreteContactManager_getName(self)

    def clone(self) -> "tesseract_collision::DiscreteContactManager::UPtr":
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.DiscreteContactManager_clone(self)

    def addCollisionObject(self, name: "std::string const &", mask_id: "int const &", shapes: "GeometriesConst", shape_poses: "VectorIsometry3d", enabled: "bool"=True) -> "bool":
        r"""
        Add a object to the checker
        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManager_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name: "std::string const &") -> "tesseract_collision::CollisionShapesConst const &":
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name: "std::string const &") -> "tesseract_common::VectorIsometry3d const &":
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManager_hasCollisionObject(self, name)

    def removeCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.DiscreteContactManager_removeCollisionObject(self, name)

    def enableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManager_enableCollisionObject(self, name)

    def disableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.DiscreteContactManager_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name: "std::string const &") -> "bool":
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.DiscreteContactManager_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args) -> "void":
        r"""
        *Overload 1:*

        Set a single collision object's transforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The transformation in world

        |

        *Overload 2:*

        Set a series of collision object's transforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The transformation in world

        |

        *Overload 3:*

        Set a series of collision object's transforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>
        """
        return _tesseract_collision_python.DiscreteContactManager_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names: "vector_string") -> "void":
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManager_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.DiscreteContactManager_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args) -> "void":
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.DiscreteContactManager_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin: "double") -> "void":
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.DiscreteContactManager_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1: "std::string const &", name2: "std::string const &", collision_margin: "double") -> "void":
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.DiscreteContactManager_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self) -> "tesseract_collision::CollisionMarginData const &":
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.DiscreteContactManager_getCollisionMarginData(self)

    def setIsContactAllowedFn(self, fn: "tesseract_collision::IsContactAllowedFn") -> "void":
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.DiscreteContactManager_setIsContactAllowedFn(self, fn)

    def contactTest(self, collisions: "ContactResultMap", request: "ContactRequest") -> "void":
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The contact results data
        :type request: :py:class:`ContactRequest`
        :param request: The contact request data
        """
        return _tesseract_collision_python.DiscreteContactManager_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config: "ContactManagerConfig") -> "void":
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.DiscreteContactManager_applyContactManagerConfig(self, config)

# Register DiscreteContactManager in _tesseract_collision_python:
_tesseract_collision_python.DiscreteContactManager_swigregister(DiscreteContactManager)

class ContinuousContactManager(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_ContinuousContactManager

    def getName(self) -> "std::string":
        r"""
        Get the name of the contact manager
        :rtype: string
        :return: The name
        """
        return _tesseract_collision_python.ContinuousContactManager_getName(self)

    def clone(self) -> "tesseract_collision::ContinuousContactManager::UPtr":
        r"""
        Clone the manager

        This is to be used for multi threaded application. A user should
        make a clone for each thread.
        """
        return _tesseract_collision_python.ContinuousContactManager_clone(self)

    def addCollisionObject(self, name: "std::string const &", mask_id: "int const &", shapes: "GeometriesConst", shape_poses: "VectorIsometry3d", enabled: "bool"=True) -> "bool":
        r"""
        Add a collision object to the checker

        All objects are added should initially be added as static objects. Use the
        setContactRequest method of defining which collision objects are moving.

        :type name: string
        :param name:            The name of the object, must be unique.
        :type mask_id: int
        :param mask_id:         User defined id which gets stored in the results structure.
        :type shapes: :py:class:`CollisionShapesConst`
        :param shapes:          A vector of shapes that make up the collision object.
        :type shape_poses: :py:class:`VectorIsometry3d`
        :param shape_poses:     A vector of poses for each shape, must be same length as shapes
        :param shape_types:     A vector of shape types for encode the collision object. If the vector is of length 1 it is
            used for all shapes.
        :param collision_object_types: A int identifying a conversion mode for the object. (ex. convert meshes to
            convex_hulls)
        :type enabled: boolean, optional
        :param enabled:         Indicate if the object is enabled for collision checking.
        :rtype: boolean
        :return: true if successfully added, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManager_addCollisionObject(self, name, mask_id, shapes, shape_poses, enabled)

    def getCollisionObjectGeometries(self, name: "std::string const &") -> "tesseract_collision::CollisionShapesConst const &":
        r"""
        Get a collision objects collision geometries
        :type name: string
        :param name: The collision objects name
        :rtype: :py:class:`CollisionShapesConst`
        :return: A vector of collision geometries. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionObjectGeometries(self, name)

    def getCollisionObjectGeometriesTransforms(self, name: "std::string const &") -> "tesseract_common::VectorIsometry3d const &":
        r"""
        Get a collision objects collision geometries transforms
        :type name: string
        :param name:  The collision objects name
        :rtype: :py:class:`VectorIsometry3d`
        :return: A vector of collision geometries transforms. The vector will be empty if the collision object is not found.
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionObjectGeometriesTransforms(self, name)

    def hasCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Find if a collision object already exists
        :type name: string
        :param name: The name of the collision object
        :rtype: boolean
        :return: true if it exists, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManager_hasCollisionObject(self, name)

    def removeCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Remove an object from the checker
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: true if successfully removed, otherwise false.
        """
        return _tesseract_collision_python.ContinuousContactManager_removeCollisionObject(self, name)

    def enableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Enable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManager_enableCollisionObject(self, name)

    def disableCollisionObject(self, name: "std::string const &") -> "bool":
        r"""
        Disable an object
        :type name: string
        :param name: The name of the object
        """
        return _tesseract_collision_python.ContinuousContactManager_disableCollisionObject(self, name)

    def isCollisionObjectEnabled(self, name: "std::string const &") -> "bool":
        r"""
        Check if collision object is enabled
        :type name: string
        :param name: The name of the object
        :rtype: boolean
        :return: True if enabled, otherwise false
        """
        return _tesseract_collision_python.ContinuousContactManager_isCollisionObjectEnabled(self, name)

    def setCollisionObjectsTransform(self, *args) -> "void":
        r"""
        *Overload 1:*

        Set a single static collision object's tansforms
        :type name: string
        :param name: The name of the object
        :type pose: :py:class:`Isometry3d`
        :param pose: The tranformation in world

        |

        *Overload 2:*

        Set a series of static collision object's tranforms
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type poses: :py:class:`VectorIsometry3d`
        :param poses: The tranformation in world

        |

        *Overload 3:*

        Set a series of static collision object's tranforms
        :type transforms: :py:class:`TransformMap`
        :param transforms: A transform map <name, pose>

        |

        *Overload 4:*

        Set a single cast(moving) collision object's tansforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type name: string
        :param name: The name of the object
        :type pose1: :py:class:`Isometry3d`
        :param pose1: The start tranformation in world
        :type pose2: :py:class:`Isometry3d`
        :param pose2: The end tranformation in world

        |

        *Overload 5:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: The name of the object
        :type pose1: :py:class:`VectorIsometry3d`
        :param pose1: The start tranformations in world
        :type pose2: :py:class:`VectorIsometry3d`
        :param pose2: The end tranformations in world

        |

        *Overload 6:*

        Set a series of cast(moving) collision object's tranforms

        This should only be used for moving objects. Use the base
        class methods for static objects.

        :type pose1: :py:class:`TransformMap`
        :param pose1: A start transform map <name, pose>
        :type pose2: :py:class:`TransformMap`
        :param pose2: A end transform map <name, pose>
        """
        return _tesseract_collision_python.ContinuousContactManager_setCollisionObjectsTransform(self, *args)

    def getCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get all collision objects
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionObjects(self)

    def setActiveCollisionObjects(self, names: "vector_string") -> "void":
        r"""
        Set which collision objects can move
        :type names: std::vector< std::string,std::allocator< std::string > >
        :param names: A vector of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManager_setActiveCollisionObjects(self, names)

    def getActiveCollisionObjects(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""
        Get which collision objects can move
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of collision object names
        """
        return _tesseract_collision_python.ContinuousContactManager_getActiveCollisionObjects(self)

    def setCollisionMarginData(self, *args) -> "void":
        r"""
        Set the contact distance thresholds for which collision should be considered on a per pair basis
        :type collision_margin_data: :py:class:`CollisionMarginData`
        :param collision_margin_data: Contains the data that will replace the current settings
        :type override_type: int, optional
        :param override_type: This determines how the provided CollisionMarginData is applied
        """
        return _tesseract_collision_python.ContinuousContactManager_setCollisionMarginData(self, *args)

    def setDefaultCollisionMarginData(self, default_collision_margin: "double") -> "void":
        r"""
        Set the default collision margin
        :type default_collision_margin: float
        :param default_collision_margin: New default collision margin
        """
        return _tesseract_collision_python.ContinuousContactManager_setDefaultCollisionMarginData(self, default_collision_margin)

    def setPairCollisionMarginData(self, name1: "std::string const &", name2: "std::string const &", collision_margin: "double") -> "void":
        r"""
        Set the margin for a given contact pair

        The order of the object names does not matter, that is handled internal to
        the class.

        :param obj1: The first object name. Order doesn't matter
        :param obj2: The Second object name. Order doesn't matter
        :type collision_margin: float
        :param collision_margin: contacts with distance < collision_margin are considered in collision
        """
        return _tesseract_collision_python.ContinuousContactManager_setPairCollisionMarginData(self, name1, name2, collision_margin)

    def getCollisionMarginData(self) -> "tesseract_collision::CollisionMarginData const &":
        r"""
        Get the contact distance threshold
        :rtype: :py:class:`CollisionMarginData`
        :return: The contact distance
        """
        return _tesseract_collision_python.ContinuousContactManager_getCollisionMarginData(self)

    def setIsContactAllowedFn(self, fn: "tesseract_collision::IsContactAllowedFn") -> "void":
        r""" Set the active function for determining if two links are allowed to be in collision"""
        return _tesseract_collision_python.ContinuousContactManager_setIsContactAllowedFn(self, fn)

    def contactTest(self, collisions: "ContactResultMap", request: "ContactRequest") -> "void":
        r"""
        Perform a contact test for all objects based
        :type collisions: :py:class:`ContactResultMap`
        :param collisions: The Contact results data
        :param type: The type of contact test
        """
        return _tesseract_collision_python.ContinuousContactManager_contactTest(self, collisions, request)

    def applyContactManagerConfig(self, config: "ContactManagerConfig") -> "void":
        r"""
        Applies settings in the config
        :type config: :py:class:`ContactManagerConfig`
        :param config: Settings to be applies
        """
        return _tesseract_collision_python.ContinuousContactManager_applyContactManagerConfig(self, config)

# Register ContinuousContactManager in _tesseract_collision_python:
_tesseract_collision_python.ContinuousContactManager_swigregister(ContinuousContactManager)

class DiscreteContactManagerFactory(object, metaclass=_SwigNonDynamicMeta):
    r""" Define a discrete contact manager plugin which the factory can create an instance"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_DiscreteContactManagerFactory

    def create(self, name: "std::string const &", config: "YAML::Node const &") -> "tesseract_collision::DiscreteContactManager::UPtr":
        r"""
        Create Discrete Contact Manager Object
        :type name: string
        :param name: The name of the contact manager object
        :rtype: :py:class:`UPtr`
        :return: If failed to create, nullptr is returned.
        """
        return _tesseract_collision_python.DiscreteContactManagerFactory_create(self, name, config)

# Register DiscreteContactManagerFactory in _tesseract_collision_python:
_tesseract_collision_python.DiscreteContactManagerFactory_swigregister(DiscreteContactManagerFactory)

class ContinuousContactManagerFactory(object, metaclass=_SwigNonDynamicMeta):
    r""" Define a continuous contact manager plugin which the factory can create an instance"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_ContinuousContactManagerFactory

    def create(self, solver_name: "std::string const &", config: "YAML::Node const &") -> "tesseract_collision::ContinuousContactManager::UPtr":
        r"""
        Create Inverse Kinematics Object
        :param name: The name of the contact manager object
        :rtype: :py:class:`UPtr`
        :return: If failed to create, nullptr is returned.
        """
        return _tesseract_collision_python.ContinuousContactManagerFactory_create(self, solver_name, config)

# Register ContinuousContactManagerFactory in _tesseract_collision_python:
_tesseract_collision_python.ContinuousContactManagerFactory_swigregister(ContinuousContactManagerFactory)

class ContactManagersPluginFactory(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_collision_python.delete_ContactManagersPluginFactory

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Load plugins from yaml node
        :type config: YAML::Node
        :param config: The config node

        |

        *Overload 2:*

        Load plugins from file path
        :type config: :py:class:`path`
        :param config: The config file path

        |

        *Overload 3:*

        Load plugins from string
        :type config: string
        :param config: The config string
        """
        _tesseract_collision_python.ContactManagersPluginFactory_swiginit(self, _tesseract_collision_python.new_ContactManagersPluginFactory(*args))

    def addSearchPath(self, path: "std::string const &") -> "void":
        r"""
        Add location for the plugin loader to search
        :type path: string
        :param path: The full path to the directory
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addSearchPath(self, path)

    def getSearchPaths(self) -> "std::set< std::string,std::less< std::string >,std::allocator< std::string > >":
        r"""
        Get the plugin search paths
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search paths
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getSearchPaths(self)

    def clearSearchPaths(self) -> "void":
        r"""Clear the search paths"""
        return _tesseract_collision_python.ContactManagersPluginFactory_clearSearchPaths(self)

    def addSearchLibrary(self, library_name: "std::string const &") -> "void":
        r"""
        Add a library to search for plugin name
        :type library_name: string
        :param library_name: The library name without the prefix or suffix
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addSearchLibrary(self, library_name)

    def getSearchLibraries(self) -> "std::set< std::string,std::less< std::string >,std::allocator< std::string > >":
        r"""
        Get the plugin search libraries
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: The search libraries
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getSearchLibraries(self)

    def clearSearchLibraries(self) -> "void":
        r"""Clean the search libraries"""
        return _tesseract_collision_python.ContactManagersPluginFactory_clearSearchLibraries(self)

    def addDiscreteContactManagerPlugin(self, name: "std::string const &", plugin_info: "PluginInfo") -> "void":
        r"""
        Add a discrete contact manager plugin
        :type name: string
        :param name: The name
        :type plugin_info: :py:class:`PluginInfo`
        :param plugin_info: The plugin information
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addDiscreteContactManagerPlugin(self, name, plugin_info)

    def hasDiscreteContactManagerPlugins(self) -> "bool":
        r"""
        Check if it has discrete contact manager plugins
        :rtype: boolean
        :return: True if discrete PluginInfoMap is not empty, otherwise fale
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_hasDiscreteContactManagerPlugins(self)

    def getDiscreteContactManagerPlugins(self) -> "tesseract_common::PluginInfoMap":
        r"""
        Get the map of discrete contact manager plugin
        :rtype: :py:class:`PluginInfoMap`
        :return: A map of plugins
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getDiscreteContactManagerPlugins(self)

    def removeDiscreteContactManagerPlugin(self, name: "std::string const &") -> "void":
        r"""
        Remove discrete contact manager plugin
        :type name: string
        :param name: The name of the contact manager to remove
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_removeDiscreteContactManagerPlugin(self, name)

    def setDefaultDiscreteContactManagerPlugin(self, name: "std::string const &") -> "void":
        r"""
        Set a default discrete contact manager
        :type name: string
        :param name: The name
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_setDefaultDiscreteContactManagerPlugin(self, name)

    def getDefaultDiscreteContactManagerPlugin(self) -> "std::string":
        r"""
        Get the default discrete contact manager
        :rtype: string
        :return: The default discrete contact manager
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getDefaultDiscreteContactManagerPlugin(self)

    def addContinuousContactManagerPlugin(self, name: "std::string const &", plugin_info: "PluginInfo") -> "void":
        r"""
        Add a continuous contact manager plugin
        :type name: string
        :param name: The name
        :type plugin_info: :py:class:`PluginInfo`
        :param plugin_info: The plugin information
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_addContinuousContactManagerPlugin(self, name, plugin_info)

    def hasContinuousContactManagerPlugins(self) -> "bool":
        r"""
        Check if it has continuous contact manager plugins
        :rtype: boolean
        :return: True if continuous PluginInfoMap is not empty, otherwise fale
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_hasContinuousContactManagerPlugins(self)

    def getContinuousContactManagerPlugins(self) -> "tesseract_common::PluginInfoMap":
        r"""
        Get the map of continuous contact manager plugin
        :rtype: :py:class:`PluginInfoMap`
        :return: A map of plugins
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getContinuousContactManagerPlugins(self)

    def removeContinuousContactManagerPlugin(self, name: "std::string const &") -> "void":
        r"""
        Remove continuous contact manager plugin
        :type name: string
        :param name: The name of the contact manager to remove
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_removeContinuousContactManagerPlugin(self, name)

    def setDefaultContinuousContactManagerPlugin(self, name: "std::string const &") -> "void":
        r"""
        Set a default continuous contact manager
        :type name: string
        :param name: The name
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_setDefaultContinuousContactManagerPlugin(self, name)

    def getDefaultContinuousContactManagerPlugin(self) -> "std::string":
        r"""
        Get the default continuous contact manager
        :rtype: string
        :return: The default continuous contact manager name
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getDefaultContinuousContactManagerPlugin(self)

    def createDiscreteContactManager(self, *args) -> "tesseract_collision::DiscreteContactManager::UPtr":
        r"""
        *Overload 1:*

        Get discrete contact manager object given name
        This looks for discrete contact manager plugin info. If not found nullptr is returned.
        :type name: string
        :param name: The name

        |

        *Overload 2:*

        Get discrete contact manager object given plugin info
        :type name: string
        :param name: The name
        :type plugin_info: :py:class:`PluginInfo`
        :param plugin_info: The plugin information to create kinematics object
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_createDiscreteContactManager(self, *args)

    def createContinuousContactManager(self, *args) -> "tesseract_collision::ContinuousContactManager::UPtr":
        r"""
        *Overload 1:*

        Get continuous contact manager object given name
        This looks for continuous contact manager plugin info. If not found nullptr is returned.
        :type name: string
        :param name: The name

        |

        *Overload 2:*

        Get continuous contact manager object given plugin info
        :type name: string
        :param name: The name
        :type plugin_info: :py:class:`PluginInfo`
        :param plugin_info: The plugin information to create kinematics object
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_createContinuousContactManager(self, *args)

    def saveConfig(self, file_path: "FilesystemPath") -> "void":
        r"""
        Save the plugin information to a yaml config file
        :type file_path: :py:class:`path`
        :param file_path: The file path
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_saveConfig(self, file_path)

    def getConfig(self) -> "YAML::Node":
        r"""
        Get the plugin information config as a yaml node
        :rtype: YAML::Node
        :return: The plugin information config yaml node/
        """
        return _tesseract_collision_python.ContactManagersPluginFactory_getConfig(self)

# Register ContactManagersPluginFactory in _tesseract_collision_python:
_tesseract_collision_python.ContactManagersPluginFactory_swigregister(ContactManagersPluginFactory)



