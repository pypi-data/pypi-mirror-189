# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_process_managers_python
else:
    import _tesseract_process_managers_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_process_managers_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_process_managers_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_process_managers_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_process_managers_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_process_managers_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_process_managers_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_process_managers_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_process_managers_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_process_managers_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_process_managers_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_process_managers_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_process_managers_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_process_managers_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_process_managers_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_process_managers_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_process_managers_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_process_managers_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_process_managers_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_process_managers_python:
_tesseract_process_managers_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_process_managers_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_process_managers_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_process_managers_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_process_managers_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_process_managers_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_process_managers_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_process_managers_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_process_managers_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_process_managers_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_process_managers_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_process_managers_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_process_managers_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_process_managers_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_process_managers_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_process_managers_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_process_managers_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_process_managers_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_process_managers_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_process_managers_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_process_managers_python.vector_eigen_index_swiginit(self, _tesseract_process_managers_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_process_managers_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_process_managers_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_process_managers_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_process_managers_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_process_managers_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_process_managers_python:
_tesseract_process_managers_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_motion_planners_simple.tesseract_motion_planners_simple_python
import tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python
import tesseract_robotics.tesseract_environment.tesseract_environment_python
import tesseract_robotics.tesseract_kinematics.tesseract_kinematics_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
import tesseract_robotics.tesseract_collision.tesseract_collision_python
import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
import tesseract_robotics.tesseract_motion_planners_trajopt.tesseract_motion_planners_trajopt_python
import tesseract_robotics.tesseract_motion_planners_ompl.tesseract_motion_planners_ompl_python
import tesseract_robotics.tesseract_motion_planners_descartes.tesseract_motion_planners_descartes_python
import tesseract_robotics.tesseract_time_parameterization.tesseract_time_parameterization_python
class EnvironmentCache(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_process_managers_python.delete_EnvironmentCache

    def setCacheSize(self, size: "long") -> "void":
        r"""
        Set the cache size used to hold tesseract objects for motion planning
        :type size: int
        :param size: The size of the cache.
        """
        return _tesseract_process_managers_python.EnvironmentCache_setCacheSize(self, size)

    def getCacheSize(self) -> "long":
        r"""
        Get the cache size used to hold tesseract objects for motion planning
        :rtype: int
        :return: The size of the cache.
        """
        return _tesseract_process_managers_python.EnvironmentCache_getCacheSize(self)

    def refreshCache(self) -> "void":
        r""" If the environment has changed it will rebuild the cache of tesseract objects"""
        return _tesseract_process_managers_python.EnvironmentCache_refreshCache(self)

    def getCachedEnvironment(self) -> "tesseract_environment::Environment::UPtr":
        r"""
        This will pop an Environment object from the queue
        This will first call refreshCache to ensure it has an updated tesseract then proceed
        """
        return _tesseract_process_managers_python.EnvironmentCache_getCachedEnvironment(self)

# Register EnvironmentCache in _tesseract_process_managers_python:
_tesseract_process_managers_python.EnvironmentCache_swigregister(EnvironmentCache)

class ProcessEnvironmentCache(EnvironmentCache):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, env: "tesseract_environment::Environment::ConstPtr", cache_size: "std::size_t"=5):
        _tesseract_process_managers_python.ProcessEnvironmentCache_swiginit(self, _tesseract_process_managers_python.new_ProcessEnvironmentCache(env, cache_size))

    def setCacheSize(self, size: "long") -> "void":
        r"""
        Set the cache size used to hold tesseract objects for motion planning
        :type size: int
        :param size: The size of the cache.
        """
        return _tesseract_process_managers_python.ProcessEnvironmentCache_setCacheSize(self, size)

    def getCacheSize(self) -> "long":
        r"""
        Get the cache size used to hold tesseract objects for motion planning
        :rtype: int
        :return: The size of the cache.
        """
        return _tesseract_process_managers_python.ProcessEnvironmentCache_getCacheSize(self)

    def refreshCache(self) -> "void":
        r""" If the environment has changed it will rebuild the cache of tesseract objects"""
        return _tesseract_process_managers_python.ProcessEnvironmentCache_refreshCache(self)

    def getCachedEnvironment(self) -> "tesseract_environment::Environment::UPtr":
        r"""
        This will pop an Environment object from the queue
        This will first call refreshCache to ensure it has an updated tesseract then proceed
        """
        return _tesseract_process_managers_python.ProcessEnvironmentCache_getCachedEnvironment(self)
    __swig_destroy__ = _tesseract_process_managers_python.delete_ProcessEnvironmentCache

# Register ProcessEnvironmentCache in _tesseract_process_managers_python:
_tesseract_process_managers_python.ProcessEnvironmentCache_swigregister(ProcessEnvironmentCache)

class TaskInfoUPtr(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_process_managers_python.TaskInfoUPtr_swiginit(self, _tesseract_process_managers_python.new_TaskInfoUPtr(*args))

    def __deref__(self) -> "std::unique_ptr< tesseract_planning::TaskInfo >::pointer":
        return _tesseract_process_managers_python.TaskInfoUPtr___deref__(self)

    def release(self) -> "std::unique_ptr< tesseract_planning::TaskInfo >::pointer":
        return _tesseract_process_managers_python.TaskInfoUPtr_release(self)

    def reset(self, *args) -> "void":
        return _tesseract_process_managers_python.TaskInfoUPtr_reset(self, *args)

    def swap(self, __u: "TaskInfoUPtr") -> "void":
        return _tesseract_process_managers_python.TaskInfoUPtr_swap(self, __u)

    def get(self) -> "std::unique_ptr< tesseract_planning::TaskInfo >::pointer":
        return _tesseract_process_managers_python.TaskInfoUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_process_managers_python.TaskInfoUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_process_managers_python.delete_TaskInfoUPtr
    return_value = property(_tesseract_process_managers_python.TaskInfoUPtr_return_value_get, _tesseract_process_managers_python.TaskInfoUPtr_return_value_set, doc=r""" Value returned from the Task on completion""")
    unique_id = property(_tesseract_process_managers_python.TaskInfoUPtr_unique_id_get, _tesseract_process_managers_python.TaskInfoUPtr_unique_id_set, doc=r""" Unique ID generated for the Task by Taskflow""")
    task_name = property(_tesseract_process_managers_python.TaskInfoUPtr_task_name_get, _tesseract_process_managers_python.TaskInfoUPtr_task_name_set)
    message = property(_tesseract_process_managers_python.TaskInfoUPtr_message_get, _tesseract_process_managers_python.TaskInfoUPtr_message_set)
    elapsed_time = property(_tesseract_process_managers_python.TaskInfoUPtr_elapsed_time_get, _tesseract_process_managers_python.TaskInfoUPtr_elapsed_time_set, doc=r""" elapsed_time Time spent in this task in seconds""")
    instructions_input = property(_tesseract_process_managers_python.TaskInfoUPtr_instructions_input_get, _tesseract_process_managers_python.TaskInfoUPtr_instructions_input_set, doc=r""" Instructions passed to task (optionally set)""")
    instructions_output = property(_tesseract_process_managers_python.TaskInfoUPtr_instructions_output_get, _tesseract_process_managers_python.TaskInfoUPtr_instructions_output_set, doc=r""" Instructions after running the task (optionally set)""")
    results_input = property(_tesseract_process_managers_python.TaskInfoUPtr_results_input_get, _tesseract_process_managers_python.TaskInfoUPtr_results_input_set, doc=r""" Seed/Results passed into the task (optionally set)""")
    results_output = property(_tesseract_process_managers_python.TaskInfoUPtr_results_output_get, _tesseract_process_managers_python.TaskInfoUPtr_results_output_set, doc=r""" Seed/Results after running the task (optionally set)""")
    environment = property(_tesseract_process_managers_python.TaskInfoUPtr_environment_get, _tesseract_process_managers_python.TaskInfoUPtr_environment_set, doc=r""" The environment at the beginning of the task (optionally set)""")

    def __eq__(self, rhs: "TaskInfo") -> "bool":
        return _tesseract_process_managers_python.TaskInfoUPtr___eq__(self, rhs)

    def __ne__(self, rhs: "TaskInfo") -> "bool":
        return _tesseract_process_managers_python.TaskInfoUPtr___ne__(self, rhs)

    def clone(self) -> "tesseract_planning::TaskInfo::UPtr":
        return _tesseract_process_managers_python.TaskInfoUPtr_clone(self)

# Register TaskInfoUPtr in _tesseract_process_managers_python:
_tesseract_process_managers_python.TaskInfoUPtr_swigregister(TaskInfoUPtr)

class TaskInfo(object, metaclass=_SwigNonDynamicMeta):
    r""" Stores information about a Task"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_process_managers_python.delete_TaskInfo

    def __init__(self, *args):
        _tesseract_process_managers_python.TaskInfo_swiginit(self, _tesseract_process_managers_python.new_TaskInfo(*args))
    return_value = property(_tesseract_process_managers_python.TaskInfo_return_value_get, _tesseract_process_managers_python.TaskInfo_return_value_set, doc=r""" Value returned from the Task on completion""")
    unique_id = property(_tesseract_process_managers_python.TaskInfo_unique_id_get, _tesseract_process_managers_python.TaskInfo_unique_id_set, doc=r""" Unique ID generated for the Task by Taskflow""")
    task_name = property(_tesseract_process_managers_python.TaskInfo_task_name_get, _tesseract_process_managers_python.TaskInfo_task_name_set)
    message = property(_tesseract_process_managers_python.TaskInfo_message_get, _tesseract_process_managers_python.TaskInfo_message_set)
    elapsed_time = property(_tesseract_process_managers_python.TaskInfo_elapsed_time_get, _tesseract_process_managers_python.TaskInfo_elapsed_time_set, doc=r""" elapsed_time Time spent in this task in seconds""")
    instructions_input = property(_tesseract_process_managers_python.TaskInfo_instructions_input_get, _tesseract_process_managers_python.TaskInfo_instructions_input_set, doc=r""" Instructions passed to task (optionally set)""")
    instructions_output = property(_tesseract_process_managers_python.TaskInfo_instructions_output_get, _tesseract_process_managers_python.TaskInfo_instructions_output_set, doc=r""" Instructions after running the task (optionally set)""")
    results_input = property(_tesseract_process_managers_python.TaskInfo_results_input_get, _tesseract_process_managers_python.TaskInfo_results_input_set, doc=r""" Seed/Results passed into the task (optionally set)""")
    results_output = property(_tesseract_process_managers_python.TaskInfo_results_output_get, _tesseract_process_managers_python.TaskInfo_results_output_set, doc=r""" Seed/Results after running the task (optionally set)""")
    environment = property(_tesseract_process_managers_python.TaskInfo_environment_get, _tesseract_process_managers_python.TaskInfo_environment_set, doc=r""" The environment at the beginning of the task (optionally set)""")

    def __eq__(self, rhs: "TaskInfo") -> "bool":
        return _tesseract_process_managers_python.TaskInfo___eq__(self, rhs)

    def __ne__(self, rhs: "TaskInfo") -> "bool":
        return _tesseract_process_managers_python.TaskInfo___ne__(self, rhs)

    def clone(self) -> "tesseract_planning::TaskInfo::UPtr":
        return _tesseract_process_managers_python.TaskInfo_clone(self)

# Register TaskInfo in _tesseract_process_managers_python:
_tesseract_process_managers_python.TaskInfo_swigregister(TaskInfo)

class TaskInfoContainer(object, metaclass=_SwigNonDynamicMeta):
    r""" A threadsafe container for TaskInfos"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __eq__(self, rhs: "TaskInfoContainer") -> "bool":
        return _tesseract_process_managers_python.TaskInfoContainer___eq__(self, rhs)

    def __ne__(self, rhs: "TaskInfoContainer") -> "bool":
        return _tesseract_process_managers_python.TaskInfoContainer___ne__(self, rhs)

    def __init__(self):
        _tesseract_process_managers_python.TaskInfoContainer_swiginit(self, _tesseract_process_managers_python.new_TaskInfoContainer())
    __swig_destroy__ = _tesseract_process_managers_python.delete_TaskInfoContainer

# Register TaskInfoContainer in _tesseract_process_managers_python:
_tesseract_process_managers_python.TaskInfoContainer_swigregister(TaskInfoContainer)

class TaskflowInterface(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This is a thread safe class used for aborting a process along with checking if a process was successful
    If a process failed then the process has been abort by some child process
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_process_managers_python.delete_TaskflowInterface

    def __init__(self, *args):
        _tesseract_process_managers_python.TaskflowInterface_swiginit(self, _tesseract_process_managers_python.new_TaskflowInterface(*args))

    def isAborted(self) -> "bool":
        r"""
        Check if the process was aborted
        :rtype: boolean
        :return: True if aborted, otherwise false
        """
        return _tesseract_process_managers_python.TaskflowInterface_isAborted(self)

    def isSuccessful(self) -> "bool":
        r"""
        Check if the process finished without error
        :rtype: boolean
        :return: True if the process was not aborted, otherwise false
        """
        return _tesseract_process_managers_python.TaskflowInterface_isSuccessful(self)

    def abort(self) -> "void":
        r""" Abort the process associated with this interface"""
        return _tesseract_process_managers_python.TaskflowInterface_abort(self)

    def getTaskInfo(self, index: "std::size_t const &") -> "tesseract_planning::TaskInfo::UPtr":
        r"""
        Get TaskInfo for a specific task by unique ID
        :type index: int
        :param index: Unique ID assigned the task from taskflow
        :rtype: :py:class:`UPtr`
        :return: The TaskInfo associated with this task
        """
        return _tesseract_process_managers_python.TaskflowInterface_getTaskInfo(self, index)

    def getTaskInfoContainer(self) -> "tesseract_planning::TaskInfoContainer::Ptr":
        r"""
        Not meant to be used by users. Exposes TaskInfoContainer so that the
        :rtype: :py:class:`TaskInfoContainer`
        :return: Threadsafe TaskInfo container
        """
        return _tesseract_process_managers_python.TaskflowInterface_getTaskInfoContainer(self)

    def __eq__(self, rhs: "TaskflowInterface") -> "bool":
        return _tesseract_process_managers_python.TaskflowInterface___eq__(self, rhs)

    def __ne__(self, rhs: "TaskflowInterface") -> "bool":
        return _tesseract_process_managers_python.TaskflowInterface___ne__(self, rhs)

# Register TaskflowInterface in _tesseract_process_managers_python:
_tesseract_process_managers_python.TaskflowInterface_swigregister(TaskflowInterface)

class TaskInput(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This struct is passed as an input to each process in the decision tree

    Note that it does not have ownership of any of its members (except the pointer). This means that if a TaskInput
    spawns a child that is a subset, it does not have to remain in scope as the references will still be valid
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    env = property(_tesseract_process_managers_python.TaskInput_env_get, doc=r""" Tesseract associated with current state of the system""")
    manip_info = property(_tesseract_process_managers_python.TaskInput_manip_info_get, doc=r""" Global Manipulator Information""")
    plan_profile_remapping = property(_tesseract_process_managers_python.TaskInput_plan_profile_remapping_get, doc=r"""
    This allows the remapping of the Plan Profile identified in the command language to a specific profile for a
    given motion planner.
    """)
    composite_profile_remapping = property(_tesseract_process_managers_python.TaskInput_composite_profile_remapping_get, doc=r"""
    This allows the remapping of the Composite Profile identified in the command language to a specific profile
    for a given motion planner.
    """)
    profiles = property(_tesseract_process_managers_python.TaskInput_profiles_get, doc=r""" The Profiles to use""")
    has_seed = property(_tesseract_process_managers_python.TaskInput_has_seed_get, doc=r"""
    This indicates if a seed was provided
    In the case of the raster process planner a skeleton seed is provided which make it
    computationally intensive to determine if a seed was provide so this was added.
    """)

    def size(self) -> "std::size_t":
        r"""
        Gets the number of instructions contained in the TaskInput
        :rtype: int
        :return: 1 instruction if not a composite, otherwise size of the composite TODO: Should this be -1, because
        composite size could be 1, 0, or other?
        """
        return _tesseract_process_managers_python.TaskInput_size(self)

    def getInstruction(self) -> "tesseract_planning::Instruction const *":
        r"""
        Get the process inputs instructions
        :rtype: :py:class:`Instruction`
        :return: A const pointer to the instruction
        """
        return _tesseract_process_managers_python.TaskInput_getInstruction(self)

    def getResults(self) -> "tesseract_planning::Instruction *":
        r"""
        Get the process inputs results instruction
        :rtype: :py:class:`Instruction`
        :return: A pointer to the results instruction
        """
        return _tesseract_process_managers_python.TaskInput_getResults(self)

    def getTaskInterface(self) -> "tesseract_planning::TaskflowInterface::Ptr":
        r"""
        Gets the task interface for checking success and aborting active process
        :rtype: :py:class:`TaskflowInterface`
        :return: The task interface for checking success and aborting active process
        """
        return _tesseract_process_managers_python.TaskInput_getTaskInterface(self)

    def isAborted(self) -> "bool":
        r"""
        Check if process has been aborted
        This accesses the internal process interface class
        :rtype: boolean
        :return: True if aborted otherwise false;
        """
        return _tesseract_process_managers_python.TaskInput_isAborted(self)

    def abort(self) -> "void":
        r"""
        Abort the process input
        This accesses the internal process interface class to abort the process
        """
        return _tesseract_process_managers_python.TaskInput_abort(self)

    def setStartInstruction(self, *args) -> "void":
        return _tesseract_process_managers_python.TaskInput_setStartInstruction(self, *args)

    def getStartInstruction(self) -> "tesseract_planning::Instruction":
        return _tesseract_process_managers_python.TaskInput_getStartInstruction(self)

    def setEndInstruction(self, *args) -> "void":
        return _tesseract_process_managers_python.TaskInput_setEndInstruction(self, *args)

    def getEndInstruction(self) -> "tesseract_planning::Instruction":
        return _tesseract_process_managers_python.TaskInput_getEndInstruction(self)

    def getTaskInfo(self, index: "std::size_t const &") -> "tesseract_planning::TaskInfo::UPtr":
        return _tesseract_process_managers_python.TaskInput_getTaskInfo(self, index)
    save_io = property(_tesseract_process_managers_python.TaskInput_save_io_get, _tesseract_process_managers_python.TaskInput_save_io_set, doc=r""" If true the task will save the inputs and outputs to the TaskInfo""")
    __swig_destroy__ = _tesseract_process_managers_python.delete_TaskInput

# Register TaskInput in _tesseract_process_managers_python:
_tesseract_process_managers_python.TaskInput_swigregister(TaskInput)

class ProcessPlanningProblem(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_process_managers_python.delete_ProcessPlanningProblem

    def __init__(self, *args):
        _tesseract_process_managers_python.ProcessPlanningProblem_swiginit(self, _tesseract_process_managers_python.new_ProcessPlanningProblem(*args))
    name = property(_tesseract_process_managers_python.ProcessPlanningProblem_name_get, _tesseract_process_managers_python.ProcessPlanningProblem_name_set, doc=r""" The name of the Process Pipeline (aka. Taskflow) to use""")
    env = property(_tesseract_process_managers_python.ProcessPlanningProblem_env_get, _tesseract_process_managers_python.ProcessPlanningProblem_env_set, doc=r""" The problem's environment""")
    input = property(_tesseract_process_managers_python.ProcessPlanningProblem_input_get, _tesseract_process_managers_python.ProcessPlanningProblem_input_set, doc=r""" The stored input to the process""")
    results = property(_tesseract_process_managers_python.ProcessPlanningProblem_results_get, _tesseract_process_managers_python.ProcessPlanningProblem_results_set, doc=r""" The results to the process""")

    def __eq__(self, rhs: "ProcessPlanningProblem") -> "bool":
        return _tesseract_process_managers_python.ProcessPlanningProblem___eq__(self, rhs)

    def __ne__(self, rhs: "ProcessPlanningProblem") -> "bool":
        return _tesseract_process_managers_python.ProcessPlanningProblem___ne__(self, rhs)

    def getInput(self) -> "tesseract_planning::Instruction &":
        return _tesseract_process_managers_python.ProcessPlanningProblem_getInput(self)

    def getResults(self) -> "tesseract_planning::Instruction &":
        return _tesseract_process_managers_python.ProcessPlanningProblem_getResults(self)

    def getGlobalManipInfo(self) -> "tesseract_planning::ManipulatorInfo":
        return _tesseract_process_managers_python.ProcessPlanningProblem_getGlobalManipInfo(self)

    def getPlanProfileRemapping(self) -> "tesseract_planning::PlannerProfileRemapping":
        return _tesseract_process_managers_python.ProcessPlanningProblem_getPlanProfileRemapping(self)

    def getCompositeProfileRemapping(self) -> "tesseract_planning::PlannerProfileRemapping":
        return _tesseract_process_managers_python.ProcessPlanningProblem_getCompositeProfileRemapping(self)

# Register ProcessPlanningProblem in _tesseract_process_managers_python:
_tesseract_process_managers_python.ProcessPlanningProblem_swigregister(ProcessPlanningProblem)

class ProcessPlanningRequest(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    executor_name = property(_tesseract_process_managers_python.ProcessPlanningRequest_executor_name_get, _tesseract_process_managers_python.ProcessPlanningRequest_executor_name_set, doc=r""" The name of the executor to use""")
    name = property(_tesseract_process_managers_python.ProcessPlanningRequest_name_get, _tesseract_process_managers_python.ProcessPlanningRequest_name_set, doc=r""" The name of the Process Pipeline (aka. Taskflow) to use""")
    instructions = property(_tesseract_process_managers_python.ProcessPlanningRequest_instructions_get, _tesseract_process_managers_python.ProcessPlanningRequest_instructions_set, doc=r""" This should an xml string of the command language instructions""")
    seed = property(_tesseract_process_managers_python.ProcessPlanningRequest_seed_get, _tesseract_process_managers_python.ProcessPlanningRequest_seed_set, doc=r""" This should an xml string of the command language instructions (Optional)""")
    env_state = property(_tesseract_process_managers_python.ProcessPlanningRequest_env_state_get, _tesseract_process_managers_python.ProcessPlanningRequest_env_state_set, doc=r""" Environment state to start planning with (Optional)""")
    commands = property(_tesseract_process_managers_python.ProcessPlanningRequest_commands_get, _tesseract_process_managers_python.ProcessPlanningRequest_commands_set, doc=r""" Additional Commands to be applied to environment prior to planning (Optional)""")
    profile = property(_tesseract_process_managers_python.ProcessPlanningRequest_profile_get, _tesseract_process_managers_python.ProcessPlanningRequest_profile_set, doc=r""" Enable profiling of the planning request (Optional)""")
    save_io = property(_tesseract_process_managers_python.ProcessPlanningRequest_save_io_get, _tesseract_process_managers_python.ProcessPlanningRequest_save_io_set, doc=r""" Indicate if tasks should store input and output results in the task info""")

    def __eq__(self, rhs: "ProcessPlanningRequest") -> "bool":
        return _tesseract_process_managers_python.ProcessPlanningRequest___eq__(self, rhs)

    def __ne__(self, rhs: "ProcessPlanningRequest") -> "bool":
        return _tesseract_process_managers_python.ProcessPlanningRequest___ne__(self, rhs)

    def __init__(self):
        _tesseract_process_managers_python.ProcessPlanningRequest_swiginit(self, _tesseract_process_managers_python.new_ProcessPlanningRequest())
    __swig_destroy__ = _tesseract_process_managers_python.delete_ProcessPlanningRequest

# Register ProcessPlanningRequest in _tesseract_process_managers_python:
_tesseract_process_managers_python.ProcessPlanningRequest_swigregister(ProcessPlanningRequest)
cvar = _tesseract_process_managers_python.cvar
PRIMARY_EXECUTOR_NAME = cvar.PRIMARY_EXECUTOR_NAME

class ProcessPlanningFuture(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This contains the result for the process planning request
    Must check the status before access the problem results to know if available.
    Notes: This stores a shared future and is copy-able to allow access from multiple threads
    This must not go out of scope until the process has finished
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self):
        _tesseract_process_managers_python.ProcessPlanningFuture_swiginit(self, _tesseract_process_managers_python.new_ProcessPlanningFuture())
    interface = property(_tesseract_process_managers_python.ProcessPlanningFuture_interface_get, _tesseract_process_managers_python.ProcessPlanningFuture_interface_set, doc=r""" This is used to abort the associated process and check if the process was successful""")
    problem = property(_tesseract_process_managers_python.ProcessPlanningFuture_problem_get, _tesseract_process_managers_python.ProcessPlanningFuture_problem_set, doc=r"""
     This contains the problem for the process plan. Do not access until problem results until the future state
    is ready.
    """)

    def clear(self) -> "void":
        r""" Clear all content"""
        return _tesseract_process_managers_python.ProcessPlanningFuture_clear(self)

    def valid(self) -> "bool":
        r""" Checks if the future has a shared state"""
        return _tesseract_process_managers_python.ProcessPlanningFuture_valid(self)

    def ready(self) -> "bool":
        r"""
        This checks if the process has finished
        :rtype: boolean
        :return: True if the process finished, otherwise false
        """
        return _tesseract_process_managers_python.ProcessPlanningFuture_ready(self)

    def wait(self) -> "void":
        r""" Wait until the process has finished"""
        return _tesseract_process_managers_python.ProcessPlanningFuture_wait(self)

    def waitUntil(self, abs: "std::chrono::time_point< std::chrono::high_resolution_clock > const &") -> "std::future_status":
        r"""
        Check if a process has finished up to a given time point
        :rtype: std::future_status
        :return: The future status
        """
        return _tesseract_process_managers_python.ProcessPlanningFuture_waitUntil(self, abs)

    def __eq__(self, rhs: "ProcessPlanningFuture") -> "bool":
        return _tesseract_process_managers_python.ProcessPlanningFuture___eq__(self, rhs)

    def __ne__(self, rhs: "ProcessPlanningFuture") -> "bool":
        return _tesseract_process_managers_python.ProcessPlanningFuture___ne__(self, rhs)

    def waitFor(self, *args) -> "bool":
        return _tesseract_process_managers_python.ProcessPlanningFuture_waitFor(self, *args)
    __swig_destroy__ = _tesseract_process_managers_python.delete_ProcessPlanningFuture

# Register ProcessPlanningFuture in _tesseract_process_managers_python:
_tesseract_process_managers_python.ProcessPlanningFuture_swigregister(ProcessPlanningFuture)
TRAJOPT_PLANNER_NAME = cvar.TRAJOPT_PLANNER_NAME
OMPL_PLANNER_NAME = cvar.OMPL_PLANNER_NAME
DESCARTES_PLANNER_NAME = cvar.DESCARTES_PLANNER_NAME
FREESPACE_PLANNER_NAME = cvar.FREESPACE_PLANNER_NAME
CARTESIAN_PLANNER_NAME = cvar.CARTESIAN_PLANNER_NAME
RASTER_FT_PLANNER_NAME = cvar.RASTER_FT_PLANNER_NAME
RASTER_FT_DT_PLANNER_NAME = cvar.RASTER_FT_DT_PLANNER_NAME
RASTER_FT_WAAD_PLANNER_NAME = cvar.RASTER_FT_WAAD_PLANNER_NAME
RASTER_FT_WAAD_DT_PLANNER_NAME = cvar.RASTER_FT_WAAD_DT_PLANNER_NAME
RASTER_CT_PLANNER_NAME = cvar.RASTER_CT_PLANNER_NAME
RASTER_CT_DT_PLANNER_NAME = cvar.RASTER_CT_DT_PLANNER_NAME
RASTER_CT_WAAD_PLANNER_NAME = cvar.RASTER_CT_WAAD_PLANNER_NAME
RASTER_CT_WAAD_DT_PLANNER_NAME = cvar.RASTER_CT_WAAD_DT_PLANNER_NAME
RASTER_G_FT_PLANNER_NAME = cvar.RASTER_G_FT_PLANNER_NAME
RASTER_G_CT_PLANNER_NAME = cvar.RASTER_G_CT_PLANNER_NAME
RASTER_O_FT_PLANNER_NAME = cvar.RASTER_O_FT_PLANNER_NAME
RASTER_O_CT_PLANNER_NAME = cvar.RASTER_O_CT_PLANNER_NAME
RASTER_O_G_FT_PLANNER_NAME = cvar.RASTER_O_G_FT_PLANNER_NAME
RASTER_O_G_CT_PLANNER_NAME = cvar.RASTER_O_G_CT_PLANNER_NAME

class ProcessPlanningServer(object, metaclass=_SwigNonDynamicMeta):
    r"""
    A process planning server that support asynchronous execution of process planning requests
    It allows the developer to register Process pipelines (aka. Taskflow Generators) so they may be request
    Notes: This class is thread safe
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor
        :type cache: :py:class:`EnvironmentCache`
        :param cache: The cache to use for getting Environment objects
        :type n: int, optional
        :param n: The number of threads used by the planning server

        |

        *Overload 2:*

        Constructor
        :type environment: :py:class:`Environment`
        :param environment: The environment object to leverage
        :type cache_size: int, optional
        :param cache_size: The cache size used for maintaining a que of environments for improved performance when making
            multiple requests
        :type n: int, optional
        :param n: The number of threads used by the planning server

        |

        *Overload 3:*

        Constructor
        :type environment: :py:class:`Environment`
        :param environment: The environment object to leverage
        :type cache_size: int, optional
        :param cache_size: The cache size used for maintaining a que of environments for improved performance when making
            multiple requests
        :param n: The number of threads used by the planning server

        |

        *Overload 4:*

        Constructor
        :type environment: :py:class:`Environment`
        :param environment: The environment object to leverage
        :param cache_size: The cache size used for maintaining a que of environments for improved performance when making
            multiple requests
        :param n: The number of threads used by the planning server
        """
        _tesseract_process_managers_python.ProcessPlanningServer_swiginit(self, _tesseract_process_managers_python.new_ProcessPlanningServer(*args))
    __swig_destroy__ = _tesseract_process_managers_python.delete_ProcessPlanningServer

    def addExecutor(self, *args) -> "void":
        r"""
        *Overload 1:*

        Add a executors (thread pool) under the provided name
        :type name: string
        :param name: The name of the thread pool
        :type executor: std::shared_ptr< tf::Executor >
        :param executor: The executor to add

        |

        *Overload 2:*

        Add a executors (thread pool) under the provided name
        This creates a taskflow executor with the provided number of threads
        :type name: string
        :param name: The name of the thread pool
        :type n: int
        :param n: The number of threads
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_addExecutor(self, *args)

    def hasExecutor(self, name: "std::string const &") -> "bool":
        r"""
        Check if executors (thread pool) exists with the provided name
        :type name: string
        :param name: The name to search
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_hasExecutor(self, name)

    def getAvailableExecutors(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the available executors (thread pool) names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of names
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_getAvailableExecutors(self)

    def loadDefaultProcessPlanners(self) -> "void":
        r"""
        Load default process planners
        This is not called automatically, so user but call this to load default planners.
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_loadDefaultProcessPlanners(self)

    def hasProcessPlanner(self, name: "std::string const &") -> "bool":
        r"""
        Check if the planning server has a name associated with a process pipeline
        :type name: string
        :param name: The name of the process planner to check for
        :rtype: boolean
        :return: True if the name is already taken, otherwise false
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_hasProcessPlanner(self, name)

    def getAvailableProcessPlanners(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get a list of process planner registered with the planning server
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of names
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_getAvailableProcessPlanners(self)

    def waitForAll(self, *args) -> "void":
        r"""
        Wait for all process currently being executed to finish before returning
        :type name: string, optional
        :param name: The name of the executor to wait on
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_waitForAll(self, *args)

    def enableTaskflowProfiling(self, *args) -> "void":
        r"""
        This add a Taskflow profiling observer to the executor
        :type name: string, optional
        :param name: The name of the executor to enable profiling for
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_enableTaskflowProfiling(self, *args)

    def disableTaskflowProfiling(self, *args) -> "void":
        r"""
        This remove the Taskflow profiling observer from the executor if one exists
        :type name: string, optional
        :param name: The name of the executor to disable profiling for
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_disableTaskflowProfiling(self, *args)

    def getProfiles(self, *args) -> "tesseract_planning::ProfileDictionary::ConstPtr":
        r"""
        *Overload 1:*

        Get the profile dictionary associated with the planning server
        :rtype: :py:class:`ProfileDictionary`
        :return: Profile dictionary

        |

        *Overload 2:*

        Get the profile dictionary associated with the planning server (const)
        :rtype: :py:class:`ProfileDictionary`
        :return: Profile dictionary (const)
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_getProfiles(self, *args)

    def getWorkerCount(self, *args) -> "long":
        r"""
        Queries the number of worker threads (can be zero)
        :type name: string, optional
        :param name: The name of the executor to get worker count for
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_getWorkerCount(self, *args)

    def getTaskCount(self, *args) -> "long":
        r"""
        Queries the number of running tasks at the time of this call
        When a taskflow is submitted to an executor, a topology is created to store
        runtime metadata of the running taskflow.
        :type name: string, optional
        :param name: The name of the executor to get task count for
        """
        return _tesseract_process_managers_python.ProcessPlanningServer_getTaskCount(self, *args)

    def run(self, *args) -> "std::shared_ptr< tesseract_planning::ProcessPlanningFuture >":
        return _tesseract_process_managers_python.ProcessPlanningServer_run(self, *args)

# Register ProcessPlanningServer in _tesseract_process_managers_python:
_tesseract_process_managers_python.ProcessPlanningServer_swigregister(ProcessPlanningServer)



