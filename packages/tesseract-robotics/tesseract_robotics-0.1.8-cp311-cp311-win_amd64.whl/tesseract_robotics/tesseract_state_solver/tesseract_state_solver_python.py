# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_state_solver_python
else:
    import _tesseract_state_solver_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_state_solver_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_state_solver_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_state_solver_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_state_solver_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_state_solver_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_state_solver_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_state_solver_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_state_solver_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_state_solver_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_state_solver_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_state_solver_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_state_solver_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_state_solver_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_state_solver_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_state_solver_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_state_solver_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_state_solver_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_state_solver_python:
_tesseract_state_solver_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_state_solver_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_state_solver_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_state_solver_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_state_solver_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_state_solver_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_state_solver_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_state_solver_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_state_solver_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_state_solver_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_state_solver_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_state_solver_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_state_solver_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_state_solver_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_state_solver_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_state_solver_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_state_solver_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_state_solver_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_state_solver_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_state_solver_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_state_solver_python.vector_eigen_index_swiginit(self, _tesseract_state_solver_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_state_solver_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_state_solver_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_state_solver_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_state_solver_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_state_solver_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_state_solver_python:
_tesseract_state_solver_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
class StateSolverUPtr(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_state_solver_python.StateSolverUPtr_swiginit(self, _tesseract_state_solver_python.new_StateSolverUPtr(*args))

    def __deref__(self) -> "std::unique_ptr< tesseract_scene_graph::StateSolver >::pointer":
        return _tesseract_state_solver_python.StateSolverUPtr___deref__(self)

    def release(self) -> "std::unique_ptr< tesseract_scene_graph::StateSolver >::pointer":
        return _tesseract_state_solver_python.StateSolverUPtr_release(self)

    def reset(self, *args) -> "void":
        return _tesseract_state_solver_python.StateSolverUPtr_reset(self, *args)

    def swap(self, __u: "StateSolverUPtr") -> "void":
        return _tesseract_state_solver_python.StateSolverUPtr_swap(self, __u)

    def get(self) -> "std::unique_ptr< tesseract_scene_graph::StateSolver >::pointer":
        return _tesseract_state_solver_python.StateSolverUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_state_solver_python.StateSolverUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_state_solver_python.delete_StateSolverUPtr

    def clone(self) -> "tesseract_scene_graph::StateSolver::UPtr":
        r"""
        This should clone the object so it may be used in a multi threaded application where each thread would
        clone the solver.
        :rtype: :py:class:`UPtr`
        :return: A clone of the object.
        """
        return _tesseract_state_solver_python.StateSolverUPtr_clone(self)

    def setState(self, *args) -> "void":
        return _tesseract_state_solver_python.StateSolverUPtr_setState(self, *args)

    def getState(self, *args) -> "tesseract_scene_graph::SceneState":
        r"""
        *Overload 1:*

        Get the state of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values

        |

        *Overload 2:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the current state of the scene
        :rtype: :py:class:`SceneState`
        :return: The current state
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getState(self, *args)

    def getJacobian(self, *args) -> "Eigen::MatrixXd":
        return _tesseract_state_solver_python.StateSolverUPtr_getJacobian(self, *args)

    def getRandomState(self) -> "tesseract_scene_graph::SceneState":
        r"""
        Get the random state of the environment
        :rtype: :py:class:`SceneState`
        :return: Environment state
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getRandomState(self)

    def getJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getJointNames(self)

    def getActiveJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of joint names which align with the limits
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getActiveJointNames(self)

    def getBaseLinkName(self) -> "std::string":
        r"""
        Get the base link name
        :rtype: string
        :return: The base link name
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getBaseLinkName(self)

    def getLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLinkNames(self)

    def getActiveLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of active link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getActiveLinkNames(self)

    def getStaticLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get a vector of static link names in the environment
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name: "std::string const &") -> "bool":
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_state_solver_python.StateSolverUPtr_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name: "std::string const &") -> "bool":
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_state_solver_python.StateSolverUPtr_hasLinkName(self, link_name)

    def getLinkTransforms(self) -> "tesseract_common::VectorIsometry3d":
        r"""
        Get all of the links transforms
        Order should be the same as getLinkNames()
        :rtype: :py:class:`VectorIsometry3d`
        :return: Get a vector of transforms for all links.
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLinkTransforms(self)

    def getLinkTransform(self, link_name: "std::string const &") -> "Eigen::Isometry3d":
        r"""
        Get the transform corresponding to the link.
        :rtype: :py:class:`Isometry3d`
        :return: Transform and is identity when no transform is available.
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name: "std::string const &", to_link_name: "std::string const &") -> "Eigen::Isometry3d":
        r"""
        Get transform between two links using the current state
        :type from_link_name: string
        :param from_link_name: The link name the transform should be relative to
        :type to_link_name: string
        :param to_link_name: The link name to get transform
        :rtype: :py:class:`Isometry3d`
        :return: The relative transform = inv(Transform(from_link_name)) * Transform(to_link_name)
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self) -> "tesseract_common::KinematicLimits":
        r"""
        Getter for kinematic limits
        :rtype: :py:class:`KinematicLimits`
        :return: The kinematic limits
        """
        return _tesseract_state_solver_python.StateSolverUPtr_getLimits(self)

# Register StateSolverUPtr in _tesseract_state_solver_python:
_tesseract_state_solver_python.StateSolverUPtr_swigregister(StateSolverUPtr)

class StateSolver(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_StateSolver

    def clone(self) -> "tesseract_scene_graph::StateSolver::UPtr":
        r"""
        This should clone the object so it may be used in a multi threaded application where each thread would
        clone the solver.
        :rtype: :py:class:`UPtr`
        :return: A clone of the object.
        """
        return _tesseract_state_solver_python.StateSolver_clone(self)

    def setState(self, *args) -> "void":
        return _tesseract_state_solver_python.StateSolver_setState(self, *args)

    def getState(self, *args) -> "tesseract_scene_graph::SceneState":
        r"""
        *Overload 1:*

        Get the state of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values

        |

        *Overload 2:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the current state of the scene
        :rtype: :py:class:`SceneState`
        :return: The current state
        """
        return _tesseract_state_solver_python.StateSolver_getState(self, *args)

    def getJacobian(self, *args) -> "Eigen::MatrixXd":
        return _tesseract_state_solver_python.StateSolver_getJacobian(self, *args)

    def getRandomState(self) -> "tesseract_scene_graph::SceneState":
        r"""
        Get the random state of the environment
        :rtype: :py:class:`SceneState`
        :return: Environment state
        """
        return _tesseract_state_solver_python.StateSolver_getRandomState(self)

    def getJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolver_getJointNames(self)

    def getActiveJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of joint names which align with the limits
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.StateSolver_getActiveJointNames(self)

    def getBaseLinkName(self) -> "std::string":
        r"""
        Get the base link name
        :rtype: string
        :return: The base link name
        """
        return _tesseract_state_solver_python.StateSolver_getBaseLinkName(self)

    def getLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_state_solver_python.StateSolver_getLinkNames(self)

    def getActiveLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of active link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_state_solver_python.StateSolver_getActiveLinkNames(self)

    def getStaticLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get a vector of static link names in the environment
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_state_solver_python.StateSolver_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name: "std::string const &") -> "bool":
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_state_solver_python.StateSolver_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name: "std::string const &") -> "bool":
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_state_solver_python.StateSolver_hasLinkName(self, link_name)

    def getLinkTransforms(self) -> "tesseract_common::VectorIsometry3d":
        r"""
        Get all of the links transforms
        Order should be the same as getLinkNames()
        :rtype: :py:class:`VectorIsometry3d`
        :return: Get a vector of transforms for all links.
        """
        return _tesseract_state_solver_python.StateSolver_getLinkTransforms(self)

    def getLinkTransform(self, link_name: "std::string const &") -> "Eigen::Isometry3d":
        r"""
        Get the transform corresponding to the link.
        :rtype: :py:class:`Isometry3d`
        :return: Transform and is identity when no transform is available.
        """
        return _tesseract_state_solver_python.StateSolver_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name: "std::string const &", to_link_name: "std::string const &") -> "Eigen::Isometry3d":
        r"""
        Get transform between two links using the current state
        :type from_link_name: string
        :param from_link_name: The link name the transform should be relative to
        :type to_link_name: string
        :param to_link_name: The link name to get transform
        :rtype: :py:class:`Isometry3d`
        :return: The relative transform = inv(Transform(from_link_name)) * Transform(to_link_name)
        """
        return _tesseract_state_solver_python.StateSolver_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self) -> "tesseract_common::KinematicLimits":
        r"""
        Getter for kinematic limits
        :rtype: :py:class:`KinematicLimits`
        :return: The kinematic limits
        """
        return _tesseract_state_solver_python.StateSolver_getLimits(self)

# Register StateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.StateSolver_swigregister(StateSolver)

class MutableStateSolverUPtr(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_state_solver_python.MutableStateSolverUPtr_swiginit(self, _tesseract_state_solver_python.new_MutableStateSolverUPtr(*args))

    def __deref__(self) -> "std::unique_ptr< tesseract_scene_graph::MutableStateSolver >::pointer":
        return _tesseract_state_solver_python.MutableStateSolverUPtr___deref__(self)

    def release(self) -> "std::unique_ptr< tesseract_scene_graph::MutableStateSolver >::pointer":
        return _tesseract_state_solver_python.MutableStateSolverUPtr_release(self)

    def reset(self, *args) -> "void":
        return _tesseract_state_solver_python.MutableStateSolverUPtr_reset(self, *args)

    def swap(self, __u: "MutableStateSolverUPtr") -> "void":
        return _tesseract_state_solver_python.MutableStateSolverUPtr_swap(self, __u)

    def get(self) -> "std::unique_ptr< tesseract_scene_graph::MutableStateSolver >::pointer":
        return _tesseract_state_solver_python.MutableStateSolverUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_state_solver_python.MutableStateSolverUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_state_solver_python.delete_MutableStateSolverUPtr

    def setRevision(self, revision: "int") -> "void":
        r"""
        Set the state solver revision number
        :type revision: int
        :param revision: The revision number to assign
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_setRevision(self, revision)

    def getRevision(self) -> "int":
        r"""
        Get the state solver revision number
        :rtype: int
        :return: revision number
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getRevision(self)

    def addLink(self, link: "Link", joint: "Joint") -> "bool":
        r"""
        Adds a link/joint to the solver
        :type link: :py:class:`Link`
        :param link: The link to be added to the graph
        :type joint: :py:class:`Joint`
        :param joint: The associated joint to be added to the graph
        :rtype: boolean
        :return: Return False if a link with the same name allready exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_addLink(self, link, joint)

    def moveLink(self, joint: "Joint") -> "bool":
        r"""
        Move a link
        :type joint: :py:class:`Joint`
        :param joint: The associated joint that defines the move
        :rtype: boolean
        :return: Return False if link does not exist or if joint name already exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_moveLink(self, joint)

    def removeLink(self, name: "std::string const &") -> "bool":
        r"""
        Removes a link from the graph

        Note: this will remove all inbound and outbound edges

        :type name: string
        :param name: Name of the link to be removed
        :rtype: boolean
        :return: Return False if a link does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_removeLink(self, name)

    def replaceJoint(self, joint: "Joint") -> "bool":
        r"""
        Replace and existing joint with the provided one
        :type joint: :py:class:`Joint`
        :param joint: The replacement joint
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_replaceJoint(self, joint)

    def removeJoint(self, name: "std::string const &") -> "bool":
        r"""
        Removes a joint from the graph
        :type name: string
        :param name: Name of the joint to be removed
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_removeJoint(self, name)

    def moveJoint(self, name: "std::string const &", parent_link: "std::string const &") -> "bool":
        r"""
        Move joint to new parent link
        :type name: string
        :param name: Name of the joint to move
        :type parent_link: string
        :param parent_link: Name of parent link to move to
        :rtype: boolean
        :return: Returns true if successful, otherwise false.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_moveJoint(self, name, parent_link)

    def changeJointOrigin(self, name: "std::string const &", new_origin: "Isometry3d") -> "bool":
        r"""
        Changes the "origin" transform of the joint and recomputes the associated edge
        :type name: string
        :param name: Name of the joint to be changed
        :type new_origin: :py:class:`Isometry3d`
        :param new_origin: The new transform associated with the joint
        :rtype: boolean
        :return: True if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointOrigin(self, name, new_origin)

    def changeJointPositionLimits(self, name: "std::string const &", lower: "double", upper: "double") -> "bool":
        r"""
        Changes the position limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New position limits to be set as the joint limits
            if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointPositionLimits(self, name, lower, upper)

    def changeJointVelocityLimits(self, name: "std::string const &", limit: "double") -> "bool":
        r"""
        Changes the velocity limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New velocity limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointVelocityLimits(self, name, limit)

    def changeJointAccelerationLimits(self, name: "std::string const &", limit: "double") -> "bool":
        r"""
        Changes the acceleration limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New acceleration limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_changeJointAccelerationLimits(self, name, limit)

    def insertSceneGraph(self, *args) -> "bool":
        r"""
        Merge a scene into the current solver
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: Const ref to the graph to be merged
        :type joint: :py:class:`Joint`
        :param joint: The joint that connects current scene with the inserted scene
        :type prefix: string, optional
        :param prefix: string Will be prepended to every link and joint of the merged scene
        :rtype: boolean
        :return: Return False if any link or joint name collides with current solver, otherwise True
            The prefix argument is meant to allow adding multiple copies of the same subgraph with different names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_insertSceneGraph(self, *args)

    def clone(self) -> "tesseract_scene_graph::StateSolver::UPtr":
        r"""
        This should clone the object so it may be used in a multi threaded application where each thread would
        clone the solver.
        :rtype: :py:class:`UPtr`
        :return: A clone of the object.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_clone(self)

    def setState(self, *args) -> "void":
        return _tesseract_state_solver_python.MutableStateSolverUPtr_setState(self, *args)

    def getState(self, *args) -> "tesseract_scene_graph::SceneState":
        r"""
        *Overload 1:*

        Get the state of the solver given the joint values
        This must be the same size and order as what is returned by getJointNames
        :type joint_values: Eigen::Ref< Eigen::VectorXd const >
        :param joint_values: The joint values

        |

        *Overload 2:*

        Get the state of the scene for a given set or subset of joint values.

        This does not change the internal state of the solver.

        :param joints: A map of joint names to joint values to change.
        :rtype: :py:class:`SceneState`
        :return: A the state of the environment

        |

        *Overload 3:*

        Get the current state of the scene
        :rtype: :py:class:`SceneState`
        :return: The current state
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getState(self, *args)

    def getJacobian(self, *args) -> "Eigen::MatrixXd":
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getJacobian(self, *args)

    def getRandomState(self) -> "tesseract_scene_graph::SceneState":
        r"""
        Get the random state of the environment
        :rtype: :py:class:`SceneState`
        :return: Environment state
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getRandomState(self)

    def getJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of joint names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getJointNames(self)

    def getActiveJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of joint names which align with the limits
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of joint names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getActiveJointNames(self)

    def getBaseLinkName(self) -> "std::string":
        r"""
        Get the base link name
        :rtype: string
        :return: The base link name
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getBaseLinkName(self)

    def getLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of link names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLinkNames(self)

    def getActiveLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the vector of active link names
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of active link names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getActiveLinkNames(self)

    def getStaticLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get a vector of static link names in the environment
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of static link names
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name: "std::string const &") -> "bool":
        r"""
        Check if link is an active link
        :type link_name: string
        :param link_name: The link name to check
        :rtype: boolean
        :return: True if active, otherwise false
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name: "std::string const &") -> "bool":
        r"""
        Check if link name exists
        :type link_name: string
        :param link_name: The link name to check for
        :rtype: boolean
        :return: True if it exists, otherwise false
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_hasLinkName(self, link_name)

    def getLinkTransforms(self) -> "tesseract_common::VectorIsometry3d":
        r"""
        Get all of the links transforms
        Order should be the same as getLinkNames()
        :rtype: :py:class:`VectorIsometry3d`
        :return: Get a vector of transforms for all links.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLinkTransforms(self)

    def getLinkTransform(self, link_name: "std::string const &") -> "Eigen::Isometry3d":
        r"""
        Get the transform corresponding to the link.
        :rtype: :py:class:`Isometry3d`
        :return: Transform and is identity when no transform is available.
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name: "std::string const &", to_link_name: "std::string const &") -> "Eigen::Isometry3d":
        r"""
        Get transform between two links using the current state
        :type from_link_name: string
        :param from_link_name: The link name the transform should be relative to
        :type to_link_name: string
        :param to_link_name: The link name to get transform
        :rtype: :py:class:`Isometry3d`
        :return: The relative transform = inv(Transform(from_link_name)) * Transform(to_link_name)
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self) -> "tesseract_common::KinematicLimits":
        r"""
        Getter for kinematic limits
        :rtype: :py:class:`KinematicLimits`
        :return: The kinematic limits
        """
        return _tesseract_state_solver_python.MutableStateSolverUPtr_getLimits(self)

# Register MutableStateSolverUPtr in _tesseract_state_solver_python:
_tesseract_state_solver_python.MutableStateSolverUPtr_swigregister(MutableStateSolverUPtr)

class MutableStateSolver(StateSolver):
    r"""A mutable state solver allows you to reconfigure the solver's links and joints"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_MutableStateSolver

    def setRevision(self, revision: "int") -> "void":
        r"""
        Set the state solver revision number
        :type revision: int
        :param revision: The revision number to assign
        """
        return _tesseract_state_solver_python.MutableStateSolver_setRevision(self, revision)

    def getRevision(self) -> "int":
        r"""
        Get the state solver revision number
        :rtype: int
        :return: revision number
        """
        return _tesseract_state_solver_python.MutableStateSolver_getRevision(self)

    def addLink(self, link: "Link", joint: "Joint") -> "bool":
        r"""
        Adds a link/joint to the solver
        :type link: :py:class:`Link`
        :param link: The link to be added to the graph
        :type joint: :py:class:`Joint`
        :param joint: The associated joint to be added to the graph
        :rtype: boolean
        :return: Return False if a link with the same name allready exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_addLink(self, link, joint)

    def moveLink(self, joint: "Joint") -> "bool":
        r"""
        Move a link
        :type joint: :py:class:`Joint`
        :param joint: The associated joint that defines the move
        :rtype: boolean
        :return: Return False if link does not exist or if joint name already exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_moveLink(self, joint)

    def removeLink(self, name: "std::string const &") -> "bool":
        r"""
        Removes a link from the graph

        Note: this will remove all inbound and outbound edges

        :type name: string
        :param name: Name of the link to be removed
        :rtype: boolean
        :return: Return False if a link does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_removeLink(self, name)

    def replaceJoint(self, joint: "Joint") -> "bool":
        r"""
        Replace and existing joint with the provided one
        :type joint: :py:class:`Joint`
        :param joint: The replacement joint
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_replaceJoint(self, joint)

    def removeJoint(self, name: "std::string const &") -> "bool":
        r"""
        Removes a joint from the graph
        :type name: string
        :param name: Name of the joint to be removed
        :rtype: boolean
        :return: Return False if a joint does not exists, otherwise true
        """
        return _tesseract_state_solver_python.MutableStateSolver_removeJoint(self, name)

    def moveJoint(self, name: "std::string const &", parent_link: "std::string const &") -> "bool":
        r"""
        Move joint to new parent link
        :type name: string
        :param name: Name of the joint to move
        :type parent_link: string
        :param parent_link: Name of parent link to move to
        :rtype: boolean
        :return: Returns true if successful, otherwise false.
        """
        return _tesseract_state_solver_python.MutableStateSolver_moveJoint(self, name, parent_link)

    def changeJointOrigin(self, name: "std::string const &", new_origin: "Isometry3d") -> "bool":
        r"""
        Changes the "origin" transform of the joint and recomputes the associated edge
        :type name: string
        :param name: Name of the joint to be changed
        :type new_origin: :py:class:`Isometry3d`
        :param new_origin: The new transform associated with the joint
        :rtype: boolean
        :return: True if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointOrigin(self, name, new_origin)

    def changeJointPositionLimits(self, name: "std::string const &", lower: "double", upper: "double") -> "bool":
        r"""
        Changes the position limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New position limits to be set as the joint limits
            if successful.
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointPositionLimits(self, name, lower, upper)

    def changeJointVelocityLimits(self, name: "std::string const &", limit: "double") -> "bool":
        r"""
        Changes the velocity limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New velocity limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointVelocityLimits(self, name, limit)

    def changeJointAccelerationLimits(self, name: "std::string const &", limit: "double") -> "bool":
        r"""
        Changes the acceleration limits associated with a joint
        :param joint_name: Name of the joint to be updated
        :param limits: New acceleration limits to be set as the joint limits
        :rtype: boolean
        :return: 
        """
        return _tesseract_state_solver_python.MutableStateSolver_changeJointAccelerationLimits(self, name, limit)

    def insertSceneGraph(self, *args) -> "bool":
        r"""
        Merge a scene into the current solver
        :type scene_graph: :py:class:`SceneGraph`
        :param scene_graph: Const ref to the graph to be merged
        :type joint: :py:class:`Joint`
        :param joint: The joint that connects current scene with the inserted scene
        :type prefix: string, optional
        :param prefix: string Will be prepended to every link and joint of the merged scene
        :rtype: boolean
        :return: Return False if any link or joint name collides with current solver, otherwise True
            The prefix argument is meant to allow adding multiple copies of the same subgraph with different names
        """
        return _tesseract_state_solver_python.MutableStateSolver_insertSceneGraph(self, *args)

# Register MutableStateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.MutableStateSolver_swigregister(MutableStateSolver)

class KDLStateSolver(StateSolver):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_KDLStateSolver

    def __init__(self, *args):
        _tesseract_state_solver_python.KDLStateSolver_swiginit(self, _tesseract_state_solver_python.new_KDLStateSolver(*args))

    def clone(self) -> "tesseract_scene_graph::StateSolver::UPtr":
        return _tesseract_state_solver_python.KDLStateSolver_clone(self)

    def setState(self, *args) -> "void":
        return _tesseract_state_solver_python.KDLStateSolver_setState(self, *args)

    def getState(self, *args) -> "tesseract_scene_graph::SceneState":
        return _tesseract_state_solver_python.KDLStateSolver_getState(self, *args)

    def getRandomState(self) -> "tesseract_scene_graph::SceneState":
        return _tesseract_state_solver_python.KDLStateSolver_getRandomState(self)

    def getJacobian(self, *args) -> "Eigen::MatrixXd":
        return _tesseract_state_solver_python.KDLStateSolver_getJacobian(self, *args)

    def getJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.KDLStateSolver_getJointNames(self)

    def getActiveJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.KDLStateSolver_getActiveJointNames(self)

    def getBaseLinkName(self) -> "std::string":
        return _tesseract_state_solver_python.KDLStateSolver_getBaseLinkName(self)

    def getLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.KDLStateSolver_getLinkNames(self)

    def getActiveLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.KDLStateSolver_getActiveLinkNames(self)

    def getStaticLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.KDLStateSolver_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name: "std::string const &") -> "bool":
        return _tesseract_state_solver_python.KDLStateSolver_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name: "std::string const &") -> "bool":
        return _tesseract_state_solver_python.KDLStateSolver_hasLinkName(self, link_name)

    def getLinkTransforms(self) -> "tesseract_common::VectorIsometry3d":
        return _tesseract_state_solver_python.KDLStateSolver_getLinkTransforms(self)

    def getLinkTransform(self, link_name: "std::string const &") -> "Eigen::Isometry3d":
        return _tesseract_state_solver_python.KDLStateSolver_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name: "std::string const &", to_link_name: "std::string const &") -> "Eigen::Isometry3d":
        return _tesseract_state_solver_python.KDLStateSolver_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self) -> "tesseract_common::KinematicLimits":
        return _tesseract_state_solver_python.KDLStateSolver_getLimits(self)

# Register KDLStateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.KDLStateSolver_swigregister(KDLStateSolver)

class OFKTStateSolver(MutableStateSolver):
    r"""
    An implementation of the Optimized Forward Kinematic Tree as a stat solver

    Starke, S., Hendrich, N., & Zhang, J. (2018). A Forward Kinematics Data Structure for Efficient Evolutionary Inverse
    Kinematics. In Computational Kinematics (pp. 560-568). Springer, Cham.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_state_solver_python.delete_OFKTStateSolver

    def __init__(self, *args):
        _tesseract_state_solver_python.OFKTStateSolver_swiginit(self, _tesseract_state_solver_python.new_OFKTStateSolver(*args))

    def setRevision(self, revision: "int") -> "void":
        return _tesseract_state_solver_python.OFKTStateSolver_setRevision(self, revision)

    def getRevision(self) -> "int":
        return _tesseract_state_solver_python.OFKTStateSolver_getRevision(self)

    def setState(self, *args) -> "void":
        return _tesseract_state_solver_python.OFKTStateSolver_setState(self, *args)

    def getState(self, *args) -> "tesseract_scene_graph::SceneState":
        return _tesseract_state_solver_python.OFKTStateSolver_getState(self, *args)

    def getRandomState(self) -> "tesseract_scene_graph::SceneState":
        return _tesseract_state_solver_python.OFKTStateSolver_getRandomState(self)

    def getJacobian(self, *args) -> "Eigen::MatrixXd":
        return _tesseract_state_solver_python.OFKTStateSolver_getJacobian(self, *args)

    def getJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.OFKTStateSolver_getJointNames(self)

    def getActiveJointNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.OFKTStateSolver_getActiveJointNames(self)

    def getBaseLinkName(self) -> "std::string":
        return _tesseract_state_solver_python.OFKTStateSolver_getBaseLinkName(self)

    def getLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.OFKTStateSolver_getLinkNames(self)

    def getActiveLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.OFKTStateSolver_getActiveLinkNames(self)

    def getStaticLinkNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _tesseract_state_solver_python.OFKTStateSolver_getStaticLinkNames(self)

    def isActiveLinkName(self, link_name: "std::string const &") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_isActiveLinkName(self, link_name)

    def hasLinkName(self, link_name: "std::string const &") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_hasLinkName(self, link_name)

    def getLinkTransforms(self) -> "tesseract_common::VectorIsometry3d":
        return _tesseract_state_solver_python.OFKTStateSolver_getLinkTransforms(self)

    def getLinkTransform(self, link_name: "std::string const &") -> "Eigen::Isometry3d":
        return _tesseract_state_solver_python.OFKTStateSolver_getLinkTransform(self, link_name)

    def getRelativeLinkTransform(self, from_link_name: "std::string const &", to_link_name: "std::string const &") -> "Eigen::Isometry3d":
        return _tesseract_state_solver_python.OFKTStateSolver_getRelativeLinkTransform(self, from_link_name, to_link_name)

    def getLimits(self) -> "tesseract_common::KinematicLimits":
        return _tesseract_state_solver_python.OFKTStateSolver_getLimits(self)

    def addLink(self, link: "Link", joint: "Joint") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_addLink(self, link, joint)

    def moveLink(self, joint: "Joint") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_moveLink(self, joint)

    def removeLink(self, name: "std::string const &") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_removeLink(self, name)

    def replaceJoint(self, joint: "Joint") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_replaceJoint(self, joint)

    def removeJoint(self, name: "std::string const &") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_removeJoint(self, name)

    def moveJoint(self, name: "std::string const &", parent_link: "std::string const &") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_moveJoint(self, name, parent_link)

    def changeJointOrigin(self, name: "std::string const &", new_origin: "Isometry3d") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointOrigin(self, name, new_origin)

    def changeJointPositionLimits(self, name: "std::string const &", lower: "double", upper: "double") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointPositionLimits(self, name, lower, upper)

    def changeJointVelocityLimits(self, name: "std::string const &", limit: "double") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointVelocityLimits(self, name, limit)

    def changeJointAccelerationLimits(self, name: "std::string const &", limit: "double") -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_changeJointAccelerationLimits(self, name, limit)

    def insertSceneGraph(self, *args) -> "bool":
        return _tesseract_state_solver_python.OFKTStateSolver_insertSceneGraph(self, *args)

    def clone(self) -> "tesseract_scene_graph::StateSolver::UPtr":
        return _tesseract_state_solver_python.OFKTStateSolver_clone(self)

# Register OFKTStateSolver in _tesseract_state_solver_python:
_tesseract_state_solver_python.OFKTStateSolver_swigregister(OFKTStateSolver)



