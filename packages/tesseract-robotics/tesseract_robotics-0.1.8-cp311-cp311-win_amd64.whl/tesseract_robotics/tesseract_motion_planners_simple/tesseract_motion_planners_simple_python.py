# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_motion_planners_simple_python
else:
    import _tesseract_motion_planners_simple_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_motion_planners_simple_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_simple_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_simple_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_motion_planners_simple_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_motion_planners_simple_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_motion_planners_simple_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.vector_eigen_index_swiginit(self, _tesseract_motion_planners_simple_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_simple_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python
import tesseract_robotics.tesseract_environment.tesseract_environment_python
import tesseract_robotics.tesseract_kinematics.tesseract_kinematics_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
import tesseract_robotics.tesseract_collision.tesseract_collision_python
import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
class JointGroupInstructionInfo(object, metaclass=_SwigNonDynamicMeta):
    r""" The Joint Group Instruction Information struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, plan_instruction: "MoveInstruction", request: "PlannerRequest", manip_info: "ManipulatorInfo"):
        _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_swiginit(self, _tesseract_motion_planners_simple_python.new_JointGroupInstructionInfo(plan_instruction, request, manip_info))
    instruction = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_instruction_get)
    manip = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_manip_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_manip_set)
    working_frame = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_working_frame_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_working_frame_set)
    tcp_frame = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_frame_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_frame_set)
    tcp_offset = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_offset_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_tcp_offset_set)
    has_cartesian_waypoint = property(_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_has_cartesian_waypoint_get, _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_has_cartesian_waypoint_set)

    def calcCartesianPose(self, jp: "Eigen::VectorXd const &") -> "Eigen::Isometry3d":
        r"""
        Calculate the cartesian pose given the joint solution
        :type jp: Eigen::VectorXd
        :param jp: The joint solution to calculate the pose
        :rtype: :py:class:`Isometry3d`
        :return: The pose give the joint solution
        """
        return _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_calcCartesianPose(self, jp)

    def extractCartesianPose(self) -> "Eigen::Isometry3d":
        r"""
        Extract the cartesian pose from the instruction
        If the instruction does not have a cartesian waypoint this throws an exception
        :rtype: :py:class:`Isometry3d`
        :return: Cartesian pose
        """
        return _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_extractCartesianPose(self)

    def extractJointPosition(self) -> "Eigen::VectorXd const &":
        r"""
        Extract the joint position from the instruction waypoint
        If the instruction does not have a joint/state waypoint this throws an exception
        :rtype: Eigen::VectorXd
        :return: Joint Position
        """
        return _tesseract_motion_planners_simple_python.JointGroupInstructionInfo_extractJointPosition(self)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_JointGroupInstructionInfo

# Register JointGroupInstructionInfo in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.JointGroupInstructionInfo_swigregister(JointGroupInstructionInfo)

class KinematicGroupInstructionInfo(object, metaclass=_SwigNonDynamicMeta):
    r""" The Kinematic Group Instruction Information struct"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, plan_instruction: "MoveInstruction", request: "PlannerRequest", manip_info: "ManipulatorInfo"):
        _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_swiginit(self, _tesseract_motion_planners_simple_python.new_KinematicGroupInstructionInfo(plan_instruction, request, manip_info))
    instruction = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_instruction_get)
    manip = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_manip_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_manip_set)
    working_frame = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_working_frame_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_working_frame_set)
    tcp_frame = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_frame_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_frame_set)
    tcp_offset = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_offset_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_tcp_offset_set)
    has_cartesian_waypoint = property(_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_has_cartesian_waypoint_get, _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_has_cartesian_waypoint_set)

    def calcCartesianPose(self, jp: "Eigen::VectorXd const &") -> "Eigen::Isometry3d":
        r"""
        Calculate the cartesian pose given the joint solution
        :type jp: Eigen::VectorXd
        :param jp: The joint solution to calculate the pose
        :rtype: :py:class:`Isometry3d`
        :return: The pose give the joint solution
        """
        return _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_calcCartesianPose(self, jp)

    def extractCartesianPose(self) -> "Eigen::Isometry3d":
        r"""
        Extract the cartesian pose from the instruction
        If the instruction does not have a cartesian waypoint this throws an exception
        :rtype: :py:class:`Isometry3d`
        :return: Cartesian pose
        """
        return _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_extractCartesianPose(self)

    def extractJointPosition(self) -> "Eigen::VectorXd const &":
        r"""
        Extract the joint position from the instruction waypoint
        If the instruction does not have a joint/state waypoint this throws an exception
        :rtype: Eigen::VectorXd
        :return: Joint Position
        """
        return _tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_extractJointPosition(self)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_KinematicGroupInstructionInfo

# Register KinematicGroupInstructionInfo in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.KinematicGroupInstructionInfo_swigregister(KinematicGroupInstructionInfo)


def getInterpolatedComposite(joint_names: "vector_string", states: "Eigen::MatrixXd const &", base_instruction: "MoveInstruction") -> "Eigen::MatrixXd const &":
    r"""
    This takes the provided seed state for the base_instruction and create a corresponding composite instruction
    :type joint_names: std::vector< std::string,std::allocator< std::string > >
    :param joint_names: The joint names associated with the states
    :type states: Eigen::MatrixXd
    :param states: The joint states to populate the composite instruction with
    :type base_instruction: :py:class:`MoveInstruction`
    :param base_instruction: The base instruction used to extract profile and manipulator information from
    :rtype: :py:class:`CompositeInstruction`
    :return: The composite instruction
    """
    return _tesseract_motion_planners_simple_python.getInterpolatedComposite(joint_names, states, base_instruction)

def getClosestJointSolution(*args) -> "Eigen::VectorXd const &":
    r"""
    *Overload 1:*

    Find the closest joint solution for p to the provided seed
    :type info: :py:class:`KinematicGroupInstructionInfo`
    :param info: The instruction info to find closest joint solution
    :type seed: Eigen::VectorXd
    :param seed: The seed to find the closest solution
    :rtype: Eigen::VectorXd
    :return: The closest solution to the seed. This will be empty if a solution was not found during inverse kinematics

    |

    *Overload 2:*

    Find the closest joint solution for the two provided cartesian poses.
    :type info1: :py:class:`KinematicGroupInstructionInfo`
    :param info1: The instruction info to find closest joint solution
    :type info2: :py:class:`KinematicGroupInstructionInfo`
    :param info2: The instruction info to find closest joint solution
    :type seed: Eigen::VectorXd
    :param seed: The seed to use during inverse kinematics
    :rtype: std::array< Eigen::VectorXd,2 >
    :return: The closest joint solution for the provided cartesian positions. If either are empty then it failed to solve
        inverse kinematics.
    """
    return _tesseract_motion_planners_simple_python.getClosestJointSolution(*args)
class SimplePlannerPlanProfile(object, metaclass=_SwigNonDynamicMeta):
    r"""
    Plan Profile for the simple planner. It defines some functions that handle each of the waypoint cases. The
    planner then simply loops over all of the plan instructions and calls the correct function
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerPlanProfile

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.SimplePlannerPlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerPlanProfile(*args))

    def generate(self, prev_instruction: "MoveInstruction", prev_seed: "MoveInstruction", base_instruction: "MoveInstruction", next_instruction: "Instruction", request: "PlannerRequest", global_manip_info: "ManipulatorInfo") -> "tesseract_planning::CompositeInstruction":
        r"""
        Generate a seed for the provided base_instruction
        :type prev_instruction: :py:class:`MoveInstruction`
        :param prev_instruction: The previous instruction
        :type prev_seed: :py:class:`MoveInstruction`
        :param prev_seed: The previous seed
        :type base_instruction: :py:class:`MoveInstruction`
        :param base_instruction: The base/current instruction to generate the seed for
        :type next_instruction: :py:class:`Instruction`
        :param next_instruction: The next instruction. This will be a null instruction for the final instruction
        :type request: :py:class:`PlannerRequest`
        :param request: The planning request
        :type global_manip_info: :py:class:`ManipulatorInfo`
        :param global_manip_info: The global manipulator information
        :rtype: :py:class:`CompositeInstruction`
        :return: A composite instruction representing the seed for the base_instruction
        """
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, request, global_manip_info)

# Register SimplePlannerPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerPlanProfile_swigregister(SimplePlannerPlanProfile)

class SimplePlannerCompositeProfile(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerCompositeProfile

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerCompositeProfile(*args))

# Register SimplePlannerCompositeProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerCompositeProfile_swigregister(SimplePlannerCompositeProfile)

class SimplePlannerPlanProfileMap(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::size_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::mapped_type const &":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::key_type const &") -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::key_type const &") -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::key_type const &") -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_asdict(self)

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerPlanProfileMap(*args))

    def empty(self) -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::size_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_size(self)

    def swap(self, v: "SimplePlannerPlanProfileMap") -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::iterator":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::iterator":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_end(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::allocator_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::size_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > >::iterator":
        return _tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_find(self, x)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerPlanProfileMap

# Register SimplePlannerPlanProfileMap in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerPlanProfileMap_swigregister(SimplePlannerPlanProfileMap)

class SimplePlannerCompositeProfileMap(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::size_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::mapped_type const &":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::key_type const &") -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::key_type const &") -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_keys(self)

    def values(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_values(self)

    def items(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::key_type const &") -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_asdict(self)

    def __init__(self, *args):
        _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerCompositeProfileMap(*args))

    def empty(self) -> "bool":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::size_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_size(self)

    def swap(self, v: "SimplePlannerCompositeProfileMap") -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::iterator":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::iterator":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_end(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::allocator_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::size_type":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_count(self, x)

    def erase(self, *args) -> "void":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::key_type const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > >::iterator":
        return _tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_find(self, x)
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerCompositeProfileMap

# Register SimplePlannerCompositeProfileMap in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerCompositeProfileMap_swigregister(SimplePlannerCompositeProfileMap)


def ProfileDictionary_hasProfileEntry_SimplePlannerPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "bool":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_hasProfileEntry_SimplePlannerPlanProfile(profile_dictionary, ns)

def ProfileDictionary_removeProfileEntry_SimplePlannerPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "void":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_removeProfileEntry_SimplePlannerPlanProfile(profile_dictionary, ns)

def ProfileDictionary_getProfileEntry_SimplePlannerPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const >,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const > > > >":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_getProfileEntry_SimplePlannerPlanProfile(profile_dictionary, ns)

def ProfileDictionary_addProfile_SimplePlannerPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &", profile: "std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const >") -> "void":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_addProfile_SimplePlannerPlanProfile(profile_dictionary, ns, profile_name, profile)

def ProfileDictionary_getProfile_SimplePlannerPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "std::shared_ptr< tesseract_planning::SimplePlannerPlanProfile const >":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_getProfile_SimplePlannerPlanProfile(profile_dictionary, ns, profile_name)

def ProfileDictionary_hasProfile_SimplePlannerPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "bool":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_hasProfile_SimplePlannerPlanProfile(profile_dictionary, ns, profile_name)

def ProfileDictionary_removeProfile_SimplePlannerPlanProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "void":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_removeProfile_SimplePlannerPlanProfile(profile_dictionary, ns, profile_name)

def ProfileDictionary_hasProfileEntry_SimplePlannerCompositeProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "bool":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_hasProfileEntry_SimplePlannerCompositeProfile(profile_dictionary, ns)

def ProfileDictionary_removeProfileEntry_SimplePlannerCompositeProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "void":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_removeProfileEntry_SimplePlannerCompositeProfile(profile_dictionary, ns)

def ProfileDictionary_getProfileEntry_SimplePlannerCompositeProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &") -> "std::unordered_map< std::string,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const >,std::hash< std::string >,std::equal_to< std::string >,std::allocator< std::pair< std::string const,std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const > > > >":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_getProfileEntry_SimplePlannerCompositeProfile(profile_dictionary, ns)

def ProfileDictionary_addProfile_SimplePlannerCompositeProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &", profile: "std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const >") -> "void":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_addProfile_SimplePlannerCompositeProfile(profile_dictionary, ns, profile_name, profile)

def ProfileDictionary_getProfile_SimplePlannerCompositeProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "std::shared_ptr< tesseract_planning::SimplePlannerCompositeProfile const >":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_getProfile_SimplePlannerCompositeProfile(profile_dictionary, ns, profile_name)

def ProfileDictionary_hasProfile_SimplePlannerCompositeProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "bool":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_hasProfile_SimplePlannerCompositeProfile(profile_dictionary, ns, profile_name)

def ProfileDictionary_removeProfile_SimplePlannerCompositeProfile(profile_dictionary: "std::shared_ptr< tesseract_planning::ProfileDictionary >", ns: "std::string const &", profile_name: "std::string const &") -> "void":
    return _tesseract_motion_planners_simple_python.ProfileDictionary_removeProfile_SimplePlannerCompositeProfile(profile_dictionary, ns, profile_name)
class SimplePlannerLVSPlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        SimplePlannerLVSPlanProfile
        :type state_longest_valid_segment_length: float, optional
        :param state_longest_valid_segment_length: The maximum joint distance (norm of changes to all joint positions)
            between successive steps
        :type translation_longest_valid_segment_length: float, optional
        :param translation_longest_valid_segment_length: The maximum translation distance between successive steps
        :type rotation_longest_valid_segment_length: float, optional
        :param rotation_longest_valid_segment_length: The maximum rotational distance between successive steps
        :type min_steps: int, optional
        :param min_steps: The minimum number of steps for the plan
        """
        _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerLVSPlanProfile(*args))

    def generate(self, prev_instruction: "MoveInstruction", prev_seed: "MoveInstruction", base_instruction: "MoveInstruction", next_instruction: "Instruction", request: "PlannerRequest", global_manip_info: "ManipulatorInfo") -> "tesseract_planning::CompositeInstruction":
        return _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, request, global_manip_info)
    state_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_state_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_state_longest_valid_segment_length_set, doc=r""" The maximum joint distance, the norm of changes to all joint positions between successive steps.""")
    translation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_translation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_translation_longest_valid_segment_length_set, doc=r""" The maximum translation distance between successive steps""")
    rotation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_rotation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_rotation_longest_valid_segment_length_set, doc=r""" The maximum rotational distance between successive steps""")
    min_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_min_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_min_steps_set, doc=r""" The minimum number of steps for the plan""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerLVSPlanProfile

# Register SimplePlannerLVSPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerLVSPlanProfile_swigregister(SimplePlannerLVSPlanProfile)

class SimplePlannerLVSNoIKPlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        SimplePlannerLVSNoIKPlanProfile
        :type state_longest_valid_segment_length: float, optional
        :param state_longest_valid_segment_length: The maximum joint distance (norm of changes to all joint positions)
            between successive steps
        :type translation_longest_valid_segment_length: float, optional
        :param translation_longest_valid_segment_length: The maximum translation distance between successive steps
        :type rotation_longest_valid_segment_length: float, optional
        :param rotation_longest_valid_segment_length: The maximum rotational distance between successive steps
        :type min_steps: int, optional
        :param min_steps: The minimum number of steps for the plan
        :type max_steps: int, optional
        :param max_steps: The maximum number of steps for the plan
        """
        _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerLVSNoIKPlanProfile(*args))

    def generate(self, prev_instruction: "MoveInstruction", prev_seed: "MoveInstruction", base_instruction: "MoveInstruction", next_instruction: "Instruction", request: "PlannerRequest", global_manip_info: "ManipulatorInfo") -> "tesseract_planning::CompositeInstruction":
        return _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, request, global_manip_info)
    state_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_state_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_state_longest_valid_segment_length_set, doc=r""" The maximum joint distance, the norm of changes to all joint positions between successive steps.""")
    translation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_translation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_translation_longest_valid_segment_length_set, doc=r""" The maximum translation distance between successive steps""")
    rotation_longest_valid_segment_length = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_rotation_longest_valid_segment_length_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_rotation_longest_valid_segment_length_set, doc=r""" The maximum rotational distance between successive steps""")
    min_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_min_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_min_steps_set, doc=r""" The minimum number of steps for the plan""")
    max_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_max_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_max_steps_set, doc=r""" The maximum number of steps for the plan""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerLVSNoIKPlanProfile

# Register SimplePlannerLVSNoIKPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerLVSNoIKPlanProfile_swigregister(SimplePlannerLVSNoIKPlanProfile)

class SimplePlannerFixedSizePlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, freespace_steps: "int"=10, linear_steps: "int"=10):
        r"""
        SimplePlannerFixedSizePlanProfile
        :type freespace_steps: int, optional
        :param freespace_steps: The number of steps to use for freespace instruction
        :type linear_steps: int, optional
        :param linear_steps: The number of steps to use for linear instruction
        """
        _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerFixedSizePlanProfile(freespace_steps, linear_steps))

    def generate(self, prev_instruction: "MoveInstruction", prev_seed: "MoveInstruction", base_instruction: "MoveInstruction", next_instruction: "Instruction", request: "PlannerRequest", global_manip_info: "ManipulatorInfo") -> "tesseract_planning::CompositeInstruction":
        return _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, request, global_manip_info)
    freespace_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_freespace_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_freespace_steps_set, doc=r""" The number of steps to use for freespace instruction""")
    linear_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_linear_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_linear_steps_set, doc=r""" The number of steps to use for linear instruction""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerFixedSizePlanProfile

# Register SimplePlannerFixedSizePlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerFixedSizePlanProfile_swigregister(SimplePlannerFixedSizePlanProfile)

class SimplePlannerFixedSizeAssignPlanProfile(SimplePlannerPlanProfile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, freespace_steps: "int"=10, linear_steps: "int"=10):
        r"""
        SimplePlannerFixedSizeAssignPlanProfile
        :type freespace_steps: int, optional
        :param freespace_steps: The number of steps to use for freespace instruction
        :type linear_steps: int, optional
        :param linear_steps: The number of steps to use for linear instruction
        """
        _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_swiginit(self, _tesseract_motion_planners_simple_python.new_SimplePlannerFixedSizeAssignPlanProfile(freespace_steps, linear_steps))

    def generate(self, prev_instruction: "MoveInstruction", prev_seed: "MoveInstruction", base_instruction: "MoveInstruction", next_instruction: "Instruction", request: "PlannerRequest", global_manip_info: "ManipulatorInfo") -> "tesseract_planning::CompositeInstruction":
        return _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_generate(self, prev_instruction, prev_seed, base_instruction, next_instruction, request, global_manip_info)
    freespace_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_freespace_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_freespace_steps_set, doc=r""" The number of steps to use for freespace instruction""")
    linear_steps = property(_tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_linear_steps_get, _tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_linear_steps_set, doc=r""" The number of steps to use for linear instruction""")
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimplePlannerFixedSizeAssignPlanProfile

# Register SimplePlannerFixedSizeAssignPlanProfile in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimplePlannerFixedSizeAssignPlanProfile_swigregister(SimplePlannerFixedSizeAssignPlanProfile)

class SimpleMotionPlanner(tesseract_robotics.tesseract_motion_planners.tesseract_motion_planners_python.MotionPlanner):
    r"""
    The simple planner is meant to be a tool for assigning values to the seed. The planner simply loops over all
    of the MoveInstructions and then calls the appropriate function from the profile. These functions do not depend on
    the seed, so this may be used to initialize the seed appropriately using e.g. linear interpolation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""" Construct a basic planner"""
        _tesseract_motion_planners_simple_python.SimpleMotionPlanner_swiginit(self, _tesseract_motion_planners_simple_python.new_SimpleMotionPlanner(*args))
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimpleMotionPlanner

    def getName(self) -> "std::string const &":
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_getName(self)

    def solve(self, request: "PlannerRequest", response: "PlannerResponse", verbose: "bool"=False) -> "tesseract_common::StatusCode":
        r"""
        Sets up the optimizer and solves a SQP problem read from json with no callbacks and default parameters
        :type response: :py:class:`PlannerResponse`
        :param response: The results of the optimization. Primary output is the optimized joint trajectory
        :param check_type: The type of collision check to perform on the planned trajectory
        :type verbose: boolean, optional
        :param verbose: Boolean indicating whether logging information about the motion planning solution should be printed
            to console
        :rtype: :py:class:`StatusCode`
        :return: true if optimization complete
        """
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_solve(self, request, response, verbose)

    @staticmethod
    def checkUserInput(request: "PlannerRequest") -> "bool":
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_checkUserInput(request)

    def terminate(self) -> "bool":
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_terminate(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_clear(self)

    def clone(self) -> "tesseract_planning::MotionPlanner::Ptr":
        return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_clone(self)

# Register SimpleMotionPlanner in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimpleMotionPlanner_swigregister(SimpleMotionPlanner)

def SimpleMotionPlanner_checkUserInput(request: "PlannerRequest") -> "bool":
    return _tesseract_motion_planners_simple_python.SimpleMotionPlanner_checkUserInput(request)

class SimpleMotionPlannerStatusCategory(tesseract_robotics.tesseract_common.tesseract_common_python.StatusCategory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, name: "std::string"):
        _tesseract_motion_planners_simple_python.SimpleMotionPlannerStatusCategory_swiginit(self, _tesseract_motion_planners_simple_python.new_SimpleMotionPlannerStatusCategory(name))

    def name(self) -> "std::string const &":
        return _tesseract_motion_planners_simple_python.SimpleMotionPlannerStatusCategory_name(self)

    def message(self, code: "int") -> "std::string":
        return _tesseract_motion_planners_simple_python.SimpleMotionPlannerStatusCategory_message(self, code)
    SolutionFound = _tesseract_motion_planners_simple_python.SimpleMotionPlannerStatusCategory_SolutionFound
    ErrorInvalidInput = _tesseract_motion_planners_simple_python.SimpleMotionPlannerStatusCategory_ErrorInvalidInput
    FailedToFindValidSolution = _tesseract_motion_planners_simple_python.SimpleMotionPlannerStatusCategory_FailedToFindValidSolution
    __swig_destroy__ = _tesseract_motion_planners_simple_python.delete_SimpleMotionPlannerStatusCategory

# Register SimpleMotionPlannerStatusCategory in _tesseract_motion_planners_simple_python:
_tesseract_motion_planners_simple_python.SimpleMotionPlannerStatusCategory_swigregister(SimpleMotionPlannerStatusCategory)



