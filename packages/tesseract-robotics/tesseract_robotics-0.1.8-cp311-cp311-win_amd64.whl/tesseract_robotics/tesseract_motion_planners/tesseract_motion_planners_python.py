# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_motion_planners_python
else:
    import _tesseract_motion_planners_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_motion_planners_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_motion_planners_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_motion_planners_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_motion_planners_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_motion_planners_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_motion_planners_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_motion_planners_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_motion_planners_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_motion_planners_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_motion_planners_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_motion_planners_python:
_tesseract_motion_planners_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_motion_planners_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_motion_planners_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_motion_planners_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_motion_planners_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_motion_planners_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_motion_planners_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_motion_planners_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_motion_planners_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_motion_planners_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_motion_planners_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_motion_planners_python.vector_eigen_index_swiginit(self, _tesseract_motion_planners_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_motion_planners_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_motion_planners_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_motion_planners_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_motion_planners_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_motion_planners_python:
_tesseract_motion_planners_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_environment.tesseract_environment_python
import tesseract_robotics.tesseract_kinematics.tesseract_kinematics_python
import tesseract_robotics.tesseract_common.tesseract_common_python
import tesseract_robotics.tesseract_scene_graph.tesseract_scene_graph_python
import tesseract_robotics.tesseract_geometry.tesseract_geometry_python
import tesseract_robotics.tesseract_srdf.tesseract_srdf_python
import tesseract_robotics.tesseract_state_solver.tesseract_state_solver_python
import tesseract_robotics.tesseract_collision.tesseract_collision_python
import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
class PlannerProfileRemappingUPtr(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_motion_planners_python.PlannerProfileRemappingUPtr_swiginit(self, _tesseract_motion_planners_python.new_PlannerProfileRemappingUPtr(*args))

    def __deref__(self) -> "std::unique_ptr< tesseract_planning::PlannerProfileRemapping >::pointer":
        return _tesseract_motion_planners_python.PlannerProfileRemappingUPtr___deref__(self)

    def release(self) -> "std::unique_ptr< tesseract_planning::PlannerProfileRemapping >::pointer":
        return _tesseract_motion_planners_python.PlannerProfileRemappingUPtr_release(self)

    def reset(self, *args) -> "void":
        return _tesseract_motion_planners_python.PlannerProfileRemappingUPtr_reset(self, *args)

    def swap(self, __u: "PlannerProfileRemappingUPtr") -> "void":
        return _tesseract_motion_planners_python.PlannerProfileRemappingUPtr_swap(self, __u)

    def get(self) -> "std::unique_ptr< tesseract_planning::PlannerProfileRemapping >::pointer":
        return _tesseract_motion_planners_python.PlannerProfileRemappingUPtr_get(self)

    def __nonzero__(self):
        return _tesseract_motion_planners_python.PlannerProfileRemappingUPtr___nonzero__(self)
    __bool__ = __nonzero__


    __swig_destroy__ = _tesseract_motion_planners_python.delete_PlannerProfileRemappingUPtr

# Register PlannerProfileRemappingUPtr in _tesseract_motion_planners_python:
_tesseract_motion_planners_python.PlannerProfileRemappingUPtr_swigregister(PlannerProfileRemappingUPtr)
cvar = _tesseract_motion_planners_python.cvar
SIMPLE_DEFAULT_NAMESPACE = cvar.SIMPLE_DEFAULT_NAMESPACE
DESCARTES_DEFAULT_NAMESPACE = cvar.DESCARTES_DEFAULT_NAMESPACE
OMPL_DEFAULT_NAMESPACE = cvar.OMPL_DEFAULT_NAMESPACE
TRAJOPT_DEFAULT_NAMESPACE = cvar.TRAJOPT_DEFAULT_NAMESPACE
TRAJOPT_IFOPT_DEFAULT_NAMESPACE = cvar.TRAJOPT_IFOPT_DEFAULT_NAMESPACE

class PlannerRequest(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    name = property(_tesseract_motion_planners_python.PlannerRequest_name_get, _tesseract_motion_planners_python.PlannerRequest_name_set, doc=r""" The name of the process manager to use""")
    env = property(_tesseract_motion_planners_python.PlannerRequest_env_get, _tesseract_motion_planners_python.PlannerRequest_env_set, doc=r""" The environment""")
    env_state = property(_tesseract_motion_planners_python.PlannerRequest_env_state_get, _tesseract_motion_planners_python.PlannerRequest_env_state_set, doc=r""" The start state to use for planning""")
    profiles = property(_tesseract_motion_planners_python.PlannerRequest_profiles_get, _tesseract_motion_planners_python.PlannerRequest_profiles_set, doc=r""" The profile dictionary""")
    instructions = property(_tesseract_motion_planners_python.PlannerRequest_instructions_get, _tesseract_motion_planners_python.PlannerRequest_instructions_set, doc=r"""
    The program instruction
    This must contain a minimum of two move instruction the first move instruction is the start state
    """)
    seed = property(_tesseract_motion_planners_python.PlannerRequest_seed_get, _tesseract_motion_planners_python.PlannerRequest_seed_set, doc=r"""
    This should be a one to one match with the instructions where the MoveInstruction is replaced with a
    CompositeInstruction of MoveInstructions.
    """)
    plan_profile_remapping = property(_tesseract_motion_planners_python.PlannerRequest_plan_profile_remapping_get, _tesseract_motion_planners_python.PlannerRequest_plan_profile_remapping_set, doc=r"""
    This allows the remapping of the Plan Profile identified in the command language to a specific profile for a
    given motion planner.
    """)
    composite_profile_remapping = property(_tesseract_motion_planners_python.PlannerRequest_composite_profile_remapping_get, _tesseract_motion_planners_python.PlannerRequest_composite_profile_remapping_set, doc=r"""
    This allows the remapping of the Composite Profile identified in the command language to a specific profile
    for a given motion planner.
    """)
    data = property(_tesseract_motion_planners_python.PlannerRequest_data_get, _tesseract_motion_planners_python.PlannerRequest_data_set, doc=r"""
    data Planner specific data. For planners included in Tesseract_planning this is the planner problem that
    will be used if it is not null
    """)

    def __init__(self):
        _tesseract_motion_planners_python.PlannerRequest_swiginit(self, _tesseract_motion_planners_python.new_PlannerRequest())
    __swig_destroy__ = _tesseract_motion_planners_python.delete_PlannerRequest

# Register PlannerRequest in _tesseract_motion_planners_python:
_tesseract_motion_planners_python.PlannerRequest_swigregister(PlannerRequest)

class PlannerResponse(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    results = property(_tesseract_motion_planners_python.PlannerResponse_results_get, _tesseract_motion_planners_python.PlannerResponse_results_set)
    status = property(_tesseract_motion_planners_python.PlannerResponse_status_get, _tesseract_motion_planners_python.PlannerResponse_status_set, doc=r""" The status information""")
    succeeded_instructions = property(_tesseract_motion_planners_python.PlannerResponse_succeeded_instructions_get, _tesseract_motion_planners_python.PlannerResponse_succeeded_instructions_set, doc=r""" Waypoints for which the planner succeeded""")
    failed_instructions = property(_tesseract_motion_planners_python.PlannerResponse_failed_instructions_get, _tesseract_motion_planners_python.PlannerResponse_failed_instructions_set, doc=r""" Waypoints for which the planner failed""")
    data = property(_tesseract_motion_planners_python.PlannerResponse_data_get, _tesseract_motion_planners_python.PlannerResponse_data_set, doc=r""" Planner specific data. Planners in Tesseract_planning use this to store the planner problem that was solved""")

    def __init__(self):
        _tesseract_motion_planners_python.PlannerResponse_swiginit(self, _tesseract_motion_planners_python.new_PlannerResponse())
    __swig_destroy__ = _tesseract_motion_planners_python.delete_PlannerResponse

# Register PlannerResponse in _tesseract_motion_planners_python:
_tesseract_motion_planners_python.PlannerResponse_swigregister(PlannerResponse)

class MotionPlanner(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_motion_planners_python.delete_MotionPlanner

    def getName(self) -> "std::string const &":
        r"""
        Get the name of this planner
        This is also used as the namespace for the profiles in the profile dictionary
        """
        return _tesseract_motion_planners_python.MotionPlanner_getName(self)

    def solve(self, request: "PlannerRequest", response: "PlannerResponse", verbose: "bool"=False) -> "tesseract_common::StatusCode":
        r"""
        Solve the planner request problem
        :type request: :py:class:`PlannerRequest`
        :param request: The planning request
        :type response: :py:class:`PlannerResponse`
        :param response: The results from the planner
        :param check_type: The type of validation check to be performed on the planned trajectory
        :type verbose: boolean, optional
        :param verbose: Flag for printing more detailed planning information
        :rtype: :py:class:`StatusCode`
        :return: A code indicating the status of the planned trajectory
        """
        return _tesseract_motion_planners_python.MotionPlanner_solve(self, request, response, verbose)

    def terminate(self) -> "bool":
        r"""
        If solve() is running, terminate the computation. Return false if termination not possible. No-op if
        solve() is not running (returns true).
        """
        return _tesseract_motion_planners_python.MotionPlanner_terminate(self)

    def clear(self) -> "void":
        r""" Clear the data structures used by the planner"""
        return _tesseract_motion_planners_python.MotionPlanner_clear(self)

    def clone(self) -> "tesseract_planning::MotionPlanner::Ptr":
        r""" Clone the motion planner"""
        return _tesseract_motion_planners_python.MotionPlanner_clone(self)

# Register MotionPlanner in _tesseract_motion_planners_python:
_tesseract_motion_planners_python.MotionPlanner_swigregister(MotionPlanner)

RobotConfig_NUT = _tesseract_motion_planners_python.RobotConfig_NUT
RobotConfig_FUT = _tesseract_motion_planners_python.RobotConfig_FUT
RobotConfig_NDT = _tesseract_motion_planners_python.RobotConfig_NDT
RobotConfig_FDT = _tesseract_motion_planners_python.RobotConfig_FDT
RobotConfig_NDB = _tesseract_motion_planners_python.RobotConfig_NDB
RobotConfig_FDB = _tesseract_motion_planners_python.RobotConfig_FDB
RobotConfig_NUB = _tesseract_motion_planners_python.RobotConfig_NUB
RobotConfig_FUB = _tesseract_motion_planners_python.RobotConfig_FUB

def getRobotConfig(*args) -> "tesseract_planning::RobotConfig":
    r"""
    Get the configuration of a six axis industrial robot
    :type joint_group: :py:class:`JointGroup`
    :param joint_group: The kinematics JointGroup.
    :type base_link: string
    :param base_link: The base link to use.
    :type tcp_frame: string
    :param tcp_frame: The tip link to use.
    :type joint_values: Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const >
    :param joint_values: The joint group joint values and assumes the last six are for the robot.
    :type sign_correction: Eigen::Ref< Eigen::Vector2i const >, optional
    :param sign_correction: Correct the sign for Joint 3 and Joint 5 based on the robot manufacturer.
    :rtype: int
    :return: Robot Config
    """
    return _tesseract_motion_planners_python.getRobotConfig(*args)

def getJointTurns(joint_values: "Eigen::Ref< Eigen::Matrix< double,Eigen::Dynamic,1 > const > const &") -> "Eigen::VectorXi":
    r"""
    Get number of turns for joints that allow rotation beyond +- 180 degrees
    :param joint: values The joint values of the robot
    :rtype: Eigen::VectorXi
    :return: The number of turns (as integers), in a vector
    """
    return _tesseract_motion_planners_python.getJointTurns(joint_values)

def generateSeed(*args) -> "tesseract_planning::CompositeInstruction":
    r""" Provided for backwards compatibility"""
    return _tesseract_motion_planners_python.generateSeed(*args)

def toToolpath(instruction: "Instruction", env: "Environment") -> "tesseract_common::Toolpath":
    r"""
    Extract toolpath from a composite instruction
    :type instruction: :py:class:`Instruction`
    :param instruction: The instruction to extract toolpath
    :type env: :py:class:`Environment`
    :param env: The environment object used for getting kinematics and tcp information
    :rtype: tesseract_common::Toolpath
    :return: A toolpath in world coordinate system
    """
    return _tesseract_motion_planners_python.toToolpath(instruction, env)

def interpolate(*args) -> "Eigen::MatrixXd":
    r"""
    *Overload 1:*

    Interpolate between two transforms return a vector of Eigen::Isometry transforms.
    :type start: :py:class:`Isometry3d`
    :param start: The Start Transform
    :type stop: :py:class:`Isometry3d`
    :param stop: The Stop/End Transform
    :type steps: int
    :param steps: The number of step
    :rtype: :py:class:`VectorIsometry3d`
    :return: A vector of Eigen::Isometry with a length = steps + 1

    |

    *Overload 2:*

    Interpolate between two Eigen::VectorXd and return a Matrix
    :type start: Eigen::Ref< Eigen::VectorXd const >
    :param start: The Start State
    :type stop: Eigen::Ref< Eigen::VectorXd const >
    :param stop: The Stop/End State
    :type steps: int
    :param steps: The number of step
    :rtype: Eigen::MatrixXd
    :return: A matrix where columns = steps + 1
    """
    return _tesseract_motion_planners_python.interpolate(*args)

def interpolate_waypoint(start: "Waypoint", stop: "Waypoint", steps: "long") -> "std::vector< tesseract_planning::Waypoint,std::allocator< tesseract_planning::Waypoint > >":
    r"""
    Interpolate between two waypoints return a vector of waypoints.
    :type start: :py:class:`Waypoint`
    :param start: The Start Waypoint
    :type stop: :py:class:`Waypoint`
    :param stop: The Stop/End Waypoint
    :type steps: int
    :param steps: The number of step
    :rtype: std::vector< tesseract_planning::Waypoint,std::allocator< tesseract_planning::Waypoint > >
    :return: A vector of waypoints with a length = steps + 1
    """
    return _tesseract_motion_planners_python.interpolate_waypoint(start, stop, steps)

def programFlattenFilter(instruction: "Instruction", composite: "CompositeInstruction", parent_is_first_composite: "bool") -> "bool":
    r"""
    A program flatten filter
    :type instruction: :py:class:`Instruction`
    :param instruction: The instruction to flatten
    :type composite: :py:class:`CompositeInstruction`
    :param composite: The parent composite the instruction is associated with
    :type parent_is_first_composite: boolean
    :param parent_is_first_composite: Indicate if this is the top most composite
    :rtype: boolean
    :return: True if successful, otherwise false
    """
    return _tesseract_motion_planners_python.programFlattenFilter(instruction, composite, parent_is_first_composite)

def flattenProgram(*args) -> "std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >":
    r"""
    *Overload 1:*

    Flattens a CompositeInstruction into a vector of Instruction

    If /p composite_instruction parameter has a start instruction it is added but child composites are not check for
    start instructions.

    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Input composite instruction to be flattened
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction > > >
    :return: A new flattened vector referencing the original instruction elements

    |

    *Overload 2:*

    Flattens a CompositeInstruction into a vector of Instruction

    If /p composite_instruction parameter has a start instruction it is added but child composites are not check for
    start instructions.

    :type composite_instruction: :py:class:`CompositeInstruction`
    :param composite_instruction: Input composite instruction to be flattened
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >
    :return: A new flattened vector (const) referencing the original instruction elements
    """
    return _tesseract_motion_planners_python.flattenProgram(*args)

def flattenProgramToPattern(*args) -> "std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >":
    r"""
    *Overload 1:*

    Flattens a composite instruction to the same pattern as the pattern composite instruction. ie, an element of
    instruction will only be flattened if the corresponding element in pattern is flatten-able.

    If /p composite_instruction parameter has a start instruction it is added but child composites are not check for
    start instructions.

    The motivation for this utility is a case where you flatten only the elements in a seed that correspond to composites
    in the parent instruction

    :param instruction: CompositeInstruction that will be flattened
    :type pattern: :py:class:`CompositeInstruction`
    :param pattern: CompositeInstruction used to determine if instruction will be flattened
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction > > >
    :return: A new flattened vector referencing the original instruction elements

    |

    *Overload 2:*

    Flattens a composite instruction to the same pattern as the pattern composite instruction. ie, an element of
    instruction will only be flattened if the corresponding element in pattern is flatten-able.

    If /p composite_instruction parameter has a start instruction it is added but child composites are not check for
    start instructions.

    The motivation for this utility is a case where you flatten only the elements in a seed that correspond to composites
    in the parent instruction

    :param instruction: CompositeInstruction that will be flattened
    :type pattern: :py:class:`CompositeInstruction`
    :param pattern: CompositeInstruction used to determine if instruction will be flattened
    :rtype: std::vector< std::reference_wrapper< tesseract_planning::Instruction const >,std::allocator< std::reference_wrapper< tesseract_planning::Instruction const > > >
    :return: A new flattened vector (const) referencing the original instruction elements
    """
    return _tesseract_motion_planners_python.flattenProgramToPattern(*args)

def contactCheckProgram(*args) -> "bool":
    r"""
    *Overload 1:*

    Should perform a continuous collision check over the trajectory.
    :type contacts: std::vector< tesseract_collision::ContactResultMap,std::allocator< tesseract_collision::ContactResultMap > >
    :param contacts: A vector of vector of ContactMap where each index corresponds to a timestep
    :type manager: :py:class:`ContinuousContactManager`
    :param manager: A continuous contact manager
    :type state_solver: :py:class:`StateSolver`
    :param state_solver: The environment state solver
    :type program: :py:class:`CompositeInstruction`
    :param program: The program to check for contacts
    :type config: :py:class:`CollisionCheckConfig`
    :param config: CollisionCheckConfig used to specify collision check settings
    :rtype: boolean
    :return: True if collision was found, otherwise false.

    |

    *Overload 2:*

    Should perform a discrete collision check over the trajectory
    :type contacts: std::vector< tesseract_collision::ContactResultMap,std::allocator< tesseract_collision::ContactResultMap > >
    :param contacts: A vector of vector of ContactMap where each index corresponds to a timestep
    :type manager: :py:class:`DiscreteContactManager`
    :param manager: A continuous contact manager
    :type state_solver: :py:class:`StateSolver`
    :param state_solver: The environment state solver
    :type program: :py:class:`CompositeInstruction`
    :param program: The program to check for contacts
    :type config: :py:class:`CollisionCheckConfig`
    :param config: CollisionCheckConfig used to specify collision check settings
    :rtype: boolean
    :return: True if collision was found, otherwise false.
    """
    return _tesseract_motion_planners_python.contactCheckProgram(*args)

def generateNaiveSeed(composite_instructions: "CompositeInstruction", env: "Environment") -> "tesseract_planning::CompositeInstruction":
    r"""
    This generates a naive seed for the provided program
    This will generate a seed where each plan instruction has a single move instruction associated to it using
    the current state.
    :type composite_instructions: :py:class:`CompositeInstruction`
    :param composite_instructions: The input program
    :type env: :py:class:`Environment`
    :param env: The environment information
    :rtype: :py:class:`CompositeInstruction`
    :return: The generated seed
    """
    return _tesseract_motion_planners_python.generateNaiveSeed(composite_instructions, env)

def formatProgram(composite_instructions: "CompositeInstruction", env: "Environment") -> "bool":
    r"""
    This formats the joint and state waypoints to align with the kinematics object
    :type composite_instructions: :py:class:`CompositeInstruction`
    :param composite_instructions: The input program to format
    :type env: :py:class:`Environment`
    :param env: The environment information
    :rtype: boolean
    :return: True if the program required formatting.
    """
    return _tesseract_motion_planners_python.formatProgram(composite_instructions, env)

RobotConfigString = cvar.RobotConfigString

