# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tesseract_time_parameterization_python
else:
    import _tesseract_time_parameterization_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _tesseract_time_parameterization_python.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tesseract_time_parameterization_python.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_time_parameterization_python.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tesseract_time_parameterization_python.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tesseract_time_parameterization_python.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_time_parameterization_python.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tesseract_time_parameterization_python.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tesseract_time_parameterization_python.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tesseract_time_parameterization_python.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tesseract_time_parameterization_python.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_time_parameterization_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_time_parameterization_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tesseract_time_parameterization_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_time_parameterization_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tesseract_time_parameterization_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tesseract_time_parameterization_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tesseract_time_parameterization_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.SwigPyIterator_swigregister(SwigPyIterator)

class vector_eigen_index(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _tesseract_time_parameterization_python.vector_eigen_index_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _tesseract_time_parameterization_python.vector_eigen_index___nonzero__(self)

    def __bool__(self) -> "bool":
        return _tesseract_time_parameterization_python.vector_eigen_index___bool__(self)

    def __len__(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_time_parameterization_python.vector_eigen_index___len__(self)

    def __getslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "std::vector< ptrdiff_t,std::allocator< ptrdiff_t > > *":
        return _tesseract_time_parameterization_python.vector_eigen_index___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< ptrdiff_t >::difference_type", j: "std::vector< ptrdiff_t >::difference_type") -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_time_parameterization_python.vector_eigen_index___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index___setitem__(self, *args)

    def pop(self) -> "std::vector< ptrdiff_t >::value_type":
        return _tesseract_time_parameterization_python.vector_eigen_index_pop(self)

    def append(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_append(self, x)

    def empty(self) -> "bool":
        return _tesseract_time_parameterization_python.vector_eigen_index_empty(self)

    def size(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_time_parameterization_python.vector_eigen_index_size(self)

    def swap(self, v: "vector_eigen_index") -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_swap(self, v)

    def begin(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_time_parameterization_python.vector_eigen_index_begin(self)

    def end(self) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_time_parameterization_python.vector_eigen_index_end(self)

    def rbegin(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_time_parameterization_python.vector_eigen_index_rbegin(self)

    def rend(self) -> "std::vector< ptrdiff_t >::reverse_iterator":
        return _tesseract_time_parameterization_python.vector_eigen_index_rend(self)

    def clear(self) -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_clear(self)

    def get_allocator(self) -> "std::vector< ptrdiff_t >::allocator_type":
        return _tesseract_time_parameterization_python.vector_eigen_index_get_allocator(self)

    def pop_back(self) -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_pop_back(self)

    def erase(self, *args) -> "std::vector< ptrdiff_t >::iterator":
        return _tesseract_time_parameterization_python.vector_eigen_index_erase(self, *args)

    def __init__(self, *args):
        _tesseract_time_parameterization_python.vector_eigen_index_swiginit(self, _tesseract_time_parameterization_python.new_vector_eigen_index(*args))

    def push_back(self, x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_push_back(self, x)

    def front(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_time_parameterization_python.vector_eigen_index_front(self)

    def back(self) -> "std::vector< ptrdiff_t >::value_type const &":
        return _tesseract_time_parameterization_python.vector_eigen_index_back(self)

    def assign(self, n: "std::vector< ptrdiff_t >::size_type", x: "std::vector< ptrdiff_t >::value_type const &") -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_resize(self, *args)

    def insert(self, *args) -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_insert(self, *args)

    def reserve(self, n: "std::vector< ptrdiff_t >::size_type") -> "void":
        return _tesseract_time_parameterization_python.vector_eigen_index_reserve(self, n)

    def capacity(self) -> "std::vector< ptrdiff_t >::size_type":
        return _tesseract_time_parameterization_python.vector_eigen_index_capacity(self)
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_vector_eigen_index

# Register vector_eigen_index in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.vector_eigen_index_swigregister(vector_eigen_index)

import tesseract_robotics.tesseract_command_language.tesseract_command_language_python
import tesseract_robotics.tesseract_common.tesseract_common_python
class TrajectoryContainer(object, metaclass=_SwigNonDynamicMeta):
    r""" A generic container that the time parameterization classes use"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_TrajectoryContainer

    def getPosition(self, i: "Eigen::Index") -> "Eigen::VectorXd const &":
        r"""
        Get the position data at a given index
        :type i: Eigen::Index
        :param i: The index to extract position data
        :rtype: Eigen::VectorXd
        :return: The position data
        """
        return _tesseract_time_parameterization_python.TrajectoryContainer_getPosition(self, i)

    def getVelocity(self, i: "Eigen::Index") -> "Eigen::VectorXd const &":
        r"""
        Get the velocity data at a given index
        :type i: Eigen::Index
        :param i: The index to extract velocity data
        :rtype: Eigen::VectorXd
        :return: The velocity data
        """
        return _tesseract_time_parameterization_python.TrajectoryContainer_getVelocity(self, i)

    def getAcceleration(self, i: "Eigen::Index") -> "Eigen::VectorXd const &":
        r"""
        Get the acceleration data at a given index
        :type i: Eigen::Index
        :param i: The index to extract acceleration data
        :rtype: Eigen::VectorXd
        :return: The acceleration data
        """
        return _tesseract_time_parameterization_python.TrajectoryContainer_getAcceleration(self, i)

    def getTimeFromStart(self, i: "Eigen::Index") -> "double":
        r"""
        Get the time from start at a given index
        :type i: Eigen::Index
        :param i: The index to extract time from start
        :rtype: float
        :return: The time from start
        """
        return _tesseract_time_parameterization_python.TrajectoryContainer_getTimeFromStart(self, i)

    def setData(self, i: "Eigen::Index", velocity: "Eigen::VectorXd const &", acceleration: "Eigen::VectorXd const &", time: "double") -> "void":
        r"""
        Set data for a given index
        :type i: Eigen::Index
        :param i: The index to set data
        :type velocity: Eigen::VectorXd
        :param velocity: The velocity data to assign to index
        :type acceleration: Eigen::VectorXd
        :param acceleration: The acceleration data to assign to index
        :type time: float
        :param time: The time from start to assign to index
        """
        return _tesseract_time_parameterization_python.TrajectoryContainer_setData(self, i, velocity, acceleration, time)

    def size(self) -> "Eigen::Index":
        r""" The size of the path"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_size(self)

    def dof(self) -> "Eigen::Index":
        r""" The degree of freedom for the path"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_dof(self)

    def empty(self) -> "bool":
        r""" Check if the path is empty"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_empty(self)

    def isTimeStrictlyIncreasing(self) -> "bool":
        r""" Check if time is strictly increasing"""
        return _tesseract_time_parameterization_python.TrajectoryContainer_isTimeStrictlyIncreasing(self)

# Register TrajectoryContainer in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.TrajectoryContainer_swigregister(TrajectoryContainer)

class InstructionsTrajectory(TrajectoryContainer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _tesseract_time_parameterization_python.InstructionsTrajectory_swiginit(self, _tesseract_time_parameterization_python.new_InstructionsTrajectory(*args))

    def getPosition(self, i: "Eigen::Index") -> "Eigen::VectorXd const &":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getPosition(self, i)

    def getVelocity(self, i: "Eigen::Index") -> "Eigen::VectorXd const &":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getVelocity(self, i)

    def getAcceleration(self, i: "Eigen::Index") -> "Eigen::VectorXd const &":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getAcceleration(self, i)

    def getTimeFromStart(self, i: "Eigen::Index") -> "double":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_getTimeFromStart(self, i)

    def setData(self, i: "Eigen::Index", velocity: "Eigen::VectorXd const &", acceleration: "Eigen::VectorXd const &", time: "double") -> "void":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_setData(self, i, velocity, acceleration, time)

    def size(self) -> "Eigen::Index":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_size(self)

    def dof(self) -> "Eigen::Index":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_dof(self)

    def empty(self) -> "bool":
        return _tesseract_time_parameterization_python.InstructionsTrajectory_empty(self)
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_InstructionsTrajectory

# Register InstructionsTrajectory in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.InstructionsTrajectory_swigregister(InstructionsTrajectory)

class IterativeSplineParameterization(object, metaclass=_SwigNonDynamicMeta):
    r"""
    This class sets the timestamps of a trajectory
    to enforce velocity, acceleration constraints.
    Initial/final velocities and accelerations may be specified in the trajectory.
    Velocity and acceleration limits are specified in the model.

    This algorithm repeatedly fits a cubic spline, adjusts the timing intervals,
    and repeats until all constraints are satisfied.
    When finished, each trajectory waypoint will have the time set,
    as well as the velocities and accelerations for each joint.
    Since we fit to a cubic spline, the position, velocity, and
    acceleration will be continuous and within bounds.
    The jerk will be discontinuous.

    To match the velocity and acceleration at the endpoints,
    the second and second-last point locations need to move.
    By default, two extra points are added to leave the original trajectory unaffected.
    If points are not added, the trajectory could potentially be faster,
    but the 2nd and 2nd-last points should be re-checked for collisions.

    Migration notes:  If migrating from Iterative Parabolic Time Parameterization,
    be aware that the velocity and acceleration limits are more strictly enforced
    using this technique.
    This means that time-parameterizing the same trajectory with the same
    velocity and acceleration limits, will result in a longer trajectory.
    If this is a problem, try retuning (increasing) the limits.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_IterativeSplineParameterization

    def __init__(self, *args):
        _tesseract_time_parameterization_python.IterativeSplineParameterization_swiginit(self, _tesseract_time_parameterization_python.new_IterativeSplineParameterization(*args))

    def compute(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :type max_velocity_scaling_factor: float, optional
        :param max_velocity_scaling_factor: The max velocity scaling factor
        :type max_acceleration_scaling_factor: float, optional
        :param max_acceleration_scaling_factor: The max acceleration scaling factor
        :rtype: boolean
        :return: True if successful, otherwise false

        |

        *Overload 2:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :type max_velocity_scaling_factor: float, optional
        :param max_velocity_scaling_factor: The max velocity scaling factor
        :type max_acceleration_scaling_factor: float, optional
        :param max_acceleration_scaling_factor: The max acceleration scaling factor
        :rtype: boolean
        :return: True if successful, otherwise false

        |

        *Overload 3:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :type max_velocity_scaling_factor: float, optional
        :param max_velocity_scaling_factor: The max velocity scaling factor
        :param max_acceleration_scaling_factor: The max acceleration scaling factor
        :rtype: boolean
        :return: True if successful, otherwise false

        |

        *Overload 4:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :param max_velocity_scaling_factor: The max velocity scaling factor
        :param max_acceleration_scaling_factor: The max acceleration scaling factor
        :rtype: boolean
        :return: True if successful, otherwise false

        |

        *Overload 5:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :type max_velocity_scaling_factor: float, optional
        :param max_velocity_scaling_factor: The max velocity scaling factor
        :type max_acceleration_scaling_factor: float, optional
        :param max_acceleration_scaling_factor: The max acceleration scaling factor
        :rtype: boolean
        :return: True if successful, otherwise false

        |

        *Overload 6:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :type max_velocity_scaling_factor: float, optional
        :param max_velocity_scaling_factor: The max velocity scaling factor
        :param max_acceleration_scaling_factor: The max acceleration scaling factor
        :rtype: boolean
        :return: True if successful, otherwise false

        |

        *Overload 7:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :param max_velocity_scaling_factor: The max velocity scaling factor
        :param max_acceleration_scaling_factor: The max acceleration scaling factor
        :rtype: boolean
        :return: True if successful, otherwise false

        |

        *Overload 8:*

        Compute the time stamps for a flattened vector of move instruction
        :type trajectory: :py:class:`TrajectoryContainer`
        :param trajectory: Flattended vector of move instruction
        :param max_velocities: The max velocities for each joint
        :param max_accelerations: The max acceleration for each joint
        :param max_velocity_scaling_factor: The max velocity scaling factor. Size should be trajectory.size()
        :param max_acceleration_scaling_factor: The max acceleration scaling factor. Size should be trajectory.size()
        :rtype: boolean
        :return: True if successful, otherwise false
        """
        return _tesseract_time_parameterization_python.IterativeSplineParameterization_compute(self, *args)

# Register IterativeSplineParameterization in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.IterativeSplineParameterization_swigregister(IterativeSplineParameterization)

class TimeOptimalTrajectoryGeneration(object, metaclass=_SwigNonDynamicMeta):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __setattr__ = _swig_setattr_nondynamic_instance_variable(object.__setattr__)
    __repr__ = _swig_repr

    def __init__(self, path_tolerance: "double"=0.1, resample_dt: "double"=0.1, min_angle_change: "double"=0.001):
        _tesseract_time_parameterization_python.TimeOptimalTrajectoryGeneration_swiginit(self, _tesseract_time_parameterization_python.new_TimeOptimalTrajectoryGeneration(path_tolerance, resample_dt, min_angle_change))

    def computeTimeStamps(self, *args) -> "bool":
        return _tesseract_time_parameterization_python.TimeOptimalTrajectoryGeneration_computeTimeStamps(self, *args)
    __swig_destroy__ = _tesseract_time_parameterization_python.delete_TimeOptimalTrajectoryGeneration

# Register TimeOptimalTrajectoryGeneration in _tesseract_time_parameterization_python:
_tesseract_time_parameterization_python.TimeOptimalTrajectoryGeneration_swigregister(TimeOptimalTrajectoryGeneration)



