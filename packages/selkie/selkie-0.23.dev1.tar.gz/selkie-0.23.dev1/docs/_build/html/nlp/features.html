<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>selkie.features — Non-recursive features &mdash; Selkie 0.22 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="selkie.avs — Recursive feature structures" href="avs.html" />
    <link rel="prev" title="selkie.dep — Dependency conversion" href="dep.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Selkie
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../todo.html">To Do</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyext/index.html">Python extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/index.html">Web Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/index.html">General-purpose tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../corpus/index.html">Corpus processing</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The NLP pipeline</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="fsa.html"><code class="docutils literal notranslate"><span class="pre">selkie.fsa</span></code> — Finite-state automata</a></li>
<li class="toctree-l2"><a class="reference internal" href="fst.html"><code class="docutils literal notranslate"><span class="pre">selkie.fst</span></code> — Finite-state transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="tree.html"><code class="docutils literal notranslate"><span class="pre">selkie.tree</span></code> — Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="stemmer.html"><code class="docutils literal notranslate"><span class="pre">selkie.stemmer</span></code> — English stemmer</a></li>
<li class="toctree-l2"><a class="reference internal" href="head.html"><code class="docutils literal notranslate"><span class="pre">selkie.head</span></code> — Head marking</a></li>
<li class="toctree-l2"><a class="reference internal" href="dep.html"><code class="docutils literal notranslate"><span class="pre">selkie.dep</span></code> — Dependency conversion</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">selkie.features</span></code> — Non-recursive features</a></li>
<li class="toctree-l2"><a class="reference internal" href="avs.html"><code class="docutils literal notranslate"><span class="pre">selkie.avs</span></code> — Recursive feature structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="grammar.html"><code class="docutils literal notranslate"><span class="pre">selkie.grammar</span></code> — Constituent grammars</a></li>
<li class="toctree-l2"><a class="reference internal" href="gdev.html"><code class="docutils literal notranslate"><span class="pre">selkie.gdev</span></code> — Grammar development tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen.html"><code class="docutils literal notranslate"><span class="pre">selkie.gen</span></code> — Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="parser.html"><code class="docutils literal notranslate"><span class="pre">selkie.parser</span></code> — Constituent parser</a></li>
<li class="toctree-l2"><a class="reference internal" href="expr.html"><code class="docutils literal notranslate"><span class="pre">selkie.expr</span></code> — Predicate calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="interp.html"><code class="docutils literal notranslate"><span class="pre">selkie.interp</span></code> — Semantic interpretation</a></li>
<li class="toctree-l2"><a class="reference internal" href="logic.html"><code class="docutils literal notranslate"><span class="pre">selkie.logic</span></code> — Automated reasoning</a></li>
<li class="toctree-l2"><a class="reference internal" href="bot.html"><code class="docutils literal notranslate"><span class="pre">selkie.bot</span></code> — Conversational agent</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../speech/index.html">Speech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/index.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../app_intro/index.html">Web Application Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../db/index.html">Persistent-object database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content/index.html">The Content Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cld/index.html">The CLD application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../uc/index.html">Universal Corpus</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Selkie</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">The NLP pipeline</a></li>
      <li class="breadcrumb-item active"><code class="docutils literal notranslate"><span class="pre">selkie.features</span></code> — Non-recursive features</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/nlp/features.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="selkie-features-non-recursive-features">
<h1><code class="docutils literal notranslate"><span class="pre">selkie.features</span></code> — Non-recursive features<a class="headerlink" href="#selkie-features-non-recursive-features" title="Permalink to this heading"></a></h1>
<section id="atoms-and-atomsets">
<h2>Atoms and AtomSets<a class="headerlink" href="#atoms-and-atomsets" title="Permalink to this heading"></a></h2>
<p>To handle phenomena such as agreement and movement, we need to enrich
syntactic categories with features.  I take a limited approach, in
which only non-recursive features are permitted.</p>
<p>The values of features will be strings or sets of strings.
Sets of strings represent
nodes in a lattice, with <code class="docutils literal notranslate"><span class="pre">None</span></code> representing bottom and
the distinguished string <code class="docutils literal notranslate"><span class="pre">'*'</span></code> representing top.</p>
<p>The class <code class="docutils literal notranslate"><span class="pre">AtomSet</span></code> is used to represent a set of strings.  <code class="docutils literal notranslate"><span class="pre">AtomSet</span></code> is a
specialization of <code class="docutils literal notranslate"><span class="pre">tuple</span></code>.  An atom set will not
work correctly unless its elements are lexicographically sorted; use
the function <code class="docutils literal notranslate"><span class="pre">atomset()</span></code> to create one.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">atomset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">atomset</span><span class="p">([</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;du&#39;</span><span class="p">,</span> <span class="s1">&#39;pl&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Atom sets print out in notation that looks like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">du/pl/sg</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">atomset()</span></code> returns a string instead of an <code class="docutils literal notranslate"><span class="pre">AtomSet</span></code> if
it is given a singleton list:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atomset</span><span class="p">([</span><span class="s1">&#39;hi&#39;</span><span class="p">])</span>
<span class="go">&#39;hi&#39;</span>
</pre></div>
</div>
<p>An atom set behaves like a sorted tuple of strings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;du&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;sg&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;du&#39;</span> <span class="ow">in</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The basic operation on atom sets is to take their <strong>meet</strong>, or
intersection.  This is done with the “<code class="docutils literal notranslate"><span class="pre">*</span></code>” operator.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">atomset</span><span class="p">([</span><span class="s1">&#39;du&#39;</span><span class="p">,</span> <span class="s1">&#39;pauc&#39;</span><span class="p">,</span> <span class="s1">&#39;pl&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="go">du/pl</span>
</pre></div>
</div>
<p>The meet operation is symmetric.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">*</span> <span class="n">x</span>
<span class="go">du/pl</span>
</pre></div>
</div>
<p>It also works with atoms as second argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">*</span> <span class="s1">&#39;du&#39;</span>
<span class="go">&#39;du&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">*</span> <span class="s1">&#39;*&#39;</span>
<span class="go">&#39;*&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">*</span> <span class="s1">&#39;foo&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>There is also a “join” operation (union):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">du/pauc/pl/sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="s1">&#39;foo&#39;</span>
<span class="go">du/foo/pl/sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span>
<span class="go">&#39;*&#39;</span>
</pre></div>
</div>
</section>
<section id="values">
<h2>Values<a class="headerlink" href="#values" title="Permalink to this heading"></a></h2>
<p>A general value is one of: <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (top), an atom set, a string, or
<code class="docutils literal notranslate"><span class="pre">None</span></code> (bottom).  Three functions are provided that handle general
values.</p>
<dl class="py function">
<dt class="sig sig-object py" id="meet">
<span class="sig-name descname"><span class="pre">meet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meet" title="Permalink to this definition"></a></dt>
<dd><p>Returns the meet of two
values.  The meet is the intersection, viewing the values as sets of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">meet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;du&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">&#39;du&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;du&#39;</span><span class="p">,</span> <span class="s1">&#39;pl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meet</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">du/pl/sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meet</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#join" title="Permalink to this definition"></a></dt>
<dd><p>Returns the join of two
values.  The join is the union, viewing the values as sets of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">join</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;du&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">du/pl/sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;du&#39;</span><span class="p">,</span> <span class="s1">&#39;pl&#39;</span><span class="p">)</span>
<span class="go">du/pl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">&#39;*&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">du/pl/sg</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="subsumes">
<span class="sig-name descname"><span class="pre">subsumes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#subsumes" title="Permalink to this definition"></a></dt>
<dd><p>Tests whether
one value subsumes another.  The subsuming value is more general: a
superset, viewed as a set of atoms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">subsumes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsumes</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsumes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsumes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="selkie.features.Category">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">selkie.features.</span></span><span class="sig-name descname"><span class="pre">Category</span></span><a class="headerlink" href="#selkie.features.Category" title="Permalink to this definition"></a></dt>
<dd><p>A category consists of a <strong>type</strong> (symbol) and a list
of <strong>features</strong>.  An example is <code class="docutils literal notranslate"><span class="pre">v[sg,i,0]</span></code>.
Instead of using named attributes, we use positional attributes, and
implement categories as tuples.
For the example just given, the tuple is <code class="docutils literal notranslate"><span class="pre">('v',</span> <span class="pre">'sg',</span> <span class="pre">'i',</span> <span class="pre">'0')</span></code>.</p>
<p>More precisely, we define the class <code class="docutils literal notranslate"><span class="pre">Category</span></code> to be a
specialization of <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, and we define the method
<code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> so that categories print out in the square-bracket
format.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cat</span> <span class="o">=</span> <span class="n">Category</span><span class="p">([</span><span class="s1">&#39;np&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;fem&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cat</span>
<span class="go">np[du/pl/sg,fem]</span>
</pre></div>
</div>
<p>A category can be accessed the same way one accesses a tuple:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;np&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">du/pl/sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The features by themselves can be accessed this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cat</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">(du/pl/sg, &#39;fem&#39;)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="variables-and-bindings">
<h2>Variables and bindings<a class="headerlink" href="#variables-and-bindings" title="Permalink to this heading"></a></h2>
<p>The categories in a rule may contain variables, in addition to
constant values.  An example of a rule with variables is the
following.  Variables are distinguished from constants by beginning
with an underscore:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VP</span><span class="p">[</span><span class="n">_f</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">V</span><span class="p">[</span><span class="n">_f</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>We permit variables <em>only</em> in categories in rules.  They may not
appear in categories in trees.</p>
<p>I use a representation for variables that maximizes simplicity.  When
digesting a rule, the variables are numbered as they are encountered, and
the variable number (starting from 0) represents the variable.  This
has the virtue that a set of bindings for a variable can simply be a
list, indexed by the variables.  For example, the rule:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VP</span><span class="p">[</span><span class="n">_f</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">V</span><span class="p">[</span><span class="n">_f</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">_p</span><span class="p">]</span> <span class="n">PP</span><span class="p">[</span><span class="n">_p</span><span class="p">]</span>
</pre></div>
</div>
<p>is internally represented as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;VP&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="s1">&#39;PP&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>If the variable <code class="docutils literal notranslate"><span class="pre">_f</span></code> has value <code class="docutils literal notranslate"><span class="pre">'sg'</span></code> and <code class="docutils literal notranslate"><span class="pre">_p</span></code> has value
<code class="docutils literal notranslate"><span class="pre">'to'</span></code>, then the bindings are represented by the list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Here is an example of creating a category that contains a variable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">Category</span><span class="p">([</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span>
<span class="go">V[_0,i,0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&#39;V&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">&#39;0&#39;</span>
</pre></div>
</div>
<p>Note that variable <code class="docutils literal notranslate"><span class="pre">0</span></code> prints out as <code class="docutils literal notranslate"><span class="pre">_0</span></code>.</p>
</section>
<section id="category-unification">
<h2>Category unification<a class="headerlink" href="#category-unification" title="Permalink to this heading"></a></h2>
<p>Categories do not have to be identical to match.  Consider the following
example.</p>
<p>We begin with the node 1``V[sg,i,*]``2 at
the bottom center.  Note that “<code class="docutils literal notranslate"><span class="pre">*</span></code>”
is a wildcard: it matches any value.  After creating this node,
the parser performs the <code class="docutils literal notranslate"><span class="pre">start</span></code> action, which looks up
continuations of <code class="docutils literal notranslate"><span class="pre">V[sg,i,*]</span></code>.  It finds the VP rule at the top left.  Written as
tuples, the rule categories and child-node category look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;VP&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="s1">&#39;PP&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The rule also contains bindings for the two variables.  Initially, both
values are wildcards: <code class="docutils literal notranslate"><span class="pre">['*',</span> <span class="pre">'*']</span></code>.
Matching the child category against the first righthand side category
is called <strong>unification</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This is equivalent to replacing the variables with their values, and
comparing each of the corresponding pairs of features.  If all pairs
match, a new set of bindings is created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="o">*</span> <span class="s1">&#39;sg&#39;</span>
<span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="o">*</span> <span class="s1">&#39;*&#39;</span>
</pre></div>
</div>
<p>Unification is a non-destructive process.  Its output is the new set
of bindings.  In this case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">start</span></code> operation creates the first edge: the oval at the
left end of the middle row.
The next step is to <code class="docutils literal notranslate"><span class="pre">combine</span></code> that edge with the second child.
We unify the category after the dot with the category of the second child:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;PP&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="s1">&#39;PP&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;PP&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="s1">&#39;PP&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="o">*</span> <span class="s1">&#39;to&#39;</span>
</pre></div>
</div>
<p>The unification succeeds, and the output is the set of bindings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The result of the <code class="docutils literal notranslate"><span class="pre">combine</span></code> operation is the new edge, with the
dot at the end.</p>
<p>Finally, we call the <code class="docutils literal notranslate"><span class="pre">complete</span></code> operation on the finished edge.
This creates a new node whose category is obtained by
<strong>substituting</strong> the edge bindings into the lefthand side category:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s1">&#39;VP&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;VP&#39;</span><span class="p">,</span> <span class="s1">&#39;sg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="category-operations">
<h2>Category operations<a class="headerlink" href="#category-operations" title="Permalink to this heading"></a></h2>
<p>With this overview in mind, we turn to a more detailed consideration
of the implementation.  The most basic function is <strong>meet</strong>, which
we have already discussed.  It
combines two values <em>u</em> and <em>v</em>.  Specifically, if <em>u=v</em>, it returns
<em>u</em>, and if either <em>u</em> or <em>v</em> is the wildcard, it returns the other
one.  Otherwise, it fails (returns <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span> <span class="o">=</span> <span class="n">Category</span><span class="p">([</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atomset</span><span class="p">([</span><span class="s1">&#39;du&#39;</span><span class="p">,</span> <span class="s1">&#39;pl&#39;</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span>
<span class="go">n[_0,du/pl]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n2</span> <span class="o">=</span> <span class="n">Category</span><span class="p">([</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;fem&#39;</span><span class="p">,</span> <span class="n">atomset</span><span class="p">([</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;pauc&#39;</span><span class="p">,</span> <span class="s1">&#39;pl&#39;</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n2</span>
<span class="go">n[fem,pauc/pl/sg]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meet</span><span class="p">(</span><span class="n">n1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">&#39;pl&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meet</span><span class="p">(</span><span class="n">n1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="go">du/pl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meet</span><span class="p">(</span><span class="n">n1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="unify">
<span class="sig-name descname"><span class="pre">unify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unify" title="Permalink to this definition"></a></dt>
<dd><p>Takes two categories and a set of
bindings, and returns a new set of bindings if the categories match,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if they do not match.  Specifically:</p>
<blockquote>
<div><ul class="simple">
<li><p>Make a fresh copy of the bindings, so that updates to the
bindings do not affect the original.</p></li>
<li><p>It fails if the types are different: i.e., if <em>x[0] != y[0]</em>.</p></li>
<li><p>Otherwise, it calls <code class="docutils literal notranslate"><span class="pre">meet()</span></code> on each element <em>u=x[i]</em> and <em>v=y[i]</em>, for <em>i&gt;0</em>.
If <em>u</em> is a variable, call it “the variable,” and let <em>u</em>
be its value: <em>u = b[u]</em>.</p></li>
<li><p>If <em>v</em> is a variable, signal an error</p></li>
<li><p>Let the new value be <code class="docutils literal notranslate"><span class="pre">meet``*(u,v,b)*;</span> <span class="pre">fail</span> <span class="pre">if</span> <span class="pre">``meet</span></code> fails.</p></li>
<li><p>If there is a variable, store the new value back into <em>b</em>.</p></li>
<li><p>The return value is the new set of bindings, or <code class="docutils literal notranslate"><span class="pre">None</span></code> on failure.</p></li>
</ul>
</div></blockquote>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">unify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">unify</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[&#39;fem&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="subst">
<span class="sig-name descname"><span class="pre">subst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#subst" title="Permalink to this definition"></a></dt>
<dd><p>This function is used by
<code class="docutils literal notranslate"><span class="pre">complete()</span></code> to create the category for a new node.  It
returns a copy of the category (tuple) in which each variable is
replaced with its value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">subst</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span>
<span class="go">n[_0,du/pl]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subst</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
<span class="go">n[fem,du/pl]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="declarations">
<h2>Declarations<a class="headerlink" href="#declarations" title="Permalink to this heading"></a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">Declarations</span></code> object supports the following functionality:</p>
<blockquote>
<div><ul class="simple">
<li><p>Defining names for atom sets.  Top (<code class="docutils literal notranslate"><span class="pre">'*'</span></code>), bottom (<code class="docutils literal notranslate"><span class="pre">None</span></code>),
the atoms, and all atomsets that can be formed from them, constitute
the feature lattice.  Being able to name atom sets means that we can
assign a name to any node in the lattice.  With the addition of
defined names, we can think of feature names as <strong>types</strong>, the
extension of a type being the set of atoms that it subsumes.</p></li>
<li><p>Defining the number of attributes that a category takes, along with
their types and default values.  This permits us to use keyword
feature specifications in addition to positional specifications.
It is also useful for detecting errors in grammars, when an
inappropriate value is assigned to an attribute.</p></li>
</ul>
</div></blockquote>
<p>A declaration consists of two pieces: a feature table and a category table.</p>
<dl class="py class">
<dt class="sig sig-object py" id="FeatureTable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FeatureTable</span></span><a class="headerlink" href="#FeatureTable" title="Permalink to this definition"></a></dt>
<dd><p>Contains named features, including both atoms and
features that name sets of atoms.  Each feature may be assigned a
default value.</p>
<dl class="py method">
<dt class="sig sig-object py" id="FeatureTable.define">
<span class="sig-name descname"><span class="pre">define</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">def</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dflt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FeatureTable.define" title="Permalink to this definition"></a></dt>
<dd><p>The basic FeatureTable method.  It takes the name
to define, its definition, and a default value.  The default value
must be subsumed by the definition.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">FeatureTable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FeatureTable</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s1">&#39;vform&#39;</span><span class="p">,</span> <span class="n">atomset</span><span class="p">([</span><span class="s1">&#39;sg&#39;</span><span class="p">,</span> <span class="s1">&#39;pl&#39;</span><span class="p">,</span> <span class="s1">&#39;ing&#39;</span><span class="p">]),</span> <span class="s1">&#39;sg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ftab</span><span class="p">)</span>
<span class="go">Features:</span>
<span class="go">    &lt;Feature vform ing/pl/sg sg&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="FeatureTable.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FeatureTable.__getitem__" title="Permalink to this definition"></a></dt>
<dd><p>One can access the FeatureTable as one accesses a dict.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span><span class="p">[</span><span class="s1">&#39;vform&#39;</span><span class="p">]</span>
<span class="go">&lt;Feature vform ing/pl/sg sg&gt;</span>
</pre></div>
</div>
<p>The value is an object of type <code class="docutils literal notranslate"><span class="pre">Feature</span></code>.  It has <code class="docutils literal notranslate"><span class="pre">name</span></code>,
<code class="docutils literal notranslate"><span class="pre">value</span></code>, and <code class="docutils literal notranslate"><span class="pre">dflt</span></code> attributes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vform</span> <span class="o">=</span> <span class="n">ftab</span><span class="p">[</span><span class="s1">&#39;vform&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vform</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;vform&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vform</span><span class="o">.</span><span class="n">value</span>
<span class="go">ing/pl/sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vform</span><span class="o">.</span><span class="n">dflt</span>
<span class="go">&#39;sg&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="FeatureTable.intern">
<span class="sig-name descname"><span class="pre">intern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FeatureTable.intern" title="Permalink to this definition"></a></dt>
<dd><p>Also accesses the FeatureTable, but records the name as
an atom, if it is not already present in the table.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span><span class="o">.</span><span class="n">intern</span><span class="p">(</span><span class="s1">&#39;sg&#39;</span><span class="p">)</span>
<span class="go">&#39;sg&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ftab</span><span class="p">)</span>
<span class="go">Features:</span>
<span class="go">    &lt;Feature sg sg sg&gt;</span>
<span class="go">    &lt;Feature vform ing/pl/sg sg&gt;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="CategoryTable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CategoryTable</span></span><a class="headerlink" href="#CategoryTable" title="Permalink to this definition"></a></dt>
<dd><p>Contains categories, associated with information
about the number of features they take, and type restrictions.
Default values come from the type restrictions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="CategoryTable.define">
<span class="sig-name descname"><span class="pre">define</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CategoryTable.define" title="Permalink to this definition"></a></dt>
<dd><p>The main method.  It takes the category name and a
list of <code class="docutils literal notranslate"><span class="pre">Parameter</span></code> instances.  A <code class="docutils literal notranslate"><span class="pre">Parameter</span></code> consists of a
name (string) and a type (of class <code class="docutils literal notranslate"><span class="pre">Feature</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">CategoryTable</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctab</span> <span class="o">=</span> <span class="n">CategoryTable</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctab</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s1">&#39;vp&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;form&#39;</span><span class="p">,</span> <span class="n">vform</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ctab</span><span class="p">)</span>
<span class="go">Categories:</span>
<span class="go">    &lt;Entry vp[form:vform]&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="CategoryTable.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CategoryTable.__getitem__" title="Permalink to this definition"></a></dt>
<dd><p>A category table is a specialization of dict.  The values are of type
<code class="docutils literal notranslate"><span class="pre">CategoryTable.Entry</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span> <span class="o">=</span> <span class="n">ctab</span><span class="p">[</span><span class="s1">&#39;vp&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;vp&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">params</span>
<span class="go">[form:vform]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;form&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ent</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
<span class="go">&lt;Feature vform ing/pl/sg sg&gt;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Declarations">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Declarations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ftab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Declarations" title="Permalink to this definition"></a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">Declarations</span></code> instance combines a feature table and a category
table.  If the feature table and category table are not provided,
empty ones will be created.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="Declarations.features">
<span class="sig-name descname"><span class="pre">features</span></span><a class="headerlink" href="#Declarations.features" title="Permalink to this definition"></a></dt>
<dd><p>A FeatureTable.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Declarations.categories">
<span class="sig-name descname"><span class="pre">categories</span></span><a class="headerlink" href="#Declarations.categories" title="Permalink to this definition"></a></dt>
<dd><p>A CategoryTable.</p>
</dd></dl>

<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">Declarations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decls</span> <span class="o">=</span> <span class="n">Declarations</span><span class="p">(</span><span class="n">ftab</span><span class="p">,</span> <span class="n">ctab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decls</span><span class="o">.</span><span class="n">features</span> <span class="o">==</span> <span class="n">ftab</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decls</span><span class="o">.</span><span class="n">categories</span> <span class="o">==</span> <span class="n">ctab</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">decls</span><span class="p">)</span>
<span class="go">Features:</span>
<span class="go">    &lt;Feature sg sg sg&gt;</span>
<span class="go">    &lt;Feature vform ing/pl/sg sg&gt;</span>

<span class="go">Categories:</span>
<span class="go">    &lt;Entry vp[form:vform]&gt;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="Declarations.scan_category">
<span class="sig-name descname"><span class="pre">scan_category</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Declarations.scan_category" title="Permalink to this definition"></a></dt>
<dd><p>Scans a category from a token stream.  See
<a class="reference internal" href="#scan_category" title="scan_category"><code class="xref py py-func docutils literal notranslate"><span class="pre">scan_category()</span></code></a> below.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Declarations.unscan_category">
<span class="sig-name descname"><span class="pre">unscan_category</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stream</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Declarations.unscan_category" title="Permalink to this definition"></a></dt>
<dd><p>Identical to the <code class="docutils literal notranslate"><span class="pre">unscan_category()</span></code> function.</p>
</dd></dl>

</dd></dl>

</section>
<section id="scanning">
<h2>Scanning<a class="headerlink" href="#scanning" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="scan_category">
<span class="sig-name descname"><span class="pre">scan_category</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scan_category" title="Permalink to this definition"></a></dt>
<dd><p>Scans a category from a token
stream.  It uses a syntax in which the only special characters are <code class="docutils literal notranslate"><span class="pre">[:/,]</span></code>.
It restores the original syntax after scanning.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seal.core.io</span> <span class="kn">import</span> <span class="n">iter_tokens</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span> <span class="o">=</span> <span class="n">iter_tokens</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39;np[</span><span class="si">{}</span><span class="s1">,a/b] </span><span class="si">{hi}</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">scan_category</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scan_category</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="go">np[{},a/b]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="go">&#39;{&#39;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Declarations.scan_category()</span></code>
method allows one to use defined features and keyword features.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="write_category">
<span class="sig-name descname"><span class="pre">write_category</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#write_category" title="Permalink to this definition"></a></dt>
<dd><p>Writes a category to an
outfile in a format that will be correctly scanned.
This is actually used by the <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> method of <code class="docutils literal notranslate"><span class="pre">Category</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cat</span> <span class="o">=</span> <span class="n">Category</span><span class="p">([</span><span class="s1">&#39;np&#39;</span><span class="p">,</span> <span class="s1">&#39;hi&#39;</span><span class="p">,</span> <span class="n">atomset</span><span class="p">([</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cat</span>
<span class="go">np[hi,&#39;,&#39;/&#39;/&#39;]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> method essentially does the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.features</span> <span class="kn">import</span> <span class="n">write_category</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">StringIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">write_category</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&quot;np[hi,&#39;,&#39;/&#39;/&#39;]&quot;</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="dep.html" class="btn btn-neutral float-left" title="selkie.dep — Dependency conversion" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="avs.html" class="btn btn-neutral float-right" title="selkie.avs — Recursive feature structures" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Steven Abney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>