<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>selkie.avs — Recursive feature structures &mdash; Selkie 0.22 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="selkie.grammar — Constituent grammars" href="grammar.html" />
    <link rel="prev" title="selkie.features — Non-recursive features" href="features.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Selkie
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../todo.html">To Do</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyext/index.html">Python extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/index.html">Web Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/index.html">General-purpose tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../corpus/index.html">Corpus processing</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The NLP pipeline</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="fsa.html"><code class="docutils literal notranslate"><span class="pre">selkie.fsa</span></code> — Finite-state automata</a></li>
<li class="toctree-l2"><a class="reference internal" href="fst.html"><code class="docutils literal notranslate"><span class="pre">selkie.fst</span></code> — Finite-state transducers</a></li>
<li class="toctree-l2"><a class="reference internal" href="tree.html"><code class="docutils literal notranslate"><span class="pre">selkie.tree</span></code> — Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="stemmer.html"><code class="docutils literal notranslate"><span class="pre">selkie.stemmer</span></code> — English stemmer</a></li>
<li class="toctree-l2"><a class="reference internal" href="head.html"><code class="docutils literal notranslate"><span class="pre">selkie.head</span></code> — Head marking</a></li>
<li class="toctree-l2"><a class="reference internal" href="dep.html"><code class="docutils literal notranslate"><span class="pre">selkie.dep</span></code> — Dependency conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html"><code class="docutils literal notranslate"><span class="pre">selkie.features</span></code> — Non-recursive features</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">selkie.avs</span></code> — Recursive feature structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="grammar.html"><code class="docutils literal notranslate"><span class="pre">selkie.grammar</span></code> — Constituent grammars</a></li>
<li class="toctree-l2"><a class="reference internal" href="gdev.html"><code class="docutils literal notranslate"><span class="pre">selkie.gdev</span></code> — Grammar development tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen.html"><code class="docutils literal notranslate"><span class="pre">selkie.gen</span></code> — Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="parser.html"><code class="docutils literal notranslate"><span class="pre">selkie.parser</span></code> — Constituent parser</a></li>
<li class="toctree-l2"><a class="reference internal" href="expr.html"><code class="docutils literal notranslate"><span class="pre">selkie.expr</span></code> — Predicate calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="interp.html"><code class="docutils literal notranslate"><span class="pre">selkie.interp</span></code> — Semantic interpretation</a></li>
<li class="toctree-l2"><a class="reference internal" href="logic.html"><code class="docutils literal notranslate"><span class="pre">selkie.logic</span></code> — Automated reasoning</a></li>
<li class="toctree-l2"><a class="reference internal" href="bot.html"><code class="docutils literal notranslate"><span class="pre">selkie.bot</span></code> — Conversational agent</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../speech/index.html">Speech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data/index.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../app_intro/index.html">Web Application Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../db/index.html">Persistent-object database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content/index.html">The Content Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cld/index.html">The CLD application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../uc/index.html">Universal Corpus</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Selkie</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">The NLP pipeline</a></li>
      <li class="breadcrumb-item active"><code class="docutils literal notranslate"><span class="pre">selkie.avs</span></code> — Recursive feature structures</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/nlp/avs.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="selkie-avs-recursive-feature-structures">
<h1><code class="docutils literal notranslate"><span class="pre">selkie.avs</span></code> — Recursive feature structures<a class="headerlink" href="#selkie-avs-recursive-feature-structures" title="Permalink to this heading"></a></h1>
<p>The examples assume:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">selkie.avs</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Selkie.features</span></code> is much better for use in grammars.  They are not
recursive, but they are much more efficient.  <code class="docutils literal notranslate"><span class="pre">Selkie.avs</span></code> is an
implementation of fully recursive feature structures.  It
may be used for (one version of) semantic interpretation.</p>
<p>My current implementation is probably much too complicated.  I
should do a more traditional implementation in which there are
variables only when explicitly required (for re-entrancies and for
empty values), and in which an AVS is an AV list combined with a
symbol table.</p>
<section id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="Permalink to this heading"></a></h2>
<p>We want to support both parsing and generation.  We associate an AV
<em>state</em> with each rule, which contains an AVS for the parent
node, and attribute paths indicating where to unify in each of the
children.</p>
<p>We wish to be use AVS’s to represent semantic translations, which grow
as the sentence grows.  But to be efficient, we need to be able to
assure that the space and time involved in processing any single node
does not increase as the tree gets larger.</p>
<p>The approach we have taken is to copy pieces of structure in a lazy
fashion.  One can construct pathological cases in which the amount
that must be copied grows without bound, but most natural cases should
require copying only the upper reaches of the input structures.</p>
</section>
<section id="data-structures">
<h2>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this heading"></a></h2>
<p>Here is an example of a typed attribute-value structure; let us call
it <em>A</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">[</span><span class="n">foo</span> <span class="n">hi</span><span class="p">]</span>
 <span class="n">bar</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">[</span><span class="n">foo</span> <span class="n">bye</span><span class="p">]</span>
 <span class="n">baz</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p>Our implemention is similar to the implementation of a
<code class="docutils literal notranslate"><span class="pre">Category</span></code>.  The atoms are either <em>variables</em> (the
angle-bracketed numbers in the example) or <em>constants</em> (strings).  As with
categories, we use the simple expedient of representing variables as
integers.  The variable 0 has special significance; it represents the
root of the structure.</p>
<p>We will at times be dealing with variables from multiple AVS’s.
Typically one AVS will be the <em>local</em> AVS and the other is the
<em>foreign</em> AVS.  A particular numeric value <em>v</em> represents two
different variables: one a local variable and the other a foreign variable.</p>
<p>The bracketed structures are <em>AV lists</em>.
An AV list is a list of attribute-value pairs.  An attribute is
a string.  A value is an atom:
that is, either a constant or a variable.  For the sake of efficiency, we keep
attributes alphabetically sorted.</p>
<p>An AV list also keeps a pointer to the AVS that it belongs to.  The
variables in an AV list are local to its AVS.  An AV
list belonging to a foreign AVS is to be considered immutable.</p>
<p>An AVS is just a symbol table.  Since variables are ints, we can
represent the symbol table as a list.
Each value in the symbol table may be an atom, an AV list, or
None.  In the case where the value is another variable, we say
that the original variable has been <em>redirected</em>.  In the case
where the value is None, the variable is called a
<em>dangling variable</em>.
The numeric value -1 is special, and represents a value
that is temporarily unavailable.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">parse_avs()</span></code> can be used to
create AVS <em>A</em> from a string representation, as follows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">avs1</span> <span class="o">=</span> <span class="n">parse_avs</span><span class="p">(</span><span class="s1">&#39;[foo hi; bar [foo bye]; baz = bar]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The AVS prints in its string form:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avs1</span><span class="p">)</span>
<span class="go">[bar [foo bye]</span>
<span class="go"> baz = bar</span>
<span class="go"> foo hi]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">raw()</span></code> method returns a string showing the internal structure.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avs1</span><span class="o">.</span><span class="n">raw</span><span class="p">())</span>
<span class="go">AVS 0:</span>
<span class="go">    0 -&gt; [bar:1, baz:1, foo:hi]</span>
<span class="go">    1 -&gt; [foo:bye]</span>
</pre></div>
</div>
<p>To summarize, an attribute value or <strong>atom</strong> is one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>a constant, or</p></li>
<li><p>a variable (foreign if the AV list is foreign).</p></li>
</ul>
</div></blockquote>
<p>A <strong>variable value</strong> is one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>a constant,</p></li>
<li><p>a variable (local),</p></li>
<li><p>an AV list,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Top</span></code>, or</p></li>
<li><p>-1.</p></li>
</ul>
</div></blockquote>
</section>
<section id="avs-unification">
<h2>AVS unification<a class="headerlink" href="#avs-unification" title="Permalink to this heading"></a></h2>
<p>The basic operation on AVS’s is unification, which essentially takes
the meet of two AVS’s.
Let <em>B</em> be the following AVS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">[</span><span class="n">bar</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">[</span><span class="n">cat</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">[</span><span class="n">meow</span> <span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">]]]</span>
 <span class="n">baz</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">[</span><span class="n">dog</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">]]</span>
</pre></div>
</div>
<p>AVS <em>B</em> is represented internally as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span>
 <span class="mi">1</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
 <span class="mi">2</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;meow&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span>
 <span class="mi">3</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
 <span class="mi">4</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="lazy-copying">
<h2>Lazy copying<a class="headerlink" href="#lazy-copying" title="Permalink to this heading"></a></h2>
<p>One use for AVS’s is to represent semantic
interpretations, which grow as the sentence grows.  We would also like
to use unification interleaved with parsing and
generation operations.  This is especially important for generation,
where the AVS specifies what should be generated.  Hence we would like
an implementation of unification that is nondestructive, but only
copies a limited amount of structure no matter how large the AVS’s
grow.</p>
<p>The approach we take is to allow a variable’s value to be a foreign AV
list, but to copy a variable into the working AVS whenever we need to
change its value.  We keep a temporary <em>import table</em> for the
working AVS, containing entries of form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">avs</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span> <span class="n">v</span>
</pre></div>
</div>
<p>meaning that variable <em>u</em> of AVS <em>avs</em> has been imported as
variable <em>v</em> of the working AVS.</p>
<p>Importing a variable <em>v</em> means that every reference to <em>v</em> in the
original AVS must be replaced.  That is, every AV list containing a
reference to <em>v</em> must be imported into the working AVS.  We can find
such AV lists by keeping track of the <em>parents</em> of a variable,
defining <em>u</em> to be a parent of <em>v</em> just in case <em>u</em>’s value is an AV
list containing a reference to <em>v</em>.</p>
<p>Importing an AV list may cause us to import additional variables.
Each AV list belongs to a particular AVS, and each variable in the AV
list is a local variable with respect to that AVS.  When we import the
AV list, we must replace its variables with variables that are local
to the working AVS.</p>
<p>Let us consider an example.  Suppose we wish to create an AV list
containing a reference to variable 2 of <em>B</em>.  To do so, we need to
import (B,2).  If we import (B,2), we must also import its
parents and the parents’ values.  There are two parents: (B,1) and
(B,3).  Their values contain references to (B,2) that will need to
be replaced, but no new variables.  However, we must also import the
parent of (B,1) and the parent of (B,3) - they have the same
parent, namely, (B,0).  Assume that the working
AVS already has one entry, so that we start with local variable 1.
Here are the resulting import table entries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span> <span class="mi">1</span>
<span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span> <span class="mi">2</span>
<span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="mi">3</span>
<span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Further, we add the following entries to the working AVS:</p>
<blockquote>
<div><p>1: <em>B</em> [(‘meow’, 4)]
2: [(‘cat’, 1)]
3: [(‘dog’, 1)]
4: [(‘bar’, 2), (‘baz’, 3)]</p>
</div></blockquote>
<p>Notice that the value of variable 1 is the foreign AV list, belong to
AVS <em>B</em>.  When we access the value, the result will be a <em>foreign variable</em>
represented by the pair (B,4).</p>
</section>
<section id="normalization">
<h2>Normalization<a class="headerlink" href="#normalization" title="Permalink to this heading"></a></h2>
<p><strong>Dereferencing</strong>.
Dereferencing consists
in chasing a chain of redirects until we arrive at a variable whose value is
something other than another variable.  An error is signalled if -1
is encountered.  If the value is a constant,
the result of dereferencing is the constant.  Otherwise, the result is
the variable itself.  In short, the possible return values are:</p>
<blockquote>
<div><ul class="simple">
<li><p>constant, constant</p></li>
<li><p>v, avlist</p></li>
<li><p>v,* None</p></li>
</ul>
</div></blockquote>
<p>The first value is the dereferenced atom, and the second is its
value.  A constant’s value is the constant itself.  A dereferenced
variable’s value is an AV list or None.</p>
<p>In our example, both variables have AV lists as values, so
dereferencing has no effect.</p>
</section>
<section id="the-unification-algorithm">
<h2>The unification algorithm<a class="headerlink" href="#the-unification-algorithm" title="Permalink to this heading"></a></h2>
<p>We begin by creating a new, empty AVS to hold the result of
unification.  The two input AVS’s are not to be modified.
We will consider the unification of <em>A</em> and <em>B</em>.  The initial task is
to unify (A,0) with (B,0).  We first import both foreign
variables, then we unify the resulting local variables.</p>
<p><strong>Unifying atoms</strong>.
The first step in unifying two atoms is to dereference each.
After dereferencing, each argument is each either a constant, a variable
naming an AV list, or a <em>dangling variable</em> whose value is {tt None}.</p>
<blockquote>
<div><ul class="simple">
<li><p>If both atoms are one and the same object, we are done.  Return the atom.</p></li>
<li><p>Else if either argument is a dangling variable, redirect the
dangling variable to the other atom and return the other atom.</p></li>
<li><p>Else if either value is a constant, unification fails.</p></li>
<li><p>Otherwise, we have two AV lists.
Redirect the second variable to the first, and set the value of the
first to the result of unifying the lists.  While unifying the two
substructures, the value of the first variable is set to -1,
representing “unavailable”.  If -1 is encountered when
dereferencing a variable, we have detected a cycle in the structure,
and unification fails.</p></li>
</ul>
</div></blockquote>
<p><strong>Unifing AV lists</strong>.
The first step in unifying two AV lists is to make sure that both are
local.  If either belongs to a foreign AVS, import it into the local AVS.
Then one iterates through the two (local) AV lists together,
constructing a new output list.  Recall
that the attributes are alphabetically sorted.  If the alphabetically
next key appears in only one of the lists, copy it and its value
unmodified into the output list.  If it appears in both lists, unify
the values, and copy the attribute along with the result of unification into
the output list.  The values in an AV list are atoms (either variables
or constants), and we have already discussed the unification of atoms.</p>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this heading"></a></h2>
<p>Let us consider the algorithm applied to our example.  The first step
is merging, resulting in the structure ??.</p>
<p><strong>Unify 0 and 2</strong>.
We now unify the variables 0 and 2.  Both have AV lists as values, so dereferencing
has no effect.  Redirect 2 to 0, and set the value of 0 temporarily to
-1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Now we unify the original values of 0 and 2, namely,
[‘bar’, 1, ‘baz’, 1, ‘foo’, ‘hi’] and [‘bar’, 3, ‘baz’, 5].
Only the first list has a
value for <code class="docutils literal notranslate"><span class="pre">foo</span></code>, so that goes unmodified into the result.  The
values for <code class="docutils literal notranslate"><span class="pre">bar</span></code> are 1 and 3, and the values for <code class="docutils literal notranslate"><span class="pre">baz</span></code> are 1
and 5.  Hence we have two recursive unifications to perform.</p>
<p><strong>Unify 1 and 3</strong>.
The values for 1 and 3 are [‘foo’, ‘bye’] and
[‘cat’, 4].  There are no common attributes, so the output is
simply the concatenation of the two lists.  Variable 3 is redirected
to 1, and the output is stored in 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span>\<span class="n">tt</span> <span class="p">[</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bye&#39;</span><span class="p">]}</span>
<span class="mi">3</span><span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
<p><strong>Unify 1 and 5</strong>.
Now we unify 1 and 5.  Variable 5 is redirected to 1 and 1 is
temporarily set to -1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span>
<span class="mi">5</span><span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The values to be unified are [‘cat’, 4, ‘foo’, ‘bye’]
and [‘dog’, 4].  There are no shared attributes, so the
unification is again simply the concatenation of the lists.  It is
stored in 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bye&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Finish unifying 0 and 2</strong>.
We have now completed the two recursive calls.  The value for
<code class="docutils literal notranslate"><span class="pre">bar</span></code> is set to 1, and the value for <code class="docutils literal notranslate"><span class="pre">baz</span></code> is also set to 1.
The output list is stored in 0.  The final outcome is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;hi&#39;</span><span class="p">]</span>
<span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bye&#39;</span><span class="p">]</span>
<span class="mi">2</span><span class="p">:</span> <span class="mi">0</span>
<span class="mi">3</span><span class="p">:</span> <span class="mi">1</span>
<span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;meow&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="mi">5</span><span class="p">:</span> <span class="mi">1</span>
<span class="mi">6</span><span class="p">:</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="packing">
<h2>Packing<a class="headerlink" href="#packing" title="Permalink to this heading"></a></h2>
<p>To make future unifications a little more efficient, we may
<em>pack</em> the result.  We first propagate “reachability” from
variables to the variables mentioned in their values, starting from
variable 0.  The result is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
</pre></div>
</div>
<p>That is, variables 0, 1, 4, and 6 are reachable.  Then
we define replacement variables by numbering the reachable variables.
The result is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally, we create a reduced symbol table, in which all variables have
been replaced with their new numbers.</p>
<blockquote>
<div><p>0: [‘bar’, 1, ‘baz’, 1, ‘foo’, ‘hi’]
1: [‘cat’, 2, ‘dog’, 2, ‘foo’, ‘bye’]
2: [‘meow’, 3]
3: None</p>
</div></blockquote>
<p>This last step can be destructive, as long as we are sure to copy all
AV lists from <em>both</em> of the original input structures when we do
the initial merge.</p>
</section>
<section id="in-python">
<h2>In Python<a class="headerlink" href="#in-python" title="Permalink to this heading"></a></h2>
<p>Create the second AVS:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">avs2</span> <span class="o">=</span> <span class="n">parse_avs</span><span class="p">(</span><span class="s1">&#39;[bar [cat [meow []]]; baz [dog = bar.cat]]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avs2</span><span class="p">)</span>
<span class="go">[bar [cat [meow []]]</span>
<span class="go"> baz [dog = bar.cat]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avs2</span><span class="o">.</span><span class="n">raw</span><span class="p">())</span>
<span class="go">AVS 1:</span>
<span class="go">    0 -&gt; [bar:1, baz:4]</span>
<span class="go">    1 -&gt; [cat:2]</span>
<span class="go">    2 -&gt; [meow:3]</span>
<span class="go">    3 -&gt; Top</span>
<span class="go">    4 -&gt; [dog:2]</span>
</pre></div>
</div>
<p>Unify:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">avs3</span> <span class="o">=</span> <span class="n">unify</span><span class="p">(</span><span class="n">avs1</span><span class="p">,</span> <span class="n">avs2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avs3</span><span class="p">)</span>
<span class="go">[bar [cat [meow []]</span>
<span class="go">      dog = bar.cat</span>
<span class="go">      foo bye]</span>
<span class="go"> baz = bar</span>
<span class="go"> foo hi]</span>
</pre></div>
</div>
</section>
<section id="av-state">
<h2>AV state<a class="headerlink" href="#av-state" title="Permalink to this heading"></a></h2>
<p>An AV state represents an intermediate state during the construction
of the AVS for a node with children.  The second argument to
<code class="docutils literal notranslate"><span class="pre">parse_avstate()</span></code> is the number of children:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;[subj $1 [foo hi; bar [foo bye]; baz = subj.bar]]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">parse_avstate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">(AvState . * subj - : [subj [bar [foo bye]; baz = subj.bar; foo hi]])</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">extend()</span></code> is given the AVS for the next child in
line.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">avs2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span>
<span class="go">(AvState . subj * - : [subj [bar [cat [meow []]; dog = subj.bar.cat;</span>
<span class="go">foo bye]; baz = subj.bar; foo hi]])</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="selkie.features — Non-recursive features" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="grammar.html" class="btn btn-neutral float-right" title="selkie.grammar — Constituent grammars" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Steven Abney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>