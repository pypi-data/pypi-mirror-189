#!/usr/bin/env python

from pprint import pformat as pf
from importlib import reload

import matplotlib.pyplot as plt
from astropy.io import fits
from astropy.wcs import WCS              # !!!
from astropy.nddata import Cutout2D      # !!!
from astropy.coordinates import SkyCoord
from astropy import units as u
import numpy as np
import pandas as pd

import astroget.client
reload(astroget.client)
astroget.__version__

# Server must support client.cutout() method !!!
#server='https://astroarchive.noirlab.edu'
server='https://marsnat1-pat.csdc.noirlab.edu' #!!!
client = astroget.client.CsdcClient(url=server)
print(f'Client: {client}')

fname='/net/archive/pipe/20170803/ct4m/2017B-0951/c4d_170804_050615_oow_r_v1.fits.fz'
obj_name = 'M2'
obj_coord = SkyCoord.from_name(obj_name)
ra = obj_coord.ra.degree
dec = obj_coord.dec.degree
print(f'Target ra,dec={(ra,dec)}')

search_size = 0.01 # radius in degrees
found = client.find(
      outfields=['md5sum', 'hdu:hdu_idx',
                 'hdu:ra_center', 'hdu:dec_center',
                 'archive_filename', 'hdu:updated'],
      constraints={
          'archive_filename': [fname],
          'instrument': ['decam'],
          'obs_type': ['object'],
          'proc_type': ['instcal'],
          'hdu:ra_center': [ra - search_size, ra + search_size],
          'hdu:dec_center': [dec - search_size, dec + search_size],
      },
    limit=50)

print(f'Found {found.count} matches of object {obj_name} '
      f'at position: ra,dec={(ra,dec)} using client.vohdu()')
recidx = 0
rec = found.records[recidx]
print(f'Show 1 of {found.count} records. rec[{recidx}] = ')
print(f'{pf(rec)}')

md5 = rec['md5sum']
hduidx = rec['hdu:hdu_idx']
#!hduurl = rec['url']
hduurl = f'{server}/api/retrieve/{md5}/?hdus=0,{hduidx}'
print(f'hduurl = {hduurl}')
client.hdu_bounds(md5, hduidx, vet=1, verbose=True)


##############################################################################

header0 = fits.getheader(hduurl, 0) # hdu0=Primary, hdu1=image
image_data1, header1 = fits.getdata(hduurl, 1, header=True) # hdu0=Primary, hdu1=image
print(f'HDU size in pixels = {image_data1.shape}')



cornerkeys = ['CENRA1',   'CENDEC1',
              'COR1RA1', 'COR1DEC1',
              'COR2RA1', 'COR2DEC1',
              'COR3RA1', 'COR3DEC1',
              'COR4RA1', 'COR4DEC1']
hducornerkeys = [f'hdu:{k}' for k in cornerkeys] # rename for use in find()

dbboundskeys = ['ra_min', 'ra_max',
                'dec_min', 'dec_max', 'ra_center', 'dec_center']
hdudbboundskeys = [f'hdu:{k}' for k in dbboundskeys] # rename for use in find()
rec


# In[10]:


hducornerkeys = ['CENRA1',   'CENDEC1',
                 'COR1RA1', 'COR1DEC1',
                 'COR2RA1', 'COR2DEC1',
                 'COR3RA1', 'COR3DEC1',
                 'COR4RA1', 'COR4DEC1']
h0 = {k: header0.get(k,None) for k in ['INSTRUME', 'OBSTYPE', 'PROCTYPE','PRODTYPE']}
h1 = {k: header1.get(k,None) for k in hducornerkeys}
print(f'header0={h0}')
print(f'header1={h1}')


# In[ ]:





# ## Cutout chip from HDU

# In[11]:


ra,dec,md5,hduidx


# In[12]:


# DEBUG.  Why do we get error: "NoOverlapError: Arrays do not overlap"
print(f'ra,dec={(ra,dec)} chip_size={chip_size}')  # cutout parameters
client.hdu_bounds(md5, hduidx, verbose=False)


# In[ ]:


chip_size = 100
print(f'Get chip centered at ra,dec={(ra,dec)} size {chip_size}. From image md5,hduidx=({md5}, {hduidx})')
# get in memory FITS file
chip = client.cutout(ra, dec, chip_size, md5, hduidx, verbose=True)
print(f'Cutout chip into local FITS file: {chip}')

plt.figure()
plt.imshow(image_data, origin='lower', cmap='gray')
plt.colorbar()


# ## Display HDU image

# In[ ]:


########################


# In[ ]:


# Look at HDU values stored in DB
recidx = 5
rec = found.records[recidx]
[f'{k} = {rec[k]}' for k in sorted(rec.keys())]


# In[ ]:


#client.fits_headers(md5)[hduidx]

objs = dict()
for n in range(1,110+1):
    name = f'M{n}'
    obj_coord = SkyCoord.from_name(name)
    ra = obj_coord.ra.degree
    dec = obj_coord.dec.degree

    # Search HDUs (not files).  There are a lot more of these than there are of files.
    # The Astro Data Archive has over 390 million HDUs that can be searched.
    # (contained in over 18 million files)
    try:
        found = client.vohdu(
            (ra,dec), 0.000001,  # position=(ra,dec), size(in decimal degrees)
            instrument='decam',
            obs_type='object',
            proc_type='instcal',
            limit=None, VERB=3, verbose=False)
    except:
        continue
    #! print(f'name={name}  found.count={found.count}')
    objs[name] = found.count
found_objects = {k:v for (k,v) in objs.items() if v > 0}
print(found_objects)
# In[ ]:


obj_name = 'M2'
instrument = 'decam'
obs_type = 'object'
proc_type = 'instcal'
limit = 25

obj_coord = SkyCoord.from_name(obj_name)
ra = obj_coord.ra.degree
dec = obj_coord.dec.degree
print(f'obj_name={obj_name} at position: ra,dec={(ra,dec)}')

cornerkeys = ['CENRA1',   'CENDEC1',
              'COR1RA1', 'COR1DEC1',
              'COR2RA1', 'COR2DEC1',
              'COR3RA1', 'COR3DEC1',
              'COR4RA1', 'COR4DEC1']
hducornerkeys = [f'hdu:{k}' for k in cornerkeys] # rename for use in find()

dbboundskeys = ['ra_min', 'ra_max',
                'dec_min', 'dec_max', 'ra_center', 'dec_center']
hdudbboundskeys = [f'hdu:{k}' for k in dbboundskeys] # rename for use in find()


search_size = 0.01  # diameter in degrees
out = ['md5sum', 'hdu:hdu_idx']  + hducornerkeys + hdudbboundskeys
cons = {'instrument': [instrument],
        'obs_type': [obs_type],
        'proc_type': [proc_type],
        'hdu:ra_center': [ra - search_size/2, ra + search_size/2],
        'hdu:dec_center': [dec - search_size/2, dec + search_size/2],
        }
found = client.find(outfields=out, constraints=cons, limit=limit)
print(f'Found {found.count} matches of object {obj_name} using client.find()')
found


# In[ ]:


found.records[0]


# ### Discover HDUs containing astro Object near HDU center by using `client.find()`

# In[ ]:


name = 'M2'
obj_coord = SkyCoord.from_name(name)
ra = obj_coord.ra.degree
dec = obj_coord.dec.degree
target = SkyCoord(ra=ra*u.deg, dec=dec*u.deg)
search_size = 0.01 # degrees, radius
print(f'Object "{name}" position={(ra,dec)}')

found = client.find(
      outfields=['md5sum', 'hdu:hdu_idx', 'hdu:ra_center', 'hdu:dec_center'],
      constraints={
          'instrument': ['decam'], 'obs_type': ['object'], 'proc_type': ['instcal'],
           'hdu:ra_center': [ra - search_size, ra + search_size],
           'hdu:dec_center': [dec - search_size, dec + search_size],
      },
    limit=50)
print(f'Found {found.count} matching HDUs')
recidx = 0
rec = found.records[recidx]
print(f'Show 1 of {found.count} records. rec[{recidx}] = \n{pf(rec)}')


# <a class="anchor" id="retrieve"></a>
# ## Get image (HDU) that contains the object
# Print extents of various regions related to cutouts.

# In[ ]:


chip_size = 300 # of square cutout chip, pixels on a side
# Store metadata needed to get a cuttout of the object from one HDU
md5 = rec['md5sum']
hduidx = rec['hdu:hdu_idx']
hduurl = f'{server}/api/retrieve/{md5}/?hdus=0,{hduidx}'
print(f'md5,hduidx,ra,dec,name = {(md5,hduidx,ra,dec,name)}')


# In[ ]:


reingested='https://marsnat1-pat.csdc.noirlab.edu/api/retrieve/013e55fa35798e0d46f02eeebb64b730/?hdus=0,34'
hduurl=reingested


# In[ ]:


# Image might be prioprietary. If so, this will error.
# But its possible to provide credentials...
# Need more helpful error messages for exceptions: timeout, proprietary !!!
with fits.open(hduurl) as hdul:
    image_data = hdul[1].data   # File at URL has hdul[0]=Primary, hdul[1]=image
    header = hdul[1].header
print(f'HDU size in pixels = {image_data.shape}')

get_ipython().run_line_magic('matplotlib', 'widget')
plt.imshow(image_data, origin='lower', cmap='gray')

wcs = WCS(header)
print()
print(wcs)
print(f'WCS(header).has_distortion = {WCS(header).has_distortion}')
print(f'wcs footprint = \n{wcs.calc_footprint(header=header)}')

# Extremes in ra,dec of WCS given in HDU header
llpos = wcs.pixel_to_world(0,0)
urpos = wcs.pixel_to_world(*wcs.pixel_shape)
print()
print(f'HDU wcs RA  extent: {llpos.ra.degree} to {urpos.ra.degree}')
print(f'HDU wcs DEC extent: {llpos.dec.degree} to {urpos.dec.degree}')
ppd = wcs.pixel_shape[1] / abs(llpos.dec.degree - urpos.dec.degree)
print(f'Pixels per degree = {ppd}')
print(f'Cutout size ({size}) in degrees = {ppd/size}')

dispkeys = 'CENRA1,CENDEC1,COR1RA1,COR1DEC1,COR2RA1,COR2DEC1,COR3RA1,COR3DEC1,COR4RA1,COR4DEC1'.split(',')
pipevalues = {k: v for (k,v) in header.items() if k in dispkeys}
print()
print(f'Corner coordinates from Pipeline = \n{pf(pipevalues)}')
cenpx,cenpy = wcs.world_to_pixel(SkyCoord(ra=header['CENRA1']*u.deg, dec=header['CENDEC1']*u.deg))
cenx=float(cenpx); ceny=float(cenpy)
print(f'Center x,y (from Pipeline) = {(cenx,ceny)}')
ral = [header['COR1RA1'], header['COR2RA1'], header['COR3RA1'], header['COR4RA1']]
decl = [header['COR1DEC1'], header['COR2DEC1'], header['COR3DEC1'], header['COR4DEC1']]
pbbox = (min(ral), max(ral), min(decl), max(decl))
print(f'bbox (from Pipeline) RA = {pbbox}')

# HDU bounding box extent per Database (comes from pipeline corners)
#!print()
#! print(f'HDU bbox(DB) RA  extent: {hdu_bbox[0]}')
#! print(f'HDU bbox(DB) DEC extent: {hdu_bbox[1]}')

# Bounds of cutout in ra,dec !!!
cpx,cpy = wcs.world_to_pixel( obj_coord )
cx = float(cpx)
cy = float(cpy)
window = wcs.pixel_to_world([cx-size, cx+size], [cy-size, cy+size])
print()
print(f'Cutout Window RA  extent: {window.ra.degree[0]} to {window.ra.degree[1]}')
print(f'Cutout Window DEC extent: {window.dec.degree[0]} to {window.dec.degree[1]}')



#chip = client.cutout(ra, dec, size, md5, hduidx)
chip = client.cutout(ra, dec, 5000, md5, hduidx)
print(f'chip={chip}')
