{"version":3,"file":"962b4ede.js","mappings":";;AAyCA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AASA;ACjCA;;AAEA;AACA;AACA;;;AAIA;;;;;;;ACfA;;;;ACOA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;;;;AAoDA;AC7CA;;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAKA;;;;;;;;;;;;;AAiBA;ACpDA;;;;AAIA;;AAEA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAwBA;;AChCA;;AAEA;;AAGA;AACA;AACA;;;;;;AAOA;AACA;AACA;AACA;AAEA;;;AAGA;;AAOA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;;;;;;;;;;AA8FA;AC1HA;AAGA;;AAEA;AACA;AACA;AACA;;;;AAQA;;AAEA;;;AAGA;AACA;;;;;;AAMA;AACA;AAGA;;;;;AAKA;;AAEA;;AAKA;AACA;AACA;AACA;AACA;;AAEA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkHA;;AC/MA;AACA;AACA;AACA;;AAGA;;ACSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;ACFA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;AA+DA;;AChFA;;AAGA;;AAEA;AAEA;AAIA;;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAgBA;;;;;;;;;;AA8DA","sources":["webpack://home-assistant-frontend/./src/components/ha-duration-input.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-boolean.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-constant.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-float.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-grid.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-expandable.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-integer.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-multi_select.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-positive_time_period_dict.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-select.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form-string.ts","webpack://home-assistant-frontend/./src/components/ha-form/ha-form.ts"],"sourcesContent":["import { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport \"./ha-base-time-input\";\nimport type { TimeChangedEvent } from \"./ha-base-time-input\";\n\nexport interface HaDurationData {\n  days?: number;\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  milliseconds?: number;\n}\n\n@customElement(\"ha-duration-input\")\nclass HaDurationInput extends LitElement {\n  @property({ attribute: false }) public data?: HaDurationData;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean }) public enableMillisecond = false;\n\n  @property({ type: Boolean }) public enableDay = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"paper-time-input\", true) private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-base-time-input\n        .label=${this.label}\n        .helper=${this.helper}\n        .required=${this.required}\n        .autoValidate=${this.required}\n        .disabled=${this.disabled}\n        errorMessage=\"Required\"\n        enableSecond\n        .enableMillisecond=${this.enableMillisecond}\n        .enableDay=${this.enableDay}\n        format=\"24\"\n        .days=${this._days}\n        .hours=${this._hours}\n        .minutes=${this._minutes}\n        .seconds=${this._seconds}\n        .milliseconds=${this._milliseconds}\n        @value-changed=${this._durationChanged}\n        noHoursLimit\n        dayLabel=\"dd\"\n        hourLabel=\"hh\"\n        minLabel=\"mm\"\n        secLabel=\"ss\"\n        millisecLabel=\"ms\"\n      ></ha-base-time-input>\n    `;\n  }\n\n  private get _days() {\n    return this.data?.days ? Number(this.data.days) : 0;\n  }\n\n  private get _hours() {\n    return this.data?.hours ? Number(this.data.hours) : 0;\n  }\n\n  private get _minutes() {\n    return this.data?.minutes ? Number(this.data.minutes) : 0;\n  }\n\n  private get _seconds() {\n    return this.data?.seconds ? Number(this.data.seconds) : 0;\n  }\n\n  private get _milliseconds() {\n    return this.data?.milliseconds ? Number(this.data.milliseconds) : 0;\n  }\n\n  private _durationChanged(ev: CustomEvent<{ value: TimeChangedEvent }>) {\n    ev.stopPropagation();\n    const value = { ...ev.detail.value };\n\n    if (!this.enableMillisecond && !value.milliseconds) {\n      // @ts-ignore\n      delete value.milliseconds;\n    } else if (value.milliseconds > 999) {\n      value.seconds += Math.floor(value.milliseconds / 1000);\n      value.milliseconds %= 1000;\n    }\n\n    if (value.seconds > 59) {\n      value.minutes += Math.floor(value.seconds / 60);\n      value.seconds %= 60;\n    }\n\n    if (value.minutes > 59) {\n      value.hours += Math.floor(value.minutes / 60);\n      value.minutes %= 60;\n    }\n\n    if (this.enableDay && value.hours > 24) {\n      value.days = (value.days ?? 0) + Math.floor(value.hours / 24);\n      value.hours %= 24;\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-duration-input\": HaDurationInput;\n  }\n}\n","import \"@material/mwc-formfield\";\nimport { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type {\n  HaFormBooleanData,\n  HaFormBooleanSchema,\n  HaFormElement,\n} from \"./types\";\nimport type { HaCheckbox } from \"../ha-checkbox\";\nimport \"../ha-checkbox\";\n\n@customElement(\"ha-form-boolean\")\nexport class HaFormBoolean extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormBooleanSchema;\n\n  @property() public data!: HaFormBooleanData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"ha-checkbox\", true) private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <mwc-formfield .label=${this.label}>\n        <ha-checkbox\n          .checked=${this.data}\n          .disabled=${this.disabled}\n          @change=${this._valueChanged}\n        ></ha-checkbox>\n      </mwc-formfield>\n    `;\n  }\n\n  private _valueChanged(ev: Event) {\n    fireEvent(this, \"value-changed\", {\n      value: (ev.target as HaCheckbox).checked,\n    });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-boolean\": HaFormBoolean;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { HaFormConstantSchema, HaFormElement } from \"./types\";\n\n@customElement(\"ha-form-constant\")\nexport class HaFormConstant extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public schema!: HaFormConstantSchema;\n\n  @property() public label!: string;\n\n  protected render(): TemplateResult {\n    return html`<span class=\"label\">${this.label}</span>${this.schema.value\n        ? `: ${this.schema.value}`\n        : \"\"}`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n      .label {\n        font-weight: 500;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-constant\": HaFormConstant;\n  }\n}\n","import { css, html, LitElement, TemplateResult, PropertyValues } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { HaTextField } from \"../ha-textfield\";\nimport \"../ha-textfield\";\nimport { HaFormElement, HaFormFloatData, HaFormFloatSchema } from \"./types\";\n\n@customElement(\"ha-form-float\")\nexport class HaFormFloat extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public schema!: HaFormFloatSchema;\n\n  @property({ attribute: false }) public data!: HaFormFloatData;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"ha-textfield\") private _input?: HaTextField;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-textfield\n        type=\"numeric\"\n        inputMode=\"decimal\"\n        .label=${this.label}\n        .helper=${this.helper}\n        helperPersistent\n        .value=${this.data !== undefined ? this.data : \"\"}\n        .disabled=${this.disabled}\n        .required=${this.schema.required}\n        .autoValidate=${this.schema.required}\n        .suffix=${this.schema.description?.suffix}\n        .validationMessage=${this.schema.required ? \"Required\" : undefined}\n        @input=${this._valueChanged}\n      ></ha-textfield>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\"own-margin\", !!this.schema.required);\n    }\n  }\n\n  private _valueChanged(ev: Event) {\n    const source = ev.target as HaTextField;\n    const rawValue = source.value.replace(\",\", \".\");\n\n    let value: number | undefined;\n\n    if (rawValue.endsWith(\".\")) {\n      return;\n    }\n\n    // Allow user to start typing a negative value\n    if (rawValue === \"-\") {\n      return;\n    }\n\n    if (rawValue !== \"\") {\n      value = parseFloat(rawValue);\n      if (isNaN(value)) {\n        value = undefined;\n      }\n    }\n\n    // Detect anything changed\n    if (this.data === value) {\n      // parseFloat will drop invalid text at the end, in that case update textfield\n      const newRawValue = value === undefined ? \"\" : String(value);\n      if (source.value !== newRawValue) {\n        source.value = newRawValue;\n      }\n      return;\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  static styles = css`\n    :host([own-margin]) {\n      margin-bottom: 5px;\n    }\n    ha-textfield {\n      display: block;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-float\": HaFormFloat;\n  }\n}\n","import \"./ha-form\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport type {\n  HaFormGridSchema,\n  HaFormDataContainer,\n  HaFormElement,\n  HaFormSchema,\n} from \"./types\";\nimport type { HomeAssistant } from \"../../types\";\n\n@customElement(\"ha-form-grid\")\nexport class HaFormGrid extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data!: HaFormDataContainer;\n\n  @property({ attribute: false }) public schema!: HaFormGridSchema;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property() public computeLabel?: (\n    schema: HaFormSchema,\n    data?: HaFormDataContainer\n  ) => string;\n\n  @property() public computeHelper?: (schema: HaFormSchema) => string;\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n    if (changedProps.has(\"schema\")) {\n      if (this.schema.column_min_width) {\n        this.style.setProperty(\n          \"--form-grid-min-width\",\n          this.schema.column_min_width\n        );\n      } else {\n        this.style.setProperty(\"--form-grid-min-width\", \"\");\n      }\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.schema.schema.map(\n        (item) =>\n          html`\n            <ha-form\n              .hass=${this.hass}\n              .data=${this.data}\n              .schema=${[item]}\n              .disabled=${this.disabled}\n              .computeLabel=${this.computeLabel}\n              .computeHelper=${this.computeHelper}\n            ></ha-form>\n          `\n      )}\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: grid !important;\n        grid-template-columns: repeat(\n          var(--form-grid-column-count, auto-fit),\n          minmax(var(--form-grid-min-width, 200px), 1fr)\n        );\n        grid-column-gap: 8px;\n        grid-row-gap: 24px;\n      }\n      :host > ha-form {\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-grid\": HaFormGrid;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./ha-form\";\nimport type {\n  HaFormDataContainer,\n  HaFormElement,\n  HaFormExpandableSchema,\n  HaFormSchema,\n} from \"./types\";\n\n@customElement(\"ha-form-expandable\")\nexport class HaFormExpendable extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data!: HaFormDataContainer;\n\n  @property({ attribute: false }) public schema!: HaFormExpandableSchema;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property() public computeLabel?: (\n    schema: HaFormSchema,\n    data?: HaFormDataContainer\n  ) => string;\n\n  @property() public computeHelper?: (schema: HaFormSchema) => string;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-expansion-panel outlined .expanded=${Boolean(this.schema.expanded)}>\n        <div\n          slot=\"header\"\n          role=\"heading\"\n          aria-level=${this.schema.headingLevel?.toString() ?? \"3\"}\n        >\n          ${this.schema.icon\n            ? html` <ha-icon .icon=${this.schema.icon}></ha-icon> `\n            : this.schema.iconPath\n            ? html` <ha-svg-icon .path=${this.schema.iconPath}></ha-svg-icon> `\n            : null}\n          ${this.schema.title}\n        </div>\n        <div class=\"content\">\n          <ha-form\n            .hass=${this.hass}\n            .data=${this.data}\n            .schema=${this.schema.schema}\n            .disabled=${this.disabled}\n            .computeLabel=${this.computeLabel}\n            .computeHelper=${this.computeHelper}\n          ></ha-form>\n        </div>\n      </ha-expansion-panel>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: flex !important;\n        flex-direction: column;\n      }\n      :host ha-form {\n        display: block;\n      }\n      .content {\n        padding: 12px;\n      }\n      ha-expansion-panel {\n        display: block;\n        --expansion-panel-content-padding: 0;\n        border-radius: 6px;\n      }\n      ha-svg-icon,\n      ha-icon {\n        color: var(--secondary-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-expandable\": HaFormExpendable;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { HaCheckbox } from \"../ha-checkbox\";\nimport \"../ha-slider\";\nimport { HaTextField } from \"../ha-textfield\";\nimport { HaFormElement, HaFormIntegerData, HaFormIntegerSchema } from \"./types\";\n\n@customElement(\"ha-form-integer\")\nexport class HaFormInteger extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public schema!: HaFormIntegerSchema;\n\n  @property({ attribute: false }) public data?: HaFormIntegerData;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"ha-textfield ha-slider\") private _input?:\n    | HaTextField\n    | HTMLInputElement;\n\n  private _lastValue?: HaFormIntegerData;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (\n      this.schema.valueMin !== undefined &&\n      this.schema.valueMax !== undefined &&\n      this.schema.valueMax - this.schema.valueMin < 256\n    ) {\n      return html`\n        <div>\n          ${this.label}\n          <div class=\"flex\">\n            ${!this.schema.required\n              ? html`\n                  <ha-checkbox\n                    @change=${this._handleCheckboxChange}\n                    .checked=${this.data !== undefined}\n                    .disabled=${this.disabled}\n                  ></ha-checkbox>\n                `\n              : \"\"}\n            <ha-slider\n              pin\n              ignore-bar-touch\n              .value=${this._value}\n              .min=${this.schema.valueMin}\n              .max=${this.schema.valueMax}\n              .disabled=${this.disabled ||\n              (this.data === undefined && !this.schema.required)}\n              @change=${this._valueChanged}\n            ></ha-slider>\n          </div>\n          ${this.helper\n            ? html`<ha-input-helper-text>${this.helper}</ha-input-helper-text>`\n            : \"\"}\n        </div>\n      `;\n    }\n\n    return html`\n      <ha-textfield\n        type=\"number\"\n        inputMode=\"numeric\"\n        .label=${this.label}\n        .helper=${this.helper}\n        helperPersistent\n        .value=${this.data !== undefined ? this.data : \"\"}\n        .disabled=${this.disabled}\n        .required=${this.schema.required}\n        .autoValidate=${this.schema.required}\n        .suffix=${this.schema.description?.suffix}\n        .validationMessage=${this.schema.required ? \"Required\" : undefined}\n        @input=${this._valueChanged}\n      ></ha-textfield>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\n        \"own-margin\",\n        !(\"valueMin\" in this.schema && \"valueMax\" in this.schema) &&\n          !!this.schema.required\n      );\n    }\n  }\n\n  private get _value() {\n    if (this.data !== undefined) {\n      return this.data;\n    }\n\n    if (!this.schema.required) {\n      return this.schema.valueMin || 0;\n    }\n\n    return (\n      (this.schema.description?.suggested_value !== undefined &&\n        this.schema.description?.suggested_value !== null) ||\n      this.schema.default ||\n      this.schema.valueMin ||\n      0\n    );\n  }\n\n  private _handleCheckboxChange(ev: Event) {\n    const checked = (ev.target as HaCheckbox).checked;\n    let value: HaFormIntegerData | undefined;\n    if (checked) {\n      for (const candidate of [\n        this._lastValue,\n        this.schema.description?.suggested_value as HaFormIntegerData,\n        this.schema.default,\n        0,\n      ]) {\n        if (candidate !== undefined) {\n          value = candidate;\n          break;\n        }\n      }\n    } else {\n      // We track last value so user can disable and enable a field without losing\n      // their value.\n      this._lastValue = this.data;\n    }\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  private _valueChanged(ev: Event) {\n    const source = ev.target as HaTextField | HTMLInputElement;\n    const rawValue = source.value;\n\n    let value: number | undefined;\n\n    if (rawValue !== \"\") {\n      value = parseInt(String(rawValue));\n    }\n\n    if (this.data === value) {\n      // parseInt will drop invalid text at the end, in that case update textfield\n      const newRawValue = value === undefined ? \"\" : String(value);\n      if (source.value !== newRawValue) {\n        source.value = newRawValue;\n      }\n      return;\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host([own-margin]) {\n        margin-bottom: 5px;\n      }\n      .flex {\n        display: flex;\n      }\n      ha-slider {\n        flex: 1;\n      }\n      ha-textfield {\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-integer\": HaFormInteger;\n  }\n}\n","import { mdiMenuDown, mdiMenuUp } from \"@mdi/js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport \"../ha-button-menu\";\nimport \"../ha-check-list-item\";\nimport type { HaCheckListItem } from \"../ha-check-list-item\";\nimport \"../ha-checkbox\";\nimport type { HaCheckbox } from \"../ha-checkbox\";\nimport \"../ha-formfield\";\nimport \"../ha-svg-icon\";\nimport \"../ha-textfield\";\nimport {\n  HaFormElement,\n  HaFormMultiSelectData,\n  HaFormMultiSelectSchema,\n} from \"./types\";\n\nfunction optionValue(item: string | string[]): string {\n  return Array.isArray(item) ? item[0] : item;\n}\n\nfunction optionLabel(item: string | string[]): string {\n  return Array.isArray(item) ? item[1] || item[0] : item;\n}\n\nconst SHOW_ALL_ENTRIES_LIMIT = 6;\n\n@customElement(\"ha-form-multi_select\")\nexport class HaFormMultiSelect extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormMultiSelectSchema;\n\n  @property() public data!: HaFormMultiSelectData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @state() private _opened = false;\n\n  @query(\"ha-button-menu\") private _input?: HTMLElement;\n\n  public focus(): void {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    const options = Array.isArray(this.schema.options)\n      ? this.schema.options\n      : Object.entries(this.schema.options);\n    const data = this.data || [];\n\n    // We will just render all checkboxes.\n    if (options.length < SHOW_ALL_ENTRIES_LIMIT) {\n      return html`<div>\n        ${this.label}${options.map((item: string | [string, string]) => {\n          const value = optionValue(item);\n          return html`\n            <ha-formfield .label=${optionLabel(item)}>\n              <ha-checkbox\n                .checked=${data.includes(value)}\n                .value=${value}\n                .disabled=${this.disabled}\n                @change=${this._valueChanged}\n              ></ha-checkbox>\n            </ha-formfield>\n          `;\n        })}\n      </div> `;\n    }\n\n    return html`\n      <ha-button-menu\n        .disabled=${this.disabled}\n        fixed\n        corner=\"BOTTOM_START\"\n        @opened=${this._handleOpen}\n        @closed=${this._handleClose}\n        multi\n        activatable\n      >\n        <ha-textfield\n          slot=\"trigger\"\n          .label=${this.label}\n          .value=${data\n            .map((value) => this.schema.options![value] || value)\n            .join(\", \")}\n          .disabled=${this.disabled}\n          tabindex=\"-1\"\n        ></ha-textfield>\n        <ha-svg-icon\n          slot=\"trigger\"\n          .path=${this._opened ? mdiMenuUp : mdiMenuDown}\n        ></ha-svg-icon>\n        ${options.map((item: string | [string, string]) => {\n          const value = optionValue(item);\n          const selected = data.includes(value);\n          return html`<ha-check-list-item\n            left\n            .selected=${selected}\n            .activated=${selected}\n            @request-selected=${this._selectedChanged}\n            .value=${value}\n            .disabled=${this.disabled}\n          >\n            ${optionLabel(item)}\n          </ha-check-list-item>`;\n        })}\n      </ha-button-menu>\n    `;\n  }\n\n  protected firstUpdated() {\n    this.updateComplete.then(() => {\n      const { formElement, mdcRoot } =\n        this.shadowRoot?.querySelector(\"ha-textfield\") || ({} as any);\n      if (formElement) {\n        formElement.style.textOverflow = \"ellipsis\";\n      }\n      if (mdcRoot) {\n        mdcRoot.style.cursor = \"pointer\";\n      }\n    });\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\n        \"own-margin\",\n        Object.keys(this.schema.options).length >= SHOW_ALL_ENTRIES_LIMIT &&\n          !!this.schema.required\n      );\n    }\n  }\n\n  private _selectedChanged(ev: CustomEvent): void {\n    ev.stopPropagation();\n    if (ev.detail.source === \"property\") {\n      return;\n    }\n    this._handleValueChanged(\n      (ev.target as HaCheckListItem).value,\n      ev.detail.selected\n    );\n  }\n\n  private _valueChanged(ev: CustomEvent): void {\n    const { value, checked } = ev.target as HaCheckbox;\n    this._handleValueChanged(value, checked);\n  }\n\n  private _handleValueChanged(value, checked: boolean): void {\n    let newValue: string[];\n\n    if (checked) {\n      if (!this.data) {\n        newValue = [value];\n      } else if (this.data.includes(value)) {\n        return;\n      } else {\n        newValue = [...this.data, value];\n      }\n    } else {\n      if (!this.data.includes(value)) {\n        return;\n      }\n      newValue = this.data.filter((v) => v !== value);\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value: newValue,\n    });\n  }\n\n  private _handleOpen(ev: Event): void {\n    ev.stopPropagation();\n    this._opened = true;\n    this.toggleAttribute(\"opened\", true);\n  }\n\n  private _handleClose(ev: Event): void {\n    ev.stopPropagation();\n    this._opened = false;\n    this.toggleAttribute(\"opened\", false);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host([own-margin]) {\n        margin-bottom: 5px;\n      }\n      ha-button-menu {\n        display: block;\n        cursor: pointer;\n      }\n      ha-formfield {\n        display: block;\n        padding-right: 16px;\n        padding-inline-end: 16px;\n        padding-inline-start: initial;\n        direction: var(--direction);\n      }\n      ha-textfield {\n        display: block;\n        pointer-events: none;\n      }\n      ha-svg-icon {\n        color: var(--input-dropdown-icon-color);\n        position: absolute;\n        right: 1em;\n        top: 1em;\n        cursor: pointer;\n        inset-inline-end: 1em;\n        inset-inline-start: initial;\n        direction: var(--direction);\n      }\n      :host([opened]) ha-svg-icon {\n        color: var(--primary-color);\n      }\n      :host([opened]) ha-button-menu {\n        --mdc-text-field-idle-line-color: var(--input-hover-line-color);\n        --mdc-text-field-label-ink-color: var(--primary-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-multi_select\": HaFormMultiSelect;\n  }\n}\n","import { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport \"../ha-duration-input\";\nimport { HaFormElement, HaFormTimeData, HaFormTimeSchema } from \"./types\";\n\n@customElement(\"ha-form-positive_time_period_dict\")\nexport class HaFormTimePeriod extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public schema!: HaFormTimeSchema;\n\n  @property({ attribute: false }) public data!: HaFormTimeData;\n\n  @property() public label!: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @query(\"ha-time-input\", true) private _input?: HTMLElement;\n\n  public focus() {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-duration-input\n        .label=${this.label}\n        ?required=${this.schema.required}\n        .data=${this.data}\n        .disabled=${this.disabled}\n      ></ha-duration-input>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-positive_time_period_dict\": HaFormTimePeriod;\n  }\n}\n","import memoizeOne from \"memoize-one\";\nimport { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { HomeAssistant } from \"../../types\";\nimport type {\n  HaFormElement,\n  HaFormSelectData,\n  HaFormSelectSchema,\n} from \"./types\";\nimport type { SelectSelector } from \"../../data/selector\";\nimport \"../ha-selector/ha-selector-select\";\n\n@customElement(\"ha-form-select\")\nexport class HaFormSelect extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public schema!: HaFormSelectSchema;\n\n  @property() public data!: HaFormSelectData;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  private _selectSchema = memoizeOne(\n    (options): SelectSelector => ({\n      select: {\n        options: options.map((option) => ({\n          value: option[0],\n          label: option[1],\n        })),\n      },\n    })\n  );\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-selector-select\n        .hass=${this.hass}\n        .schema=${this.schema}\n        .value=${this.data}\n        .label=${this.label}\n        .helper=${this.helper}\n        .disabled=${this.disabled}\n        .required=${this.schema.required}\n        .selector=${this._selectSchema(this.schema.options)}\n        @value-changed=${this._valueChanged}\n      ></ha-selector-select>\n    `;\n  }\n\n  private _valueChanged(ev: CustomEvent) {\n    ev.stopPropagation();\n    let value: string | undefined = ev.detail.value;\n\n    if (value === this.data) {\n      return;\n    }\n\n    if (value === \"\") {\n      value = undefined;\n    }\n\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-select\": HaFormSelect;\n  }\n}\n","import { mdiEye, mdiEyeOff } from \"@mdi/js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport \"../ha-icon-button\";\nimport \"../ha-textfield\";\nimport type { HaTextField } from \"../ha-textfield\";\nimport type {\n  HaFormElement,\n  HaFormStringData,\n  HaFormStringSchema,\n} from \"./types\";\n\nconst MASKED_FIELDS = [\"password\", \"secret\", \"token\"];\n\n@customElement(\"ha-form-string\")\nexport class HaFormString extends LitElement implements HaFormElement {\n  @property() public schema!: HaFormStringSchema;\n\n  @property() public data!: HaFormStringData;\n\n  @property() public label!: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @state() private _unmaskedPassword = false;\n\n  @query(\"ha-textfield\") private _input?: HaTextField;\n\n  public focus(): void {\n    if (this._input) {\n      this._input.focus();\n    }\n  }\n\n  protected render(): TemplateResult {\n    const isPassword = MASKED_FIELDS.some((field) =>\n      this.schema.name.includes(field)\n    );\n    return html`\n      <ha-textfield\n        .type=${!isPassword\n          ? this._stringType\n          : this._unmaskedPassword\n          ? \"text\"\n          : \"password\"}\n        .label=${this.label}\n        .value=${this.data || \"\"}\n        .helper=${this.helper}\n        helperPersistent\n        .disabled=${this.disabled}\n        .required=${this.schema.required}\n        .autoValidate=${this.schema.required}\n        .name=${this.schema.name}\n        .autocomplete=${this.schema.autocomplete}\n        .suffix=${isPassword\n          ? // reserve some space for the icon.\n            html`<div style=\"width: 24px\"></div>`\n          : this.schema.description?.suffix}\n        .validationMessage=${this.schema.required ? \"Required\" : undefined}\n        @input=${this._valueChanged}\n      ></ha-textfield>\n      ${isPassword\n        ? html`<ha-icon-button\n            toggles\n            .label=${`${this._unmaskedPassword ? \"Hide\" : \"Show\"} password`}\n            @click=${this._toggleUnmaskedPassword}\n            .path=${this._unmaskedPassword ? mdiEyeOff : mdiEye}\n          ></ha-icon-button>`\n        : \"\"}\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    if (changedProps.has(\"schema\")) {\n      this.toggleAttribute(\"own-margin\", !!this.schema.required);\n    }\n  }\n\n  private _toggleUnmaskedPassword(): void {\n    this._unmaskedPassword = !this._unmaskedPassword;\n  }\n\n  private _valueChanged(ev: Event): void {\n    let value: string | undefined = (ev.target as HaTextField).value;\n    if (this.data === value) {\n      return;\n    }\n    if (value === \"\" && !this.schema.required) {\n      value = undefined;\n    }\n    fireEvent(this, \"value-changed\", {\n      value,\n    });\n  }\n\n  private get _stringType(): string {\n    if (this.schema.format) {\n      if ([\"email\", \"url\"].includes(this.schema.format)) {\n        return this.schema.format;\n      }\n      if (this.schema.format === \"fqdnurl\") {\n        return \"url\";\n      }\n    }\n    return \"text\";\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        position: relative;\n      }\n      :host([own-margin]) {\n        margin-bottom: 5px;\n      }\n      ha-textfield {\n        display: block;\n      }\n      ha-icon-button {\n        position: absolute;\n        top: 1em;\n        right: 12px;\n        --mdc-icon-button-size: 24px;\n        color: var(--secondary-text-color);\n      }\n\n      ha-icon-button {\n        inset-inline-start: initial;\n        inset-inline-end: 12px;\n        direction: var(--direction);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form-string\": HaFormString;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { dynamicElement } from \"../../common/dom/dynamic-element-directive\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-alert\";\nimport \"../ha-selector/ha-selector\";\nimport \"./ha-form-boolean\";\nimport \"./ha-form-constant\";\nimport \"./ha-form-float\";\nimport \"./ha-form-grid\";\nimport \"./ha-form-expandable\";\nimport \"./ha-form-integer\";\nimport \"./ha-form-multi_select\";\nimport \"./ha-form-positive_time_period_dict\";\nimport \"./ha-form-select\";\nimport \"./ha-form-string\";\nimport { HaFormDataContainer, HaFormElement, HaFormSchema } from \"./types\";\n\nconst getValue = (obj, item) =>\n  obj ? (!item.name ? obj : obj[item.name]) : null;\n\nconst getError = (obj, item) => (obj && item.name ? obj[item.name] : null);\n\n@customElement(\"ha-form\")\nexport class HaForm extends LitElement implements HaFormElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data!: HaFormDataContainer;\n\n  @property({ attribute: false }) public schema!: readonly HaFormSchema[];\n\n  @property() public error?: Record<string, string>;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property() public computeError?: (schema: any, error) => string;\n\n  @property() public computeLabel?: (\n    schema: any,\n    data: HaFormDataContainer\n  ) => string;\n\n  @property() public computeHelper?: (schema: any) => string | undefined;\n\n  @property() public localizeValue?: (key: string) => string;\n\n  public focus() {\n    const root = this.shadowRoot?.querySelector(\".root\");\n    if (!root) {\n      return;\n    }\n    for (const child of root.children) {\n      if (child.tagName !== \"HA-ALERT\") {\n        (child as HTMLElement).focus();\n        break;\n      }\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"root\" part=\"root\">\n        ${this.error && this.error.base\n          ? html`\n              <ha-alert alert-type=\"error\">\n                ${this._computeError(this.error.base, this.schema)}\n              </ha-alert>\n            `\n          : \"\"}\n        ${this.schema.map((item) => {\n          const error = getError(this.error, item);\n\n          return html`\n            ${error\n              ? html`\n                  <ha-alert own-margin alert-type=\"error\">\n                    ${this._computeError(error, item)}\n                  </ha-alert>\n                `\n              : \"\"}\n            ${\"selector\" in item\n              ? html`<ha-selector\n                  .schema=${item}\n                  .hass=${this.hass}\n                  .name=${item.name}\n                  .selector=${item.selector}\n                  .value=${getValue(this.data, item)}\n                  .label=${this._computeLabel(item, this.data)}\n                  .disabled=${item.disabled || this.disabled || false}\n                  .placeholder=${item.required ? \"\" : item.default}\n                  .helper=${this._computeHelper(item)}\n                  .localizeValue=${this.localizeValue}\n                  .required=${item.required || false}\n                  .context=${this._generateContext(item)}\n                ></ha-selector>`\n              : dynamicElement(`ha-form-${item.type}`, {\n                  schema: item,\n                  data: getValue(this.data, item),\n                  label: this._computeLabel(item, this.data),\n                  helper: this._computeHelper(item),\n                  disabled: this.disabled || item.disabled || false,\n                  hass: this.hass,\n                  computeLabel: this.computeLabel,\n                  computeHelper: this.computeHelper,\n                  context: this._generateContext(item),\n                })}\n          `;\n        })}\n      </div>\n    `;\n  }\n\n  private _generateContext(\n    schema: HaFormSchema\n  ): Record<string, any> | undefined {\n    if (!schema.context) {\n      return undefined;\n    }\n\n    const context = {};\n    for (const [context_key, data_key] of Object.entries(schema.context)) {\n      context[context_key] = this.data[data_key];\n    }\n    return context;\n  }\n\n  protected createRenderRoot() {\n    const root = super.createRenderRoot();\n    // attach it as soon as possible to make sure we fetch all events.\n    root.addEventListener(\"value-changed\", (ev) => {\n      ev.stopPropagation();\n      const schema = (ev.target as HaFormElement).schema as HaFormSchema;\n\n      const newValue = !schema.name\n        ? ev.detail.value\n        : { [schema.name]: ev.detail.value };\n\n      fireEvent(this, \"value-changed\", {\n        value: { ...this.data, ...newValue },\n      });\n    });\n    return root;\n  }\n\n  private _computeLabel(schema: HaFormSchema, data: HaFormDataContainer) {\n    return this.computeLabel\n      ? this.computeLabel(schema, data)\n      : schema\n      ? schema.name\n      : \"\";\n  }\n\n  private _computeHelper(schema: HaFormSchema) {\n    return this.computeHelper ? this.computeHelper(schema) : \"\";\n  }\n\n  private _computeError(error, schema: HaFormSchema | readonly HaFormSchema[]) {\n    return this.computeError ? this.computeError(error, schema) : error;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      .root > * {\n        display: block;\n      }\n      .root > *:not([own-margin]):not(:last-child) {\n        margin-bottom: 24px;\n      }\n      ha-alert[own-margin] {\n        margin-bottom: 4px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-form\": HaForm;\n  }\n}\n"],"names":[],"sourceRoot":""}