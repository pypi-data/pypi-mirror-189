<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="RPA.DocumentAI.Base64AI" type="LIBRARY" format="REST" scope="GLOBAL" generated="2023-02-03T13:07:21Z" specversion="4" source="./RPA/DocumentAI/Base64AI.py" lineno="15">
<version/>
<doc>Library to support `Base64.ai &lt;https://base64.ai/&gt;`_ service for intelligent
document processing (IDP).

Added with `rpaframework` version **19.0.0**.

Service supports identifying fields in the documents, which can be given to the
service in multiple different file formats and via URL.

**Robot Framework example usage**

.. code-block:: robotframework

    *** Settings ***
    Library   RPA.DocumentAI.Base64AI
    Library   RPA.Robocorp.Vault

    *** Tasks ***
    Identify document
        ${secrets}=   Get Secret  base64ai-auth
        Set Authorization  ${secrets}[email-address]   ${secrets}[apikey]
        ${results}=  Scan Document File
        ...   ${CURDIR}${/}invoice.pdf
        ...   model_types=finance/check/usa,finance/invoice/usa
        # Scan response contains list of detected models in the document
        FOR  ${result}  IN  @{results}
            Log To Console  Model: ${result}[model]
            Log To Console  Field keys: ${{','.join($result['fields'].keys())}}
            Log To Console  Fields: ${result}[fields]
            Log To Console  Text (OCR): ${result}[ocr]
        END


**Python example usage**

.. code-block:: python

    from RPA.DocumentAI.Base64AI import Base64AI
    from RPA.Robocorp.Vault import Vault

    secrets = Vault().get_secret("base64ai-auth")
    baselib = Base64AI()
    baselib.set_authorization(secrets["email-address"], secrets["apikey"])
    result = baselib.scan_document_file(
        "invoice.pdf",
        model_types="finance/invoice,finance/check/usa",
    )
    for r in result:
        print(f"Model: {r['model']}")
        for key, props in r["fields"].items():
            print(f"FIELD {key}: {props['value']}")
        print(f"Text (OCR): {r['ocr']}")</doc>
<tags>
</tags>
<inits>
</inits>
<keywords>
<kw name="Get Fields From Prediction Result" lineno="227">
<arguments repr="prediction: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="prediction: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>prediction</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
</arguments>
<doc>Helper keyword to get found fields from a prediction result.
For example see ``Scan Document File`` or ``Scan Document URL`` keyword.

:param prediction: prediction result dictionary
:return: list of found fields</doc>
<shortdoc>Helper keyword to get found fields from a prediction result. For example see ``Scan Document File`` or ``Scan Document URL`` keyword.</shortdoc>
</kw>
<kw name="Get User Data" lineno="238">
<arguments repr="">
</arguments>
<doc>Get user data including details on credits used and credits remaining
for the Base64 service.

Returned user data contains following keys:

    - givenName
    - familyName
    - email
    - hasWorkEmail
    - companyName
    - numberOfCredits
    - numberOfPages
    - numberOfUploads
    - numberOfCreditsSpentOnDocuments (visible if used)
    - numberOfCreditsSpentOnFaceDetection (visible if used)
    - numberOfCreditsSpentOnFaceRecognition (visible if used)
    - hasActiveAwsContract
    - subscriptionType
    - subscriptionPeriod
    - tags
    - ccEmails
    - status
    - remainingCredits (calculated by the keyword)

:return: object containing details on the API user

Robot Framework example:

.. code-block:: robotframework

    ${userdata}=   Get User Data
    Log To Console  I have still ${userdata}[remainingCredits] credits left

Python example:

.. code-block:: python

    userdata = baselib.get_user_data()
    print(f"I have still {userdata['remainingCredits']} credits left")</doc>
<shortdoc>Get user data including details on credits used and credits remaining for the Base64 service.</shortdoc>
</kw>
<kw name="Scan Document File" lineno="140">
<arguments repr="file_path: str, model_types: str | List[str] | None = None, mock: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="file_path: str">
<name>file_path</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="model_types: str | List[str] | None = None">
<name>model_types</name>
<type typedoc="string">str</type>
<type typedoc="list">List[str]</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mock: bool = False">
<name>mock</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Scan a document file. Can be given a ``model_types`` to
specifically target certain models.

:param file_path: filepath to the file
:param model_types: single model type or list of model types
:param mock: set to True to use /mock/scan endpoint instead of /scan
:return: result of the document scan

Robot Framework example:

.. code-block:: robotframework

    ${results}=    Scan Document File
    ...    ${CURDIR}${/}files${/}IMG_8277.jpeg
    ...    model_types=finance/check/usa,finance/invoice
    FOR    ${result}    IN    @{results}
        Log To Console    Model: ${result}[model]
        Log To Console    Fields: ${result}[fields]
        Log To Console    Text (OCR): ${result}[ocr]
    END

Python example:

.. code-block:: python

    result = baselib.scan_document_file(
        "./files/Invoice-1120.pdf",
        model_types="finance/invoice,finance/check/usa",
    )
    for r in result:
        print(f"Model: {r['model']}")
        for key, val in r["fields"].items():
            print(f"{key}: {val['value']}")
        print(f"Text (OCR): {r['ocr']}")</doc>
<shortdoc>Scan a document file. Can be given a ``model_types`` to specifically target certain models.</shortdoc>
</kw>
<kw name="Scan Document Url" lineno="185">
<arguments repr="url: str, model_types: str | List[str] | None = None, mock: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="model_types: str | List[str] | None = None">
<name>model_types</name>
<type typedoc="string">str</type>
<type typedoc="list">List[str]</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mock: bool = False">
<name>mock</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Scan a document URL. Can be given a ``model_types`` to
specifically target certain models.

:param url: valid url to a file
:param model_types: single model type or list of model types
:param mock: set to True to use /mock/scan endpoint instead of /scan
:return: result of the document scan

Robot Framework example:

.. code-block:: robotframework

    ${results}=    Scan Document URL
    ...    https://base64.ai/static/content/features/data-extraction/models//2.png
    FOR    ${result}    IN    @{results}
        Log To Console    Model: ${result}[model]
        Log To Console    Fields: ${result}[fields]
        Log To Console    Text (OCR): ${result}[ocr]
    END

Python example:

.. code-block:: python

    result = baselib.scan_document_url(
        "https://base64.ai/static/content/features/data-extraction/models//2.png"
    )
    for r in result:
        print(f"Model: {r['model']}")
        for key, props in r["fields"].items():
            print(f"FIELD {key}: {props['value']}")
        print(f"Text (OCR): {r['ocr']}")</doc>
<shortdoc>Scan a document URL. Can be given a ``model_types`` to specifically target certain models.</shortdoc>
</kw>
<kw name="Set Authorization" lineno="82">
<arguments repr="api_email: str, api_key: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="api_email: str">
<name>api_email</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="api_key: str">
<name>api_key</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Set Base64 AI request headers with email and key related to API.

:param api_email: email address related to the API
:param api_key: key related to the API

Robot Framework example:

.. code-block:: robotframework

    ${secrets}=   Get Secret  base64ai-auth
    Set Authorization    ${secrets}[email-address]    ${secrets}[apikey]

Python example:

.. code-block:: python

    secrets = Vault().get_secret("base64ai-auth")
    baselib = Base64AI()
    baselib.set_authorization(secrets["email-address"], secrets["apikey"])</doc>
<shortdoc>Set Base64 AI request headers with email and key related to API.</shortdoc>
</kw>
</keywords>
<datatypes>
</datatypes>
<typedocs>
<type name="boolean" type="Standard">
<doc>Strings ``TRUE``, ``YES``, ``ON`` and ``1`` are converted to Boolean ``True``,
the empty string as well as strings ``FALSE``, ``NO``, ``OFF`` and ``0``
are converted to Boolean ``False``, and the string ``NONE`` is converted
to the Python ``None`` object. Other strings and other accepted values are
passed as-is, allowing keywords to handle them specially if
needed. All string comparisons are case-insensitive.

Examples: ``TRUE`` (converted to ``True``), ``off`` (converted to ``False``),
``example`` (used as-is)
</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
<type>None</type>
</accepts>
<usages>
<usage>Get Fields From Prediction Result</usage>
<usage>Scan Document File</usage>
<usage>Scan Document Url</usage>
</usages>
</type>
<type name="dictionary" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#dict|dictionary]
literals. They are converted to actual dictionaries using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
dictionaries and other containers.

Examples: ``{'a': 1, 'b': 2}``, ``{'key': 1, 'nested': {'key': 2}}``
</doc>
<accepts>
<type>string</type>
<type>Mapping</type>
</accepts>
<usages>
<usage>Get Fields From Prediction Result</usage>
</usages>
</type>
<type name="float" type="Standard">
<doc>Conversion is done using Python's
[https://docs.python.org/library/functions.html#float|float] built-in function.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``3.14``, ``2.9979e8``, ``10 000.000 01``
</doc>
<accepts>
<type>string</type>
<type>Real</type>
</accepts>
<usages>
<usage>Get Fields From Prediction Result</usage>
</usages>
</type>
<type name="integer" type="Standard">
<doc>Conversion is done using Python's [https://docs.python.org/library/functions.html#int|int]
built-in function. Floating point
numbers are accepted only if they can be represented as integers exactly.
For example, ``1.0`` is accepted and ``1.1`` is not.

Starting from RF 4.1, it is possible to use hexadecimal, octal and binary
numbers by prefixing values with ``0x``, ``0o`` and ``0b``, respectively.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``42``, ``-1``, ``0b1010``, ``10 000 000``, ``0xBAD_C0FFEE``
</doc>
<accepts>
<type>string</type>
<type>float</type>
</accepts>
<usages>
<usage>Get Fields From Prediction Result</usage>
</usages>
</type>
<type name="list" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#list|list]
literals. They are converted to actual lists using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
lists and other containers.

Examples: ``['one', 'two']``, ``[('one', 1), ('two', 2)]``
</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>Get Fields From Prediction Result</usage>
<usage>Scan Document File</usage>
<usage>Scan Document Url</usage>
</usages>
</type>
<type name="None" type="Standard">
<doc>String ``NONE`` (case-insensitive) is converted to Python ``None`` object.
Other values cause an error.
</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>Get Fields From Prediction Result</usage>
<usage>Scan Document File</usage>
<usage>Scan Document Url</usage>
</usages>
</type>
<type name="string" type="Standard">
<doc>All arguments are converted to Unicode strings.</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>Get Fields From Prediction Result</usage>
<usage>Scan Document File</usage>
<usage>Scan Document Url</usage>
<usage>Set Authorization</usage>
</usages>
</type>
</typedocs>
</keywordspec>
